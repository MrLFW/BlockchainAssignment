commit c3f258218bdb21da58b7f4a9b239231ab563d16e
Author: “nk002734” <“nk002734@student.reading.ac.uk”>
Date:   Tue Mar 25 13:50:56 2025 +0000

    add mega help doc

diff --git a/Complete Practical Exercises & Coursework Support Document.pdf b/Complete Practical Exercises & Coursework Support Document.pdf
new file mode 100644
index 0000000..eed2bb4
--- /dev/null
+++ b/Complete Practical Exercises & Coursework Support Document.pdf	
@@ -0,0 +1,2431 @@
+   Blockchain Build
+     Flowchart and
+Fully commented code
+
+                                                                                                                                                                         0
+1
+Key
+Part 1 – Project Setup
+Part 2 – Blocks and the Blockchain
+Part 3 – Transactions and Digital Signatures
+Part 4 – Consensus Algorithms (Proof-of-Work)
+Part 5 – Validation
+
+Throughout these documents, the colours chosen highlight sections of the code that relate to different parts of the assignment tasks/lab script (Parts 1-5), this way it is easy to
+follow the steps taken to arrive at the final solution and it separates the different topics/themes/concepts for which students can then refer back to the tutorials for more
+information.
+
+The code is organised by class (from the smallest to the largest element of the hierarchy i.e. Transaction->Block->Blockchain->Application) and each class is comprised of
+variables, constructors (initialising the variables) and then functions (operating on these values). I have indented these to make them stand out and easier to read.
+
+/*********************************************************************************************************************************************/
+
+/** TRANSACTION.CS                                                                                                                               **/
+
+/** Class representing transactions                                                        **/
+
+/*********************************************************************************************************************************************/
+
+using System;
+
+using System.Collections.Generic;
+
+using System.Linq;
+
+using System.Security.Cryptography;
+
+using System.Text;
+
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+
+  class Transaction
+  {
+
+   /* Transaction Variables */
+
+DateTime timestamp;                            // Time of creation
+public String senderAddress,
+                                               // Participants public key addresses
+                recipientAddress;              // Quantities transferred
+public double amount, fee;                     // Attributes for verification of validity
+public String hash, signature;
+
+                                                                                                                                                                                     2
+/* Transaction Constructor */
+
+public Transaction(String from, String to, double amount, double fee, String privateKey)
+{
+
+  this.timestamp = DateTime.Now;
+
+this.senderAddress = from;
+this.recipientAddress = to;
+
+this.amount = amount;
+this.fee = fee;
+
+  this.hash = CreateHash();                                                  // Hash the transaction attributes
+  this.signature = Wallet.Wallet.CreateSignature(from, privateKey, hash);    // Sign the hash with the senders private key ensuring validity
+}
+
+/* Transaction Functions */
+
+public String CreateHash()                                                   // Hash the transaction attributes using SHA256
+{
+
+  String hash = String.Empty;
+  SHA256 hasher = SHA256Managed.Create();
+
+String input = timestamp + senderAddress + recipientAddress + amount + fee;  // Concatenate all transaction properties
+Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));         // Apply the hash function to the "input" string
+foreach (byte x in hashByte)
+                                                                             // Reformat to a string
+  hash += String.Format("{0:x2}", x);
+
+  return hash;
+}
+
+public override string ToString()                                            // Represent a transaction as a string for output to UI
+{
+
+  return " [TRANSACTION START]"
+     + "\n Timestamp: " + timestamp
+     + "\n -- Verification --"
+     + "\n Hash: " + hash
+
+                                                                                                                                              3
+        + "\n Signature: " + signature
+        + "\n -- Quantities --"
+        + "\n Transferred: " + amount + " Assignment Coin"
+        + "\t Fee: " + fee
+        + "\n -- Participants --"
+        + "\n Sender: " + senderAddress
+        + "\n Reciever: " + recipientAddress
+        + "\n [TRANSACTION END]";
+
+     }
+  }
+}
+
+                                                            4
+/*********************************************************************************************************************************************/
+
+/** BLOCK.CS                                                                                                                                     **/
+
+/** Class representing a Block instance                                                            **/
+
+/*********************************************************************************************************************************************/
+
+using System;
+
+using System.Collections.Generic;
+
+using System.Linq;
+
+using System.Security.Cryptography;
+
+using System.Text;
+
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+
+  class Block
+  {
+
+/* Block Variables */                    // Time of creation
+
+private DateTime timestamp;
+
+private int index,                       // Position of the block in the sequence of blocks
+        difficulty = 4;                  // An arbitrary number of 0's to proceed a hash value
+
+public String prevHash,                  // A reference pointer to the previous block
+         hash,                           // The current blocks "identity"
+         merkleRoot,                     // The merkle root of all transactions in the block
+         minerAddress;                   // Public Key (Wallet Address) of the Miner
+
+public List<Transaction> transactionList; // List of transactions in this block
+
+// Proof-of-work                         // Number used once for Proof-of-Work and mining
+public long nonce;
+
+// Rewards                               // Simple fixed reward established by "Coinbase"
+public double reward;
+
+/* Block constructors */
+
+public Block()                                                                   // Genesis Block
+
+                                                                                                                                                      5
+{
+  this.timestamp = DateTime.Now;
+  this.index = 0;
+  this.transactionList = new List<Transaction>();
+  this.hash = Mine();
+
+}
+
+public Block(Block lastBlock, List<Transaction> transactions, String minerAddress) // Standard Block
+{
+
+  this.timestamp = DateTime.Now;
+
+this.index = lastBlock.index + 1;
+this.prevHash = lastBlock.hash;
+
+this.minerAddress = minerAddress;                  // The wallet to be credited the reward for the mining effort
+this.reward = 1.0;                                 // Assign a simple fixed value reward
+
+transactions.Add(createRewardTransaction(transactions)); // Create and append the reward transaction
+this.transactionList = new List<Transaction>(transactions); // Assign provided transactions to the block
+
+  this.merkleRoot = MerkleRoot(transactionList);   // Calculate the merkle root of the blocks transactions
+  this.hash = Mine();                              // Conduct PoW to create a hash which meets the given difficulty requirement
+}
+
+/* Block Functions */                                                 // Hashes the entire Block object
+
+public String CreateHash()
+{
+
+  String hash = String.Empty;
+  SHA256 hasher = SHA256Managed.Create();
+
+String input = timestamp.ToString() + index + prevHash + nonce + merkleRoot; // Concatenate all of the blocks properties including nonce as to generate a new hash on each call
+
+Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));  // Apply the SHA hash function to the block as represented by the string "input"
+
+*/                                                                    // Reformat to a string
+foreach (byte x in hashByte)
+
+  hash += String.Format("{0:x2}", x);
+
+                                                                                                                                                                                 6
+  return hash;
+}
+
+public String Mine()                        // Create a Hash which satisfies the difficulty level required for PoW
+{                                           // Initalise the nonce
+                                            // Hash the block
+  nonce = 0;                                // A string representing the “difficulty” for analysing the PoW requirement
+  String hash = CreateHash();               // Check the resultant hash against the "re" string
+                                            // Increment the nonce should the difficulty level not be satisfied
+  String re = new string('0', difficulty);  // Rehash with the new nonce as to generate a different hash
+
+  while(!hash.StartsWith(re))               // Return the hash meeting the difficulty requirement
+  {
+
+     nonce++;
+     hash = CreateHash();
+  }
+
+  return hash;
+}
+
+public static String MerkleRoot(List<Transaction> transactionList)     // Merkle Root Algorithm - Encodes transactions within a block into a single hash
+{                                                                      // Get a list of transaction hashes for "combining"
+
+  List<String> hashes = transactionList.Select(t => t.hash).ToList();
+
+// Handle Blocks with...                                               // No transactions
+if (hashes.Count == 0)
+{                                                                      // One transaction - hash with "self"
+
+  return String.Empty;                                                 // Multiple transactions - Repeat until tree has been traversed
+}                                                                      // Keep track of current "level" of the tree
+if (hashes.Count == 1)
+{
+
+  return HashCode.HashTools.combineHash(hashes[0], hashes[0]);
+}
+while (hashes.Count != 1)
+{
+
+  List<String> merkleLeaves = new List<String>();
+
+for (int i=0; i<hashes.Count; i+=2)                                    // Step over neighbouring pair combining each
+
+                                                                                                                                                          7
+      {
+
+         if (i == hashes.Count - 1)
+
+         {
+
+            merkleLeaves.Add(HashCode.HashTools.combineHash(hashes[i], hashes[i])); // Handle an odd number of leaves
+
+         }
+
+         else
+
+         {
+
+            merkleLeaves.Add(HashCode.HashTools.combineHash(hashes[i], hashes[i + 1])); // Hash neighbours leaves
+
+         }
+
+      }
+
+      hashes = merkleLeaves;                                                     // Update the working "layer"
+
+   }
+
+   return hashes[0];                                                             // Return the root node
+
+}
+
+public Transaction createRewardTransaction(List<Transaction> transactions)       // Create reward for incentivising the mining of block
+{
+                                                                                 // Sum all transaction fees
+  double fees = transactions.Aggregate(0.0, (acc, t) => acc + t.fee);            // Issue reward as a transaction in the new block
+  return new Transaction("Mine Rewards", minerAddress, (reward + fees), 0, "");
+}
+
+public override string ToString()                                                // Concatenate all properties to output to the UI
+{
+
+  return "[BLOCK START]"
+     + "\nIndex: " + index
+     + "\tTimestamp: " + timestamp
+     + "\nPrevious Hash: " + prevHash
+     + "\n-- PoW --"
+     + "\nDifficulty Level: " + difficulty
+     + "\nNonce: " + nonce
+     + "\nHash: " + hash
+     + "\n-- Rewards --"
+     + "\nReward: " + reward
+     + "\nMiners Address: " + minerAddress
+     + "\n-- " + transactionList.Count + " Transactions --"
+     +"\nMerkle Root: " + merkleRoot
+     + "\n" + String.Join("\n", transactionList)
+
+                                                                                                                                         8
+        + "\n[BLOCK END]";
+
+     }
+  }
+}
+
+/*********************************************************************************************************************************************/
+
+/** BLOCKCHAIN.CS                                                                                                                                **/
+
+/** Class representing the entire Blockchain                         **/
+
+/*********************************************************************************************************************************************/
+
+using System;
+
+using System.Collections.Generic;
+
+using System.Linq;
+
+using System.Text;
+
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+
+  class Blockchain
+  {
+
+/* Blockchain Attributes */                                          // List of block objects forming the blockchain
+                                                                     // Maximum number of transactions per block
+public List<Block> blocks;                                           // List of pending transactions to be mined
+private int transactionsPerBlock = 5;
+public List<Transaction> transactionPool = new List<Transaction>();
+
+  /* Blockchain Constructor */                                       // Initialises the list of blocks and generates the genesis block
+                                                                     // Create and append the Genesis Block
+public Blockchain()
+{
+
+  this.blocks = new List<Block>()
+  {
+
+     new Block()
+  };
+}
+
+                                                                                                                                                      9
+/* Blockchain Functions */                          // Prints the block at the specified index to the UI
+                                                    // Check if referenced block exists
+public String GetBlockAsString(int index)           // Return block as a string
+{
+                                                    // Retrieves the most recently appended block in the blockchain
+  if (index >= 0 && index < blocks.Count)
+
+     return blocks[index].ToString();
+  else
+
+     return "No such block exists";
+}
+
+public Block GetLastBlock()
+{
+
+  return blocks[blocks.Count - 1];
+}
+
+public List<Transaction> GetPendingTransactions()                   // Retrieve pending transactions and remove from pool
+{                                                                   // Determine the number of transactions to retrieve dependent on the number of pending transactions and the limit specified
+                                                                    // "Pull" transactions from the transaction list (modifying the original list)
+  int n = Math.Min(transactionsPerBlock, transactionPool.Count);
+  List<Transaction> transactions = transactionPool.GetRange(0, n);  // Return the extracted transactions
+  transactionPool.RemoveRange(0, n);
+  return transactions;
+}
+
+public static bool ValidateHash(Block block)        // Check validity of a blocks hash by recomputing the hash and comparing with the mined value
+{
+
+  String rehash = block.CreateHash();
+  return rehash.Equals(block.hash);
+}
+
+public static bool ValidateMerkleRoot(Block block)  // Check validity of the merkle root by recalculating the root and comparing with the mined value
+
+                                                                                                                                                                                                 10
+{
+  String reMerkle = Block.MerkleRoot(block.transactionList);
+  return reMerkle.Equals(block.merkleRoot);
+
+}
+
+public double GetBalance(String address)                        // Check the balance associated with a wallet based on the public key
+
+{                                                               // Accumulator value for current Wallet
+  double balance = 0;
+
+  foreach(Block block in blocks)                                // Loop through all approved transactions in order to assess account balance
+  {                                                             // Credit funds received
+                                                                // Debit payments placed
+     foreach(Transaction transaction in block.transactionList)
+     {
+
+        if (transaction.recipientAddress.Equals(address))
+        {
+
+           balance += transaction.amount;
+        }
+        if (transaction.senderAddress.Equals(address))
+        {
+
+           balance -= (transaction.amount + transaction.fee);
+        }
+     }
+  }
+  return balance;
+}
+
+     public override string ToString()                          // Output all blocks of the blockchain as a string
+     {
+
+        return String.Join("\n", blocks);
+     }
+  }
+}
+
+                                                                                                                                              11
+/*********************************************************************************************************************************************/
+
+/** BLOCKCHAINAPP.CS                                                                                                                             **/
+
+/** Class for handling user interactions with the blockchain via the Windows Form  **/
+
+/*********************************************************************************************************************************************/
+
+using System;
+using System.Collections.Generic;
+using System.Windows.Forms;
+
+namespace BlockchainAssignment
+{
+
+  public partial class BlockchainApp : Form
+  {
+
+     // Global blockchain object
+     private Blockchain blockchain;
+
+// Default App Constructor
+public BlockchainApp()
+{
+
+  // Initialise UI Components
+  InitializeComponent();
+  // Create a new blockchain
+  this.blockchain = new Blockchain();
+  // Update UI with an initalisation message
+  UpdateText("New blockchain initialised!");
+}
+
+/* PRINTING */
+
+// Helper method to update the UI with a provided message
+private void UpdateText(String text)
+{
+
+  output.Text = text;
+}
+
+// Print entire blockchain to UI
+private void ReadAll_Click(object sender, EventArgs e)
+{
+
+                                                                                                                                                                                                                  12
+  UpdateText(blockchain.ToString());
+}
+
+// Print Block N (based on user input)
+private void PrintBlock_Click(object sender, EventArgs e)
+{
+
+  if (Int32.TryParse(blockNo.Text, out int index))
+     UpdateText(blockchain.GetBlockAsString(index));
+
+  else
+     UpdateText("Invalid Block No.");
+
+}
+
+// Print pending transactions from the transaction pool to the UI
+private void PrintPendingTransactions_Click(object sender, EventArgs e)
+{
+
+  UpdateText(String.Join("\n", blockchain.transactionPool));
+}
+
+/* WALLETS */
+// Generate a new Wallet and fill the public and private key fields of the UI
+private void GenerateWallet_Click(object sender, EventArgs e)
+{
+
+  Wallet.Wallet myNewWallet = new Wallet.Wallet(out string privKey);
+
+  publicKey.Text = myNewWallet.publicID;
+  privateKey.Text = privKey;
+}
+
+// Validate the keys loaded in the UI by comparing their mathematical relationship
+private void ValidateKeys_Click(object sender, EventArgs e)
+{
+
+  if (Wallet.Wallet.ValidatePrivateKey(privateKey.Text, publicKey.Text))
+     UpdateText("Keys are valid");
+
+  else
+     UpdateText("Keys are invalid");
+
+}
+
+// Check the balance of current user
+private void CheckBalance_Click(object sender, EventArgs e)
+{
+
+                                                                                                                                                                                                                  13
+  UpdateText(blockchain.GetBalance(publicKey.Text).ToString() + " Assignment Coin");
+}
+
+/* TRANSACTION MANAGEMENT */
+
+// Create a new pending transaction and add it to the transaction pool
+private void CreateTransaction_Click(object sender, EventArgs e)
+{
+
+  Transaction transaction = new Transaction(publicKey.Text, reciever.Text, Double.Parse(amount.Text), Double.Parse(fee.Text), privateKey.Text);
+  blockchain.transactionPool.Add(transaction);
+  UpdateText(transaction.ToString());
+}
+
+  /* BLOCK MANAGEMENT */
+
+// Conduct Proof-of-work in order to mine transactions from the pool and submit a new block to the Blockchain
+private void NewBlock_Click(object sender, EventArgs e)
+{
+
+  // Retrieve pending transactions to be added to the newly generated Block
+  List<Transaction> transactions = blockchain.GetPendingTransactions();
+
+  // Create and append the new block - requires a reference to the previous block, a set of transactions and the miners public address (For the reward to be issued)
+  Block newBlock = new Block(blockchain.GetLastBlock(), transactions, publicKey.Text);
+  blockchain.blocks.Add(newBlock);
+
+  UpdateText(blockchain.ToString());
+}
+
+/* BLOCKCHAIN VALIDATION */
+
+// Validate the integrity of the state of the Blockchain
+private void Validate_Click(object sender, EventArgs e)
+{
+
+// CASE: Genesis Block - Check only hash as no transactions are currently present
+if(blockchain.blocks.Count == 1)
+
+{
+
+   if (!Blockchain.ValidateHash(blockchain.blocks[0]))    // Recompute Hash to check validity
+
+   UpdateText("Blockchain is invalid");
+
+   else
+
+   UpdateText("Blockchain is valid");
+
+   return;
+
+                                                                                                                                                                      14
+}
+
+        for (int i=1; i<blockchain.blocks.Count-1; i++)                         // Check hash "chain"
+        {                                                                       // Check each blocks hash
+                                                                                // Check transaction integrity using Merkle Root
+           if(
+             blockchain.blocks[i].prevHash != blockchain.blocks[i - 1].hash ||
+             !Blockchain.ValidateHash(blockchain.blocks[i]) ||
+             !Blockchain.ValidateMerkleRoot(blockchain.blocks[i])
+
+          )
+          {
+
+             UpdateText("Blockchain is invalid");
+             return;
+          }
+        }
+        UpdateText("Blockchain is valid");
+     }
+  }
+}
+
+                                                                                                                                  15
+       Next is How
+       Your Report
+    Will be Marked
+and Feedback provided
+
+                                                                                                                                                                          16
+Aspect                                Description                                                         Potential Marks Rewarded           Notes
+                                      Student ID Number xxxxxxxx
+
+                                                                                                          Implementation      Documentation
+
+Customising the User-Interface             Practical 1 - Project Setup                                                    1                  1 Windows Forms and User Interface design
+Event Handlers                        Addition of Buttons and Text Boxes
+                                      Implementation of Event Handler                                                     1                  1 Handling user input
+
+                                                                                                                          2                  2 Sub-total for the above criteria
+
+Block and Blockchain Class Structure  Practical 2 - Blocks and Blockchain                                                 1                  1 Data-type justifications
+Instantiation of a new Blockchain     Appropriate variables and data-types including list data-structure
+Genesis Block Creation                Object definition and initialisation in Blockchain app                              1                  1 Class hierarchy description
+Hashing                               Necessary constructor modifications
+Printing Blocks                       Hashing the entire block using the SHA256 algorithm                                 1                  1 Special properties of Genesis blocks
+                                      Outputting hashes as hexadecimal strings in the UI
+                                                                                                                          1                  1 Description of hashing and hash properties
+
+                                                                                                                          1                  0 Description missing
+
+                                                                                                                          5                  4 Sub-total for the above criteria
+
+Wallet Creation                  Practical 3 - Transactions and Digital Signatures                                        1                  1 Key usage and mathematical relationship/properties
+Setting up Transactions                 Asymmetric key generation and UI adaptation
+Digital Signature Creation              Transaction class implementation - Variables and constructor                      1                  0 Description missing
+Processing Transactions                 Signing the Hash using Senders Private Key
+Transaction Pools                       Generate a transaction and printing the data                                      1                  1 Use in authentication of transactions
+                                        Implemented as a list of "pending" transactions
+                                                                                                                          1                  0 Description missing
+
+                                                                                                                          1                  1 Creating and managing Transaction Pools in Blockchains
+
+                                                                                                                          5                  3 Sub-total for the above criteria
+
+                                 Practical 4 - Consensus Algorithms (Proof-of-Work)
+
+Generating new Blocks                 Adding "Empty" Blocks to a Blockchain                                               2                  2 Blockchain-Block relationship
+
+Adding transactions into Blocks       Transaction Lists                                                                   2                  2 Block composition
+
+Proof-of-Work                         Algorithm Implementation                                                            2                  2 Properties, Advantages and Disadvantages etc.
+
+Nonce Generation                      Random Number Generation                                                            1                  1 Requirement for nonce in Blocks
+
+Difficulty Level                      Value selection and checking                                                        1                  1 Justification of value selected
+
+Rewards and Fees                      Coinbase configuration                                                              2                  2 Mining and Incentives: Driving transactions
+
+                                                                                                                          10                 10 Sub-total for the above criteria
+
+                                      Practical 5 – Validation
+
+                                                                                                                                                                                                       17
+Validating the Blockchain structure  Block Coherence and contiguity checks                                         2   2 How trustability is achieved
+Checking and Validating Balances     Ledger Tracing
+Validating Blocks and Merkle Root    Implementing Merkle Root Algorithm - Combining Hashes                         2   2 Double spend prevention
+Validating Transactions              Checking digital signatures
+Testing the Validation               Verification                                                                  2   2 Merkle root properties and benefits
+
+                                                                                                                   2   2 Authenticity and Integrity achieved as a result of usage
+
+                                                                                                                   2   2 Incorporation of "rules"
+
+                                                                                                                   10  10 Sub-total for the above criteria
+
+Multi-threading                               Assignment Tasks                                                     3   3 Increasing the rate in which nodes mine blocks
+e-Nonce                               Task 1 - Extending Proof-of-Work
+Sampling                             Callbacks/delegates and threading                                             1   1 Overcoming "Duplication of work" in parallelised systems
+                                     Additional nonce generation
+                                     Comparative study                                                             1   1 Performance comparisons
+
+                                                                                                                   5   5 Sub-total for the above criteria
+
+Block Time Measurement  Task 2 - Adjusting Difficulty Level for Proof-of-Work                                      1   1 Using "Block Time" as a metric
+Adaptive Difficulty              Calculation of "Block Time"
+Block Time Selection             Adaptive Difficulty Algorithm Implementation                                      3   3 Evidence of background reading
+                                 Adaptivity etc.
+                                                                                                                   1   1 Justification of design and implementation
+
+                                                                                                                   5   5 Sub-total for the above criteria
+
+Pool Adaptation         Task 3 - Implementing Alternative Mining Preference Settings                               1   1 Potential use case for each preference
+Greedy                                 Use-cases
+Altruistic                             Highest Fee                                                                 1   1√
+Random                                 Longest Wait
+Address Preference                     Random Selection                                                            1   1√
+                                       Owner
+                                                                                                                   1   1√
+
+                                                                                                                   1   1√
+
+                                                                                                                   5   5 Sub-total For the above criteria
+
+Other                                Task 4 - Other Extension or Modification                                      5   5 Design and Implementation justification
+                                        Alternate consensus algorithm implementation, networking, smart contracts
+                                        etc.
+
+                                                                                                                   5   5 Sub-total for the above criteria
+
+Total Assessment Mark                                                                                                       44
+Percentage Mark                                                                                                        93.62%
+
+                                                                                                                                                                                         18
+ Practical Exercises
+          and
+
+Coursework Support
+
+                                                                                                                                                                  19
+Blockchain Lab Practical Guided Exercises to
+Support the Coursework Assignment
+
+Contents
+Introduction ......................................................................................................... Error! Bookmark not defined.
+
+   Practical Guided Exercises and Assignment ...................................................... Error! Bookmark not defined.
+      Marking Scheme .......................................................................................... Error! Bookmark not defined.
+
+Part 1 – Project Setup ........................................................................................... Error! Bookmark not defined.
+   Setup................................................................................................................ Error! Bookmark not defined.
+   Customising the UI ........................................................................................... Error! Bookmark not defined.
+
+Part 2 – Blocks and the Blockchain........................................................................ Error! Bookmark not defined.
+   Creating the classes and their contents ............................................................ Error! Bookmark not defined.
+   Hashing and creating the Genesis Block............................................................ Error! Bookmark not defined.
+   Printing a Block to the UI .................................................................................. Error! Bookmark not defined.
+
+Part 3 – Transactions and Digital Signatures ......................................................... Error! Bookmark not defined.
+   Wallets & Private and Public Key Generation.................................................... Error! Bookmark not defined.
+   Setting up Transactions .................................................................................... Error! Bookmark not defined.
+   Processing Transactions & Transaction Pools.................................................... Error! Bookmark not defined.
+
+Part 4 – Consensus Algorithms (Proof-of-Work).................................................... Error! Bookmark not defined.
+   Generating new Blocks ..................................................................................... Error! Bookmark not defined.
+   Adding transactions into Blocks ........................................................................ Error! Bookmark not defined.
+   Proof-of-Work .................................................................................................. Error! Bookmark not defined.
+   Difficulty (Level) ............................................................................................... Error! Bookmark not defined.
+   Rewards & Fees ................................................................................................ Error! Bookmark not defined.
+
+Part 5 – Validation ................................................................................................ Error! Bookmark not defined.
+   Validating the Blockchain Structure .................................................................. Error! Bookmark not defined.
+   Checking and Validating Balance ...................................................................... Error! Bookmark not defined.
+   Validating Blocks & Merkle Root....................................................................... Error! Bookmark not defined.
+   Validating Transactions .................................................................................... Error! Bookmark not defined.
+   Testing the validation ....................................................................................... Error! Bookmark not defined.
+
+Part 6 – Assignment Tasks .................................................................................... Error! Bookmark not defined.
+   Threading during Proof-of-Work....................................................................... Error! Bookmark not defined.
+   Adjusting the Difficulty Level in Proof-of-Work ................................................. Error! Bookmark not defined.
+   Mining Settings................................................................................................. Error! Bookmark not defined.
+      Your own idea .............................................................................................. Error! Bookmark not defined.
+
+Introduction
+
+The goal of these practical sessions is to create an offline Blockchain application. This application can be
+developed in a language of your choice, although it is highly recommended to use C#. This brief operates
+on the assumption that C# is used and resources such as the template code are in C#. C# is an object-
+
+                                                                                                                             1
+oriented language and is very similar to Java, and it should be relatively easy to pick up. Visual Studio is the
+recommended IDE for developing in C#, the latest version can be found here.
+
+Along with this brief you should find a visual studio project which will provide the template code for the
+assignment. This code should be built upon during the practicals. The template makes use of Windows
+Forms for the UI. Windows Forms is simple and quick to use, meaning you can focus on the technical
+aspects more than the appearance. This template also includes ready-made classes that will be used to
+develop features.
+
+Practical Guided Exercises and Assignment
+
+It is expected that you will complete the first 5 parts of this brief during the practical sessions. The
+assignment tasks are based on the application you will have made in the first 5 parts. Marks for the
+assignment are allocated as follows:
+
+Table 1: Marking Scheme
+
+Part 1 – Project Setup                           Evidence of       Report      Total
+Part 2 – Blocks and the Blockchain             implementation
+Part 3 – Transactions and Digital Signatures   3               2           5
+Part 4 – Consensus Algorithms (Proof-of-Work)  5               5           10
+Part 5 – Validation                            5               5           10
+Part 6 – Assignment Tasks                      10              10          20
+                                               10              10          20
+                                               15              20          35
+                                               48              52          (100)
+
+For each part in this brief, you are expected to provide evidence of implementation alongside a report which
+details your understanding of the topic.
+
+In part 6 of the assignment, you are only expected to complete 3 out of 4 of the sections to achieve the
+maximum of 35 marks. However, if you choose to do all four you may be able to score more marks (not
+more than 35).
+
+This brief will require students to develop a basic offline Blockchain application that includes the following:
+
+    • Blockchain made of cryptographically connected Blocks;
+    • Transaction generation – including digital signature via asymmetric encryption;
+    • A Proof-of-Work consensus algorithm – including hashing and threading;
+    • Validation methods to ensure the Blockchain is valid;
+    • A basic UI that can verify the implementation of the above features.
+
+The following instructions are built to ease you into programming with C# and Windows Forms and
+gradually get more complex throughout.
+
+Part 1 – Project Setup
+
+Setup
+
+Download the BlockchainAssignment Project from Blackboard. Open Visual Studio click open
+project/solution and select BlockchainAssignment.sln. In the Solution explorer you will see the
+BlockchainAssignment.csproj. Expand this to find the components of the project, including the code,
+references, and properties. For us, the important parts are the BlockchainApp.cs, HashCode-, and Wallet-
+folders.
+
+Double click the BlockchainApp.cs to open a Windows Form, which shows the basic UI of the App. You are
+free to modify it during this assignment as you see fit but ensure that the results are clear (as you are
+required to provide screenshots in your report). Right click BlockchainApp.cs and click view code to see the
+underlying code behind the UI. Currently it is mostly empty.
+
+                                                                                                                             2
+The HashCode and Wallet folders are host to ready-made code that will be applied later in this assignment.
+Wallet is responsible for the asymmetric encryption (public and private key pairs) and digital signatures in
+transaction. HashCode is responsible for combining hashes and converting hashes to and from byte arrays
+to strings both ways. This code is provided to help reduce the workload of the project, such that time can
+be evenly distributed across each of the components.
+
+Customising the UI
+
+To familiarise yourself with Windows Forms and C# briefly add some functionality to the UI. First add a
+button, on the left side of the screen a horizontal tab titled Toolbox should be visible.
+
+Click Toolbox and a window will expand, click All Windows Forms or Common Controls, and click and drag
+Button onto the UI. Now search for a TextBox in the toolbox and drag it onto the UI. Your UI should now
+appear as the following:
+
+Click button1 once to open its properties in the bottom left. Change its text property to say ‘Print’ instead
+of ‘button1’. Now double click the button and you will be taken to the underlying code, a new function for
+clicking the button is created after double clicking it. Next you can write some code that takes the text
+from the TextBox we added and prints it to the larger textbox above, when we click the Button. To get the
+names of the Textboxes you can click them in the UI form, in this case the large black text box is richTextBox1
+and the smaller text box is textBox1.
+Code:
+
+Output:
+                                                                                                                             3
+Note: This textbox and button can be removed or re-purposed after this section as you wish.
+                                                                                                                    4
+Part 2 – Blocks and the Blockchain
+
+Creating the classes and their contents
+
+C# is an object-orientated language. Therefore, it makes sense to exploit this with the object-orientated
+nature of Blockchain. Right click BlockchainAssignmentAnswer.csproj and click add then new item. Add a
+new class called Blockchain.cs and another class called Block.cs. A Blockchain consists of a chain of blocks,
+so add a list variable into Blockchain.cs that holds Blocks.
+
+                                                                  1: Blockchain.cs code
+
+The Blockchain itself needs to be initialised in the code. You can initialise in it BlockchainApp.cs or initialise
+it in Program.cs (Main) and pass into the BlockchainApp.cs.
+
+                                                       2: Initialising blockchain within the form
+
+Now you can add variables into Block.cs. Typically, a Block within a Blockchain would have many variables.
+Many of these will added throughout the duration of the assignment, so write the code carefully such that
+it can be easily changed at a later point. For now, the following variables should be added to the Block class
+with appropriate types:
+
+    • A timestamp, set when the Block is made
+    • An index; the position of the Block within the Blockchain
+    • Hash of the Block
+    • Hash of the previous Block
+Now create a constructor for a new Block to assign these variables. The constructor should have two
+arguments, the hash of the prior Block and the index of the prior Block. Alternatively, you can pass the
+whole previous Block through (In this case you will need to set the access modifiers for the variables to
+public). The timestamp should be set to the current time (current time can be retrieved using
+
+                                                                                                                             5
+Datetime.Now), and the previous hash and current index should be set with respect to the given arguments.
+Assignment of the hash of the Block will be covered in the next section.
+
+                                                      3: A Constructor with one argument in C#
+
+Hashing and creating the Genesis Block
+
+A genesis block is the first block of a block chain. Modern versions of Bitcoin number it as block 0, though
+very early versions counted it as block 1
+We now need to generate a hash to finish the assignment of the variables in Block.cs. First, we need to
+create a new method in Block.cs that will create the hash. This method will also be extended as w required
+during the course of the assignment.
+
+                                               4: An empty method in C# that should return a String
+
+The hash of a Block is normally the hash of all information within the Block. Therefore, we want to combine
+the index, timestamp and previous hash and hash the combination. The code displayed below uses the
+SHA256 to produce a hash. You can copy it into your CreateHash method.
+SHA-256 and SHA-512 are novel hash functions computed with 32-bit and 64-bit words, respectively.
+https://emn178.github.io/online-tools/sha256.html
+
+SHA256 hasher = SHA256Managed.Create();
+String input = index.ToString() + timestamp.ToString() + prevHash;
+Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
+String hash = string.Empty;
+foreach (byte x in hashByte)
+
+           hash += String.Format("{0:x2}", x);
+return hash;
+
+Finally, now assign the value of the hash variable in the constructor to the output of CreateHash().
+Now we have a constructor to create Blocks, but no methods that create them. As stated, the first Block in
+a Blockchain has no previous hash and is called the Genesis Block. To generate a Genesis Block we must
+create another constructor in Block.cs. This constructor will have no arguments, it will assign the previous
+hash to an empty string and the index to 0.
+
+Now do the following:
+    • Create a constructor for Blockchain.cs
+    • This constructor calls the Genesis Block constructor in Block.cs.
+    • The Genesis Block is then added to the Blockchains list of Blocks.
+
+Now a genesis Block should be created when the app is started.
+
+                                                                                                                             6
+Tip: Debugging in C# is very easy and very useful. You can place a breakpoint at any point in the code and
+view the state of variables and objects in real-time.
+
+                                      5: An example of debugging in C# that shows the contents of Blocks
+
+Printing a Block to the UI
+
+Now that we have generated a Genesis Block, we should verify this by displaying its variables to the UI. To
+achieve this the following should be done.
+
+    • Add a new method in Block.cs to return a string containing the Block index, previous hash, hash and
+         timestamp.
+
+    • Add a new method in Blockchain.cs that takes a Block index as an argument, then calls the above
+         method in the chosen block and returns the output.
+
+Add a button in the UI that calls the Blockchain.cs method to read a given Block. Print this text to the large
+black text box. Tip: You can re-purpose the buttons you made earlier for this purpose. Also, you may
+want to make a method dedicated to changing the text of richTextBox1, as you may be changing it
+frequently.
+
+                                                                                                                             7
+                                                    6: The output of the Genesis Block – for now
+
+Note: You may notice that the hash is in hexadecimal meaning that each character in the hash can be one
+  of 16 characters: 0-9 and A-F. This is more relevant later when we focus on mining and proof-of-work.
+
+                                                                                                                            8
+Part 3 – Transactions and Digital Signatures
+
+Wallets & Private and Public Key Generation
+
+Blockchain technology can store almost any type of data within the blocks; although typically Blockchains
+store a ledger of transactions. Transactions on a Blockchain are a receipt of the movement of digital crypto-
+currency from one wallet to another. This digital currency is generated through the consensus algorithm,
+which we will be discussed in detail in later section. In this section we are interested in the generation of
+the wallets. In Blockchain a wallet has two components, a private key and a public key. A public key is
+public to all entities in a Blockchain, while a private key must be kept secret, as it gives the owner control
+of the wallet funds.
+
+Public and Private Key Pairs are mathematically related to each other, but a private key cannot be solved
+(deciphered, decoded) simply by exploiting this relationship with the public key. There exist many
+asymmetric encryption algorithms for the purpose of generating key pairs; in this assignment we will use
+the Elliptic Curve Digital Signature Algorithm (ECDSA). This is the same algorithm that Bitcoin and other
+Crypto-currencies use, therefore we can consider our key generation to be cryptographically strong.
+
+Within the folder Wallet, Wallet.cs can be found. This class includes the code for key pair generation and
+validation. Feel free to look at this code to familiarise yourself with its structure. This code is provided for
+your convenience to free up your time to focus on and grasp the essential framework. process.
+
+ The following methods are included:
+
+    • Wallet(out String privateKey) – Constructor for a Wallet object. The Wallet object has one variable,
+         public key. The private key is an output parameter. Example code of constructing a Wallet:
+
+                      String privKey;
+                      Wallet.Wallet myNewWallet = new Wallet.Wallet(out privKey);
+                      String publicKey = myNewWallet.publicID;
+                      Console.WriteLine(publicKey + "\n" + privKey);
+
+    • ValidatePrivateKey(privateKey, publicID) – Returns true if private and public key are mathematically
+         related. Returns false otherwise.
+
+    • CreateSignature(publicID, privateKey, data) – Digitally signs the given data using the private key
+         given. Returns the digital signature.
+
+    • ValidateSignature(publicID, data, digitalSig) - Confirms that a given signature has been signed by a
+         private key related to the given public key. Returns true/false.
+
+Most of these methods are static, meaning they can be called without creating an instance of the Wallet
+object. Next, we can make use of this code in our Blockchain application; so let us go ahead as follows:
+
+    • Add a new button to the UI that generates a new Wallet.
+    • Add two new text boxes to the UI to display the public and private keys after a wallet has been
+
+         generated.
+    • Add labels to the UI to distinguish which key is public and private, respectively.
+    • Add a button to validate the public and private keys present in the textboxes(Call the
+
+         ValidatePrivateKey method to do this)
+
+                     Note: The public key is 64 characters, and the private key 32 characters.
+
+                                                                                                                             9
+                                         7: An example of key pair generation with validation message.
+
+Setting up Transactions
+
+Now that we have created wallets, we want to be able to send funds between them. To achieve this, as
+mentioned previously we need to add transactions to the Blockchain. First, we need to develop a
+Transaction.cs class. Next, we can add the appropriate variables you would expect to see in a Blockchain
+transaction. You can consider an example of a transaction from Bitcoin. From this example the following
+variables can be adopted (implement them in Transaction.cs with appropriate types):
+
+    • Hash – the hash of the transaction and its contents
+    • Signature – the hash of the transaction signed with the private key of the sender
+    • SenderAddress – the public key of the sender
+    • RecipientAddress – the public key of the receiver
+    • Timestamp – the time at which the transaction was made/sent
+    • Amount – the amount of currency being sent to the receiver
+    • Fee – the fee added to the transaction (this will be implemented later)
+
+Now create a constructor for transaction, it should accept arguments for the above variables and also the
+sender’s private key, although you should exclude hash, signature and timestamp as the method will
+generate these. The constructor should assign the arguments to their respective properties, then the
+timestamp should be set to current time.
+
+The transaction should now have a sender, receiver, timestamp, amount, and fee. We can use this
+information to generate the hash. Take the code extract used in Part 2 to generate a SHA256 hash and
+adjust it to make a method to generate a transaction hash, then assign the hash with the result.
+
+Finally, you need to sign the hash with the sender’s private key (this was supplied in the argument of the
+constructor). You can generate a signature using the static method of Wallet.cs CreateSignature(), and
+provide the sender’s address, their private key, and the hash of the transaction as arguments.
+
+ Note: The private key should not be left in the memory of the transaction instance, so do not save it as a
+                                                            variable.
+
+Processing Transactions & Transaction Pools
+
+Now that we have made the infrastructure for a transaction, we want to be able to generate and process
+transactions. For this we can first generate a transaction and then display it to the UI. This will require a
+new UI element; in particular:
+
+                                                                                                                             10
+    • An ‘Amount to send’ label and textbox
+    • A ‘Fee’ label and textbox
+    • A ‘receiver address’ label and textbox
+    • A button to ‘send the transaction,’ once the above fields have been completed
+
+                     Note: You can re-use the private and public textboxes for this purpose.
+
+                                                               8: New UI for transactions
+
+When the ‘Create Transaction’ button is clicked the following should occur:
+    • Amount, Fee, Public Key, Private Key, and Receiver Key fields are passed through to a new instance
+         of Transaction
+    • The Transaction is generated
+    • The Transaction is printed to the UI large text box
+
+ Tip: It could be useful to make a method in Transaction.cs that returns the contents of a transaction as a
+                                                             string.
+
+              Note: Now is your chance to come up with the name of your own crypto-currency!
+
+                                                                                                                             11
+                                                          9: Sending some ‘AssignmentCoins’
+
+ Note: You may notice there are no checks in place currently to verify if the information being provided is
+    valid. For example, does the sender have the 10 AssignmentCoins to send? -safeguarding against
+                                                        double-spend!
+
+We will add these checks in a later section, once it is possible to check the balance of a wallet.
+We have successfully generated a transaction, but we are not yet able to process it so that the blockchain
+could show it recorded in the next update. In Bitcoin when a transaction is created it is then processed by
+being shared with the network and placed in a transaction pool which consists of transactions that are
+waiting to be added to the next block on the Blockchain.
+A transaction is not confirmed or considered valid until it has been added to the Blockchain. Even then it is
+not always immediately accepted, some services that accept crypto-currency as payment require X number
+of confirmations. A transaction has one confirmation when it is first added to the Blockchain; when the
+next block is added it has two confirmations. Each additional block adds another confirmation.
+Transactions are not accepted until they reach a threshold of confirmations to reduce the impact of forks
+and attacks on the Blockchain. This is covered in more detail in the lectures.
+Our Blockchain is offline, so we do not need to worry about sharing it to the network. However, we should
+still place it in a transaction pool with other transactions while it is waiting to be added to the Blockchain.
+Now we can create a place to store pending transactions by adding a list of transactions to Blockchain.cs
+class called ‘transactionpool’ or ‘pendingtransactions’.
+Now when we generate a transaction, we can add it to the transaction pool, so it is ready to be added to
+the Blockchain.
+
+                                                                                                                             12
+Part 4 – Consensus Algorithms (Proof-of-Work)
+
+Generating new Blocks
+
+Your application should now be able to generate transactions and generate a genesis block. One Block on
+its own is not a Blockchain, therefore we need to generate some more blocks. We can add a button to the
+UI with the purpose of generating a new Blocks. When you click this button, it should call the Block
+constructor and pass it the variables from the previous block. Once this new Block has been generated,
+you can add it to the Blockchain (the List<Blocks> variable in Blockchain.cs). Now you can update the UI
+with the contents of the Block.
+Tip: It may be useful to create a GetLastBlock method in Blockchain.cs to get the latest block on the chain.
+ This method can be as simple as return blocks[blocks.Count - 1]; Also ensure that the list of Blocks
+
+          in Blockchain.cs is public or at least there is a public method to add new blocks to the list.
+
+                   10: The second block – connected to the prior Genesis Block through reference to its previous hash
+
+If you have not already done so, you can now add a method or button to read all Blocks from the Blockchain
+and write them to the large text box.
+
+                                           11: Read All button displaying the 4 blocks within the chain
+
+Adding transactions into Blocks
+
+We will now make use of the transaction pool that we created earlier. Blocks should carry transactions
+within them. We can examine this by first adding a new data field to Block.cs – transactionList, which
+
+                                                                                                                             13
+should contain transactions. When a new Block is generated it should be accompanied with transactions
+from the transaction pool. You can write some code to add transactions from the transaction pool to newly
+generated Blocks (This should occur during the Block generation process – before the hash is generated).
+Please make sure that the constructor of the Block is changed to accept a list of transactions in the
+arguments. We will edit the hashing mechanism in the Block later to consider transactions (by adding the
+“Merkle root”).
+
+   Note: Blocks cannot take an infinite number of transactions from the transaction pool, you can add a
+          reasonable finite limit to the number of transactions that each block can take (such as 5).
+
+Note: Ensure that transactions picked from the transaction pool are removed once the new block is added
+                                to the chain. You may find the following line helpful:
+
+                 transactionPool = transactionPool.Except(chosenTransactions).ToList();
+
+Now you can edit the Read function of Block to print out the contents of transactions within the Block.
+
+          Tip: Making use of a foreach loop in the Read code can make this task easier. See below.
+
+foreach (Transaction t in transactions) {
+    output += "\n" + t.ReadTransaction();
+
+}
+
+     Tip: It may be useful to add a button to read all transactions in the pool, to ensure that the code is
+
+                                             working as
+
+intended.
+
+12: Newly mined Block with two transactions
+
+Proof-of-Work
+
+In an online Blockchain which is distributed across nodes in a peer-2-peer network, the nodes must reach
+a consensus on how the next Block should be added to the chain. In Bitcoin and other existing Crypto-
+currencies, Proof-of-Work is used. Proof-of-Work dictates that for a new Block to be added to the chain,
+this Block must have a hash that satisfies a given difficulty threshold. In Proof-of-Work nodes compete to
+
+                                                                                                                             14
+create a Block that satisfies this difficulty threshold in the shortest time Consider the example below where
+the difficulty threshold is set as 2.
+
+    • A Blockchain node has generated a new Blockchain, however they cannot add it to the chain until
+         the hash begins with a number of zeros corresponding to the difficulty threshold. (Difficulty = 2,
+         therefore number of zeros required = 2).
+
+    • The node generates a hash of -
+         57169c0619650ff122a8d74776e74a5e6b6e8e517aea48579b2be0af19440488 for the block using
+         the block attributes.
+
+    • This hash does not satisfy the difficulty threshold, a new hash must be generated based on this
+         hash (re-hash). ; However hashing algorithms such as SHA256 always generate the same hash
+         given the same input. To generate a non-identical hash the Block has an extra data property –
+         nonce (number only used once). This nonce value is incremented after each hash attempt until the
+         resulting hash satisfies the difficulty threshold.
+
+    • So, the Blockchain node increments the nonce and rehashes until the difficulty threshold is met.
+         Finally, the following hash is generated that satisfies the threshold:
+         008a78f40bb59bf4c9da8cfccf6a9c8e1202b01933d2363eabb277ad867ba738
+
+    • The winning node having achieved the difficulty in shortest time then goes on to shares the Block
+         with the other nodes on the network, these nodes accept the new Block and add it to their identical
+         copies of the Blockchain. In this way the blockchain as universal record of transactions is kept
+         updated.
+
+To implement Proof-of-Work within our example Blockchain we need to add a new data property to
+Block.cs – nonce (set it to 0 by default) and set a global difficulty threshold float that must be satisfied. We
+recommend selecting a difficulty threshold of either 4, or 5.
+With the above complete, to create the Proof-of-Work algorithm the following must be implemented:
+
+    • Include the nonce in the CreateHash() method such that it is included in the process of the
+         composition of the hash.
+
+    • Create a new method Mine() that executes the CreateHash() method within a while loop, which
+         continues until the given hash starts with a number of zeros correlating to the difficulty.
+
+    • Change the Block.cs constructor to call Mine() instead of CreateHash().
+    • Increment the nonce after each failed hashing attempt. Do not increment the nonce after the
+
+         process has already resulted in a hash that has satisfied the difficulty criteria.
+    • Change the Read() method in Block.cs to also return the last value of nonce and the difficulty level
+
+         the Block was mined at.
+Note: If you implemented this incorrectly your code could get stuck in a while loop. Making use of debug
+
+                    mode (and reducing the difficulty) may help you investigate this problem.
+
+                                                                                                                             15
+                                                      13: Three Blocks mined at a difficulty of 4
+
+Difficulty (Level)
+
+The difficulty level as set in Proof-of-Work is proportional to the number of zeros at the beginning of the
+hash that constitute a valid block. The more zeros required there, the longer it will take to mine. SHA256
+represents characters in hex format; meaning each character can be 1 of 16 different characters. Therefore,
+each extra zero required to mine in Proof-of-Work increases the difficulty by a factor of 16. For now, we
+are using a fixed difficulty of 4 or 5 zeros (up to you) at the beginning of the hash. Later however we will
+discuss the topic of a dynamic difficulty (which is why the data type of difficulty is float).
+
+For this section, the only action you need to take is to include the difficulty to the hash composition used
+in CreateHash().
+
+Rewards & Fees
+
+If we take a random Block from Bitcoin and look at the number of zeros required, we can see that 19 zeros
+were required. The chance of generating a hash that begins with 19 zeros is 1/1619. This requires a huge
+amount of work to be done to generate a Block. Nodes all over the world compete to be the next one to
+generate a Block FIRST. Specialist computation hardware and much electricity is required to even have a
+slim chance of being the next node to mine a Block. Right now, in our Blockchain there is no incentive for
+nodes to mine, other than to get their transaction on the chain. In Bitcoin and other Proof-of-Work crypto-
+currencies the incentive comes in the form of a reward and fees.
+
+After each Block is mined in Bitcoin, a flat reward is given to the winning miner’s address. This reward is
+given as a transaction; the receiver address is the mining node address and the sending node is technically
+from nowhere (as the currency is generated there and then). In Bitcoin the sender’s address is ‘Coinbase’,
+which is simply the terminology to refer to currency generated as a reward. In our implementation the
+sender’s address should be ‘Mine Rewards’ (because Wallet.cs is configured for reward currency to be sent
+from ‘Mine Rewards’. You can change this if you reconfigure Wallet.cs too). You can set the reward amount
+to any number you wish; you can even add conditions to the way rewards are PAID if you wish. For example
+
+                                                                                                                             16
+in Bitcoin, rewards are halved every 210,000 blocks; as a result only a finite amount in Bitcoins will ever
+exist.
+Fees are a small sum added to each transaction to incentivise the mining node to choose their transaction
+in the next Block. The higher the fee, the more likely the node will pick it. When the node successfully
+mines a Block, they receive a flat reward and the accumulative fees from all transactions in the Block. As
+we have already implemented fees in our transactions, we are ready to implement rewards and fees to
+mining nodes.
+To implemented fees and rewards we need to do the following:
+
+    • Add the logic for rewards; it can be fixed, variable, anything you decide.
+    • Update the UI code; such that the public address for the miner is sent through to the Block
+
+         constructor.
+    • Before we start mining the Block, we need to add all new transaction to the transaction list ( the
+
+         pool) used by Block .t. In the constructor of the Block add a new method (before Mine() is called)
+         this method will calculate the reward and total fees owed (from all the transactions in the Block)
+         and create a transaction for it.
+    • Create this new transaction using the following line of code:
+    • Transaction transaction = new Transaction("Mine Rewards", minerAddress, (reward +
+
+           fees), 0,"")
+
+    • Wallet.cs is configured to deal with ‘Mine Rewards’ so a private key does not need to be provided.
+    • Now add this new transaction to the transaction list in the Block.
+    • Add the reward to the hash composition used in CreateHash()
+    • Finally update the read method of Block.cs to print the reward, fees, and the miner’s address
+
+         {wallet).
+
+                           •
+
+                                      14: Block with rewards implemented. Miner gets a reward of 25.001
+
+At this point we have successfully created an offline Blockchain. We have a consensus algorithm, a
+Blockchain, and can create transactions and get them published on the chain. However, we have not added
+
+                                                                                                                             17
+any validation methods along the way. The next part covers validation and how we can prevent malicious
+actors from attacking the chain by utilising what we have already implemented.
+
+                                                                                                                             18
+Part 5 – Validation
+
+A Blockchain is normally hosted by many nodes in a peer-2-peer network. By definition being a trustless
+network, it is impossible to trust any node in the system, as they could be malicious. Therefore, instead of
+trusting the other nodes, you must trust the system. So far, we have developed a system that can generate
+digital keys, generate transactions with signatures, and generate and add Blocks to the Blockchain.
+However, we have no/minimal checks along the way to validate the Blockchain. The following section will
+highlight the areas that need validation and checks to ensure that the Blockchain is operating as intended,
+with no incorrect or malicious activity.
+
+Validating the Blockchain Structure
+
+As we already know, Blockchain is a linear structure of connected Blocks. The component that ‘connects’
+the Blocks is the reference to the hash of the previous Block. We should validate that the Blocks are
+properly connected, by checking that each Block correctly refer to the hash of the previous Block (Block
+Coherence, Contiguity)
+We can now include a new button within the UI that will perform full validation of the Blockchain. For
+now, you can make a method that iterates through the Blocks in the chain and checks the hashes of each
+block with its previous block to see if they match. This is to that each previous hash reference matches
+the hash of its previous block (the block that immediately preceded it; came just before it in the chain) If
+all Blocks pass (match their respective precursor block) , then this method must return a success message;
+otherwise return a failure message.
+
+Checking and Validating Balance
+
+So far, we have had no way to check the balance of a wallet, and we do not have checks before transactions
+are made to see if a wallet can afford to spend the funds needed to be sent to another wallet for given
+transaction. We can include another button in the UI that checks the balance of a given wallet and include
+further checks within the transaction generation logic to ensure that the sender has sufficient funds before
+a transaction can be permitted to proceed.
+
+                (Remember currency is generated through mining so all wallets start with zero)
+ Tip: You will need to create code that goes through all Blocks and searches for transactions involving the
+
+                                                  wallet you are checking.
+
+        15: Check balance showing the balance of an address along with the transactions in which the address was involved.
+
+Validating Blocks & Merkle Root
+
+So far, we have had have no verification method in the Blocks to check if the transactions within it have
+been tampered with Merkle root is a scalable and efficient method to encode data on the Blocks in an
+efficient manner. We can use the Merkle root algorithm to encode the transactions within a Block to a
+
+                                                                                                                             19
+single hash. You can now include a new data field within Block.cs, as merkleRoot. We can include a new
+method within Block.cs to calculate the Merkle root too.
+
+The Merkle root algorithm combines the hashes of multiple transactions iteratively, until only one resulting
+hash remains after the hash of the latest block has been included. Consider the following example for how
+Merkle root is implemented:
+
+    • A Block has five transactions within: 1, 2, 3, 4, and 5.
+    • The hash of 1 and 2 are combined to make 1,2
+    • The hash of 3 and 4 are combined to make 3,4
+    • The hash of 5 is left untouched for now to make 5
+    • Now the hashes 1,2 and 3,4 are combined to make 1,2,3,4
+    • Finally, the hashes 1,2,3,4 and 5 are combined to make 1,2,3,4,5
+    • 1,2,3,4,5 is the final hash, and therefore it is the Merkle root.
+
+Now implement the Merkle root method in code. To help with this task you can make use of HashTools.cs
+made available for you in the HashCode folder. Use the method
+
+combineHash(hash1,hash2) to combine the hashes of transactions.
+
+     Tip: It may be useful to make the Merkle root algorithm static, as it will be useful for verification.
+
+Once the Merkle root algorithm and assignment are completed, Include the Merkle root validation with
+the validation method you made earlier. (Please do not forget to include the Merkle root within the Read()
+method in Block.cs)
+
+We do not just perform comparison of the hash of the Blocks for the purpose of Proof-of-Work [i.e.to
+check if a miner has submitted a block that is i) carries the content of all previous blocks and ii) satisfies the
+difficulty level, iii) has included all the transactions] we also use it to ensure that none of the data in a Block
+has been tampered with. As hashing algorithms always create the same hash given the same input, we can
+rehash the contents of a Block and compare the result with which hash ? to check that the provided hash
+for the Block matches the combinatorial hash of all the previous blocks (their Merkle root. If the hashes do
+not match, then it is likely that some data in some Block(s) has been tampered with. If this happens the
+entire Block has to be rejected. So now we need to include this facility within our full Blockchain validation
+method, to check if the hash of a Block submitted by a miner does match the expected reference hash (who
+computed that, can they be trusted, who validates them? ) indeed hash provided is correct.
+
+Finally we can include the merkleRoot data property within the SHA256 hashing method that generates a
+Block hash. This means if any transactions have been tampered with, then the Merkle Root will be different
+from what? , and as a result the hash of the Block will be wrong.
+
+Validating Transactions
+
+Similarly to the last section, here we can include checks within the validation method to recalculate the
+hash of the transactions to arrive at the hash of a given block and compare it with a given hash of
+transaction within a submitted block. In addition to this we can also include logic to verify the signature
+provided in the transaction, to check to see that i the transaction has been signed off with the correct
+private key i.e. to authenticate the person making the transaction . For this purpose, Wallet.cs has a
+verification method that you can make use of: ValidateSignature(publicKey, hash, signature).
+
+                                                                                                                             20
+Testing the validation
+
+You can test the validation methods that you have implemented in various ways. For example you can try
+some of the following steps
+
+    • Sending a transaction with address that does not have enough funds to support it
+    • Sending a transaction and providing an invalid private key
+    • Creating a button/method that generates invalid Blocks with incorrect features – e.g., wrong
+
+         previous hash, wrong hash, invalid transactions within the block.
+                       *******************************************************
+
+                                                                                                                             21
+Clarification re Assessment and Implementation
+
+The only code to be added by students to the fully commented working program already provided is the
+additional code to be integrated within the Mine() routine in the program.
+
+As the marking scheme below shows, by completing and documenting tasks 1-5, which is simply to run
+the program provided and presenting a report on it on the same basis as the Coursework Support Notes,
+a student can obtain (65%), and by completing each of the last three tasks correctly (requiring a few lines of
+code to be added) a student can obtain a further 35/3= 11.66 marks added to the 65% for Parts-1-5 if fully
+completed.
+
+Part                                            Evidence of implementation Repor Tota
+
+1 – Project Setup                                                     t  l
+2 – Blocks and the Blockchain
+3 – Transactions and Digital Signatures                           3   2  5
+4 – Consensus Algorithms (Proof of Work)
+5 - Validation                                                    5   5  10
+6 – Assignment Tasks 1, 2, 3
+Equally divided marks                                             5   5  10
+
+                                                                  10  10 20
+
+                                                                  10  10 20
+
+                                                                  15  20 35
+
+                                                                  48  52 (100
+
+                                                                         )
+
+Coursework Facts
+
+Tasks 1-5 which cover the stages of building the mini-blockchain         65%
+
+Please see the sample assessment and feedback as provided to a student who took this course in the
+previous year. As you can see it is essential to show a comprehensive understanding of the code. Students
+are to submit a description of each of the steps including screenshots from their own running instance of
+the blockchain application to demonstrate their understanding.
+
+Thus, students will get full marks allocated to these steps (Yellow highlighted Parts in the marking scheme
+= 65%) simply by showing their own screenshots arising from the execution of the code provided and
+outlining the steps, for example as illustrated by a flow chart.
+
+All the code, including the constructors for each necessary object such as block, wallet and transaction, are
+integrated within the working code including the GUI using Windows Forms as provided in the practical
+folder to build a mini-blockchain. The document called Practical Exercises and Coursework Support and
+the Blockchain Cookbook PowerPoint that is based on it can be is used for step-by-step creation of the
+mini-blockchain during laboratory sessions. The following are the normally expected screenshots to be
+
+                                                                                                                             22
+included in the report or in the Appendix to ensure compliance with the 7 pages limit of the main body of
+the report.
+1. Screenshots of Gensis Block
+2. Screenshot of wallets showing key pairs
+3. Screenshot of a transaction with fee showing
+4. Screenshot of transaction with balance showing
+5. Screen shot of transaction Pool listing.
+6. Screenshot of Blocks with sufficient number of leading zeros satisfying a Degree of Difficulty of 4
+7. Screenshots for the results of each of Tasks 6.1, 6.2 and 6.3 as attempted as appropriate
+
+                                                                                                                             23
+    Part 6 (Tasks 1, 2, 3) the green highlighted tasks in the above Marking Scheme           35%
+
+    Some tutorial advice regarding the only additional coding necessary for implementing Part B tasks has
+
+    been provided in lab/lecture sessions.
+
+    For Tasks 1, 2, 3 of Part 6, students can add some code of their own to the Mine () routine within the
+    working code to experiment with alternative scenarios for Proof-of-Work which is the process of mining
+    valid blocks as already implemented within the code.
+
+    The points at which this additional code could be introduced are dependent on the Tasks selected for
+    Part 6 which are any three from those listed below:
+
+    1. Threading during Proof-of-Work
+    2. Adjusting the Difficulty Level in Proof-of-Work
+    3. Mining Settings
+    4. Your own idea
+
+             These are described below:
+
+i)  Task 1: Multi-threading to carry out, in parallel, the block preparation (Proof-of-Work) process for
+
+    different degrees of difficulty. Finding out as you increase the Degree-of-Difficulty, how high one needs
+
+    to increase it, before multi-threading would give significant speed advantage in arriving at a valid block
+
+    with the right number of leading zeros, noting that multi-threading requires a computational overhead
+
+    in thread management, and such parallelised computation will lead to an efficiency gain only when the
+
+    gain from the parallelism is over- compensated by the time taken for thread management.
+
+ii) Task 2: Develop an algorithm which periodically adjusts (re-sets) the “Degree-of-Difficulty” to match the
+         Block-Update-Rate set for the next cycle – the time interval between successive block updates that has
+         to allow enough time for the miners to arrive at a block hash with as many leading zeros as the number
+         stated as the “Degree-of-Difficulty”.
+
+iii) Task 3: Develop an algorithm to be used by the miner to select the right transactions to be included in the
+         next block as typically there could be more transactions in the pool than a miner could/would include in
+         each next block to be submitted.
+
+    Part 6 - (Tasks 1, 2, 3) Preparatory steps
+
+    For task 6, students should first simply create a few more transactions by sending coins from one wallet
+    to another, essentially establishing the mini-blockchain as a ledger – creating a number of accounts
+    (wallets) and say 10-20 transactions within an hour time-period with varying amounts and fees so that
+    the transactions will have sufficiently spread-out timestamps. Students would then be ready to attempt
+    the additional Tasks for the last 35 marks; here are some more hints for tackling tasks 6.1, 6.2, 6.3.
+
+                                                                                                  24
+25
+Part 6 - Task 1                                  35/3≈11.67 Marks
+
+Multi-threading tutorials are available for C# which is the language of the already completed program
+for the mini-blockchain build but for students who wish to translate the existing program to another
+language such as Python or Java, multi-threading tutorials have also been included for these languages
+with lots of code examples by way of additional support. Despite this, the additional code to be written
+for the additional Tasks is relatively minor, so it would probably be advisable to attempt to continue with
+C# even if one is more comfortable with some other language. Programming tutorial resources covering
+multi-threading are available on the module site are as follows:
+
+C# Threads Tutorial
+java Threads Tutorial
+
+ Everything Python Head-on – Coursework Support
+
+Each thread needs to have its own nonce to do its mining in parallel trying to get to arrive at a string
+with the right number of zeros preceding the hash of the block, but each threat needs to use its own
+nonce to avoid duplication of results. There is such a thing as an “enonce” (extra nonce), and each
+thread could have its extra nonce assigned i.e. own distinct one-time-token (number) to keep
+incrementing to use in each cycle of mining - enonce( type long).
+
+    In this way as a distinct number shall be used for each enonce of each threat in each cycle of hash
+    composition, no duplicated effort could occur.
+
+    This task involves the following considerations:
+
+1. Using the full computational power available for multi-threading e.g. C# Threads.
+2. Advanced parallel processing could be deployed e.g. GPU implementation (CUDA).
+3. Must use e-nonce to prevent duplication of work.
+4. Threads synchronization and control.
+5. Performing a comparison study comparing mining times of single versus multi-threaded solution.
+6. Varying the Degree-of-Difficulty (n) to examine the point at which parallel processing does make
+
+    necessary to arrive at the required results (<n leading zero><hash>) faster.
+
+    Thus, to increase the chance of arriving at the above result fastest, for this task one can run several
+    threads each doing the block validation/mining (Proof-of-Work) process in parallel. Thefirst thread would
+    use standard Nonce and subsequent threads will each use their own distinct extra-Nonces (e-Nonce).
+    This is because Nonce can only be used with one of the threads, so to avoid duplication of computation
+    with each new thread another e-Nonce should be used.
+
+    Thread synchronization and control has to be implemented to ensure that as soon as the first successful
+    Mine() thread resulting in the block hash with the right number of leading zeros is arrived at as the final
+    result, all threading computation is stopped and all threads are timed to enable benchmarking the
+    efficiency of single versus multi-threaded Mine() which is the objective of this task.
+
+    Therefore, one would need to measure how long it takes with single or more threads and how many
+    threads are needed to satisfy a workable level of Degree-of-Difficulty for a reasonable Block Update Time
+    (time-to -compute-valid-block).
+
+    This just means using the existing code and adding some extensions to Mine() to multi-thread it and work
+    out the time each thread takes to do its Mine(). This would mean setting up new variables for thread
+    management and for recording the time taken by each thread until the process ends which is the time
+    at which one of the threads has arrived at the block hash with required number of leading zeros. The
+
+                                                                                                                                  26
+measure and record the individual thread latencies, one could make use of
+system.Diagnostics.Stopwatch).
+
+One should be able to take multiple samples of mining times and compare them for different number
+of threads and for a few increasing “Degree-of-Difficulty” numbers (e.g. 4, 5, 6 etc.) and seeing for what
+Degree-of-Difficulty and what number of threads a most efficient [(shortest Mine() time] is achievable.
+
+By increasing the Degree-of-Difficulty one can examine the point at which the overheads of threading
+are exceeded by the efficiency gain arising from the parallelism provided by the threading. Say starting
+from 4 as the “Degree-of-Difficulty” and adapting the existing Mine() to a multi-threaded Mine() in the
+C# program provided and manually re-setting it for each run with a different number of threads (while
+increasing or decreasing the number of threads and timing the process to establish at what Degree-of-
+Difficulty, using how many threads, the multi-threaded Mine() will execute faster to deliver the valid
+block with requisite number of leading zeros, i.e. the optimal set-up at which the parallel execution of
+Mine() through multi-threading gets the job done fastest.
+
+Part 6 - Task 2                          35/3≈11.67 marks
+
+Re-setting the Dynamic” or “Adaptive” Degree-of -Difficulty for Adaptively varying the required
+Proof-of-Work (APoW)
+
+Clearly there is a trade-off between changing the Degree-of-Difficulty and time-to-submit of valid blocks
+which is the time it takes to complete the computation required to arrive at a submittable block with
+the requisite number of leading zeros that thus satisfying the "Degree- of-Difficulty".
+
+In our current implementation, increasing the Degree-of-Difficulty by one would increase the amount of
+work by a factor of 16. This is not suitable for fine tuning a dynamically re-settable Degree-of-Difficulty.
+You are going to need to think of another approach, consider researching existing approaches.
+
+In your report, please detail how you implemented your Dynamic Degree-of-Difficulty and why you
+chose that approach while also providing evidence that it works. Also mention the length of your ‘Block
+Time’ and justify why.
+
+Note: Any ‘Block Time’ implementation is OK as long as you feel it has been fairly justified (and it is
+workable for the miners given a high-speed computational platform).
+
+This task involves the following steps:
+
+1. Decide your own ‘block time’ and implement an appropriate algorithm
+2. Establish a target block time
+3. Continuously call Mine()
+4. Calculate the “Mine Rate” based on previous block timestamps
+5. Adjust the difficulty based on the difference between target and actual/observed
+
+    block time
+
+                                                                                                                                  27
+The block update time (latency) usually does not change frequently for a specific Blockchain (e.g. In
+Ethereum the block update time 10-20 seconds, for Bitcoin it is presently 10 minutes, and the Degree-
+of-Difficulty maintained with this is 19, see below).
+
+                                                                                                                             28
+                         =    () –    ( − 1)
+
+    For re-setting the “Degree-of-Difficulty” to vary the computational load of Dynamic Proof-of- Work for
+    miners from time to time, one can assess the trend in the median value of Block Update Time and have
+    an algorithm that dynamically increases the Degree-of-Difficulty responsive to the trend in the median
+    value of the Block Update Time.
+
+    In this way, Blockchains could use the block update times of the last N blocks to re-adjust the Degree-
+    of-Difficulty responsive to the trend in the value of the Block Update Time.
+
+    One can use an exponential function to have the Degree-of-Difficulty be re-set responsive to changes in
+    the Block Update Time (median time it has taken for the miners to submit the last N blocks) or use
+    alternative approaches for such Adaptive Degree-of-Difficulty responsive to the latency of the required
+    Proof-of-Work and decide what Degree-of-Difficulty would be optimal.
+
+    However, the starting point could be to establish a target block time and apply an exponential decay
+    function to converge to a “Degree-of-Difficulty” number incrementally best adjusted for the target block
+    update latency desired.
+
+1. start with a moderate level of difficulty say 4 or 5
+2. Benchmark this i.e. measure how long it takes with or without threads and how many
+
+    threads it takes to satisfy a workable level of difficulty and block time
+3. This just means repeating the PoW using Mine() for different levels of difficulty with or
+
+    without threads
+4. Block time = timestamp for block (n) – timestamp for block (n-1)
+5. Apply an exponential growth function. In the exponential growth of f(x), the function doubles every
+
+    time you add one to its input x. In the exponential decay of g(x), the function shrinks in half every time
+    you add one to its input x … e.g.
+6. Establish a target block time
+7. Calibrate “Block-To-Block Stair-Stepping”
+8. >Median block time of a batch of N recently-mined blocks
+9. Exponential Decay Difficulty Adjustments
+
+1. /e
+
+10. Adjust the difficulty according to the formula 
+11. After a significant spike in hash-rate and difficulty followed by a huge drop in hash-rate and difficulty,
+
+    working each new block gets easier until the difficulty stabilizes according to the true size of the network.
+
+                                                                                                                                  29
+Part 6 - Task 3                                                    35/3 ≈ 11.67 marks
+Variable Methods for Selection of Pending Transactions for Mining
+
+    A Miner may consider picking the transaction with lowest fees which tend to be also amongst the
+    ones that may have been waiting to be mined the longest (Altruistic Approach) or picking the largest
+    transactions with the largest fees first as most Miners tend to go for as the most profitable approach
+    (Greedy Approach). You will be able to add buttons for each of the above approaches to select the
+    transactions according to the Miner’s Approach - you need to reflect on the side-effects, on the
+    Blockchain as a whole, arising from each of the transaction selection approaches.
+
+    Using some additional coding to modify the way Mine() works, you can enable the selection of
+    transactions from the transactions pool to take place based on any one of up to three approaches
+    selected from the table below:
+
+• Greedy: You can choose transactions with the higher fees with a cut-off of say six transactions to be
+    chosen.
+
+• Altruistic: You can check the timestamp of transactions and choose the oldest ones with cut-off set
+    on the oldest transaction to be selected. The algorithm could have a limit of no more than n
+    transactions to be selected and would select them by prioritising transactions that are no older than
+    say n-Minutes/Hours/Days and then add as many younger transactions as possible in the order of
+    oldest to complete the number of n transactions to be selected.
+
+• Unpredictatble (Random): You can run a Rand() function with a small range and choose the
+    transaction which represents the closest match with say the transaction number or the hash of some
+    parameter of the transaction - with a cut-off decided on the number n of transactions required to
+    be selected.
+
+• Address-based: You can choose transactions based on the value of some other attribute of the
+    transaction e.g., the highest wallet_ID addresses with a cut-off after the top six chosen.
+    Start by using the Windows Form to create buttons for each of the above four types of Mining. Declare
+    custom functions to select transactions from the transaction pool, according to each of the above
+    criteria, thereafter, proceeding to run Mine() with this method to select the transactions to be
+    selected for the new block generated – ready to be submitted.
+
+Your own idea - Some Suggestions:
+
+    1. Implementation of a different consensus algorithm (e.g. Proof-of-Stake)
+    2. Creating multiple nodes running in a local network, automating the generation of
+
+         transactions
+    3. Secure Smart Contracting for a specific application domain use-case
+
+                                                                                         0
+   Basic Technical Reporting Hygiene
+
+As you can see 52% of the marks are allocated to the reporting so it is important that the
+accompanying report submitted is complete, coherent, and well-presented as it is with the
+presentation that one can needlessly lose marks one could easily earn. Research and reference to
+other Blockchain implementations highly recommended for these sections.
+
+            **************************************************
+
+Appendix: Blockchain Optimisation
+Further support for Task 6.2: Dynamic Degree-of-Difficulty Optimisation
+
+Block Time
+
+Block time refers to the average time it takes to generate a new block in a blockchain network. This
+is the time between the addition of one block and the next. Different blockchain networks have
+varying block times. For example:
+
+• Bitcoin: Approximately 10 minutes.
+
+• Ethereum: Around 12-14 seconds.
+
+Importance of Block Time
+
+• Transaction Speed: Block time directly impacts how quickly transactions are confirmed. Shorter
+    block times mean faster transaction processing, which is essential for user experience and the
+    practical use of the blockchain.
+
+• Network Security: Block time affects the security of the network. A shorter block time can lead to
+    more frequent blocks, which may increase the probability of forks (split chains). Managing block
+    time helps in balancing security and efficiency.
+
+• Scalability: Block time influences the blockchain’s ability to handle a large number of transactions.
+    Shorter block times can help increase throughput, but they also require more computational power
+    and efficient network propagation.
+
+• Energy Consumption: The frequency of block creation affects the amount of computational work
+    required. Shorter block times might lead to higher energy consumption, making it important to find
+    a balance for sustainability.
+
+• Economic Incentives: Miners are rewarded for solving complex cryptographic problems to create
+
+new blocks. The block time influences how often these rewards are distributed, impacting the
+
+economic dynamics of mining activities.                                                                  1
+• Finding the Balance
+    Finding the optimal block time is about balancing transaction speed, network security, scalability,
+    energy efficiency, and economic incentives. Too short a block time might lead to network instability
+    and higher energy consumption, while too long a block time could result in slow transaction
+    processing and user dissatisfaction.
+
+    Optimising the Bock Time and Degree-of-Difficulty in the PoW as a Consensus Protocol for
+    Blockchain
+
+    These items collectively contribute to optimizing the block time and PoW throughput/latency
+    capacity in blockchain networks.
+
+• Mining Difficulty Adjustment: Dynamically adjusting the mining difficulty to maintain a consistent
+    block generation time. This ensures the blockchain doesn't grow too rapidly or too slowly.
+
+• Exponential Moving Average (EMA) & Simple Moving Average (SMA): Both EMA and SMA are used
+    to smooth out data and provide trends. These averages help in making informed adjustments to
+    mining difficulty, directly influencing block time and PoW efficiency. EMA responds faster to recent
+    changes, while SMA offers a balanced view over time. Utilizing EMA to give more weight to recent
+    data, making the difficulty adjustment mechanism more responsive to abrupt changes in network
+    activity.
+
+• Simple Moving Average (SMA): Employing SMA for reporting purposes, providing a balanced view of
+    network activity over a longer period.
+
+• Simple Moving Average (SMA): Employing SMA for reporting purposes, providing a balanced view of
+    network activity over a longer period.
+
+• Reinforcement Learning (RL): Leveraging RL techniques to dynamically adapt the difficulty of PoW
+    based on the computing power of miners. This helps in achieving fairness and efficiency in
+    blockchain mining.
+
+• Optimal Block Size: Analysing and determining the optimal block size to minimize latency and
+    maximize throughput. This involves considering factors like transaction confirmation time and
+    network congestion.
+
+• Latency: The time taken for a transaction to be confirmed. Lower latency improves user experience.
+
+• Latency Reduction: Implementing strategies to reduce end-to-end latency in PoW-based blockchain
+    networks. This includes optimizing block generation rates and minimizing fork probabilities.
+    Reducing latency improves the overall network efficiency and transaction speed, which is vital for 2
+    maintaining a stable throughput. Lower latency can also reduce the likelihood of forks, which can
+    further stabilize the network.
+
+• Throughput Optimization: Enhancing the number of transactions processed per second by
+    optimizing the block size and block interval. Optimizing throughput ensures the network can handle
+    a high volume of transactions, but it must be balanced with block size and mining difficulty to avoid
+    excessive latency.
+
+• Scalability Improvements: Ensuring that the blockchain network can handle an increasing number of
+    users and transactions without performance degradation.
+
+• Energy Efficiency: Developing more efficient consensus mechanisms to reduce energy consumption
+    and operational costs. More efficient consensus mechanisms reduce energy consumption, which is
+    crucial for sustainability. Energy efficiency can also influence mining
+
+• difficulty, as less energy-intensive methods may require different difficulty adjustment strategies.
+
+    These items are interrelated, and they often influence each other in dynamic ways:
+
+• Mining Difficulty Adjustment: Adjusting mining difficulty directly impacts throughput and latency. If
+    difficulty increases, it can reduce throughput and increase latency because blocks take longer to
+    mine. Conversely, lowering difficulty can increase throughput but may compromise security.
+    Dynamically adjusting the mining difficulty to maintain a consistent block generation time. This
+    ensures the blockchain doesn't grow too rapidly or too slowly.
+
+• Exponential Moving Average (EMA) & Simple Moving Average (SMA): Both EMA and SMA are used
+    to smooth out data and provide trends. These averages help in making informed adjustments to
+    mining difficulty, directly influencing block time and PoW efficiency. EMA responds faster to recent
+    changes, while SMA offers a balanced view over time.
+
+• Reinforcement Learning (RL): Leveraging RL techniques to dynamically adapt the difficulty of PoW
+    based on the computing power of miners. This helps in achieving fairness and efficiency in
+    blockchain mining. RL can optimize the difficulty adjustment process by learning from past data and
+    predicting future trends. This helps maintain an optimal balance between block time and
+    throughput.
+
+• Optimal Block Size: Analysing and determining the optimal block size to minimize latency and
+    maximize throughput. This involves considering factors like transaction confirmation time and
+    network congestion. The block size affects both throughput and latency. Larger blocks can process
+    more transactions but may increase the time to propagate across the network, leading to higher
+    latency. Finding the optimal block size is crucial for maintaining balance.
+
+• Latency Reduction: Reducing latency improves the overall network efficiency and transaction speed,
+    which is vital for maintaining a stable throughput. Lower latency can also reduce the likelihood of
+    forks, which can further stabilize the network.
+
+• Throughput Optimization: Optimizing throughput ensures the network can handle a high volume of
+    transactions, but it must be balanced with block size and mining difficulty to avoid excessive latency.
+                                                                                                                               3
+• Scalability Metrics: The network's ability to handle increased demand. Metrics like TPS and latency
+    under load are important indicators.
+
+• Scalability Improvements: Ensuring that the blockchain network can handle an increasing number of
+    users and transactions without performance degradation. Scalability ensures the network can grow
+    without performance degradation. This includes optimizing mining difficulty, block size, and reducing
+    latency to handle more users and transactions efficiently. The network's ability to handle increased
+    demand. Metrics like TPS and latency under load are important indicators.
+
+• Energy Efficiency: More efficient consensus mechanisms reduce energy consumption, which is
+    crucial for sustainability. Energy efficiency can also influence mining difficulty, as less energy-
+    intensive methods may require different difficulty adjustment strategies.
+
+By understanding these interconnections, developers can create a more efficient and balanced
+blockchain system that optimizes for block time, throughput
+
+For optimal blockchain performance, it is important to monitor a range of metrics that cover
+different aspects of the network. Here are some key metrics to keep an eye on:
+
+Blockchain Metrics
+
+1. Block Time: The average time taken to mine a new block. Consistent block time indicates network
+    stability.
+
+2. Hash Rate: The total computational power of the network. Higher hash rates generally improve
+    network security.
+
+3. Difficulty: The mining difficulty level, which adjusts to maintain consistent block times.
+
+4. Block Size: The average size of blocks. Optimal block sizes help balance throughput and latency.
+
+5. Transaction Throughput (TPS): The number of transactions processed per second. Higher TPS
+    indicates better network performance.
+
+Network Metrics
+
+6. Latency: The time taken for a transaction to be confirmed. Lower latency improves user experience.
+
+7. Fork Rate: The frequency of blockchain forks. Lower fork rates suggest a more stable network.
+
+8. Propagation Time: The time taken for a new block to reach all nodes in the network. Faster
+    propagation reduces the risk of forks or orphaned blocks, thereby ensuring better network
+    synchronization and security.
+
+Economic Metrics
+
+9. Transaction Fees: The average fees paid for transactions. Lower fees can encourage more users to
+    transact.
+
+10. Miner Revenue: The total income of miners from block rewards and transaction fees. Higher
+    revenue can incentivize more mining activity.
+
+Security Metrics                                                                                       4
+11. Attack Cost: The cost to launch an attack on the network (e.g., 51% attack). Higher attack costs
+    indicate better security.
+
+12. Double-Spend Rate: The frequency of double-spend incidents. Lower rates suggest higher network
+    integrity.
+
+    User Metrics
+
+13. Active Nodes: The number of active nodes participating in the network. More nodes enhance
+    decentralization and resilience.
+
+14. Wallet Activity: The number of active wallets and transactions. High activity indicates robust user
+    engagement.
+
+Exponential Decay Function usage in implementation of adaptive dynamic optimisation of "Degree
+of Difficulty" and "Block Time" in Blockchain
+
+Exponential Decay Function
+
+Imagine you have a big, colourful balloon. Every minute, you let out a certain percentage of air from
+the balloon. At first, a lot of air escapes because the balloon is full. But as time goes on, less and less
+air comes out, because there's not much left in the balloon.
+
+So, exponential decay means that something decreases at a rate proportional to its current value.
+The more you have, the faster it decreases. Over time, the amount gets smaller and smaller, but it
+never quite reaches zero.
+
+In the context of blockchain, this concept can be used to make certain things, like rewards or
+difficulty levels, decrease smoothly over time.
+
+Examples of how exponential decay functions can be applied in blockchain technology to optimize
+various parameters and ensure the network's stability and efficiency.
+
+• Exponential Decay of Sensitivity in Dynamic Optimization: This paper explores the exponential
+    decay of sensitivity in dynamic optimization problems, including model predictive control and
+    moving horizon estimation. It provides insights into how perturbations propagate along the horizon
+    and enable the development of approximation and solution schemes.
+
+• Controllability and Observability Imply Exponential Decay of Sensitivity in Dynamic Optimization:
+
+This study delves into the property of exponential decay of sensitivity in dynamic optimization
+
+problems. It discusses how uniform controllability and observability imply exponential decay of
+
+sensitivity, providing insights into the development of approximation and solution schemes.              5
+• Gradient-Based Optimization Method Using Exponential Decay: This article proposes a new
+    gradient optimization method using exponential decay and adaptive learning rates. It discusses the
+    application of this method in various optimization problems, including neural network training.
+
+• Difficulty Adjustment: In blockchain networks like Bitcoin, the difficulty of mining new blocks is
+    adjusted periodically to ensure that blocks are mined at a consistent rate. An exponential decay
+    function can be used to smooth out these adjustments, preventing sudden spikes or drops in
+    difficulty. This helps maintain a stable and predictable block generation time.
+
+• Block Reward Halving: Many blockchain networks implement a block reward halving mechanism,
+    where the reward for mining a new block is reduced by half at regular intervals. This can be
+    modelled using an exponential decay function, where the reward decreases exponentially over time.
+    This helps control the supply of new coins and can influence the long-term value of the
+    cryptocurrency.
+
+• Fee Adjustment: Transaction fees in blockchain networks can also be adjusted using exponential
+    decay functions. For example, the minimum fee required to include a transaction in a block can be
+    dynamically adjusted based on network congestion and demand. This ensures that the fee rate
+    remains competitive and fair for users.
+
+• Token Economics: In some blockchain-based token economies, the distribution of tokens or rewards
+    can follow an exponential decay pattern. This can help incentivize early adopters and gradually
+    reduce the rate of new token issuance over time, promoting scarcity and potentially increasing the
+    token's value
+
+    References
+          1. Adaptive Difficulty Adjustment in Blockchain: Harnessing the Power of Exponential Moving
+              Average (EMA) - GRIDNET OS - Main - GRIDNET Community
+          2. https://vtechworks.lib.vt.edu/server/api/core/bitstreams/596fda75-96a6-4796-94e3-
+              d6c9cae8d92a/content
+          3. (PDF) End-to-End Latency Analysis and Optimal Block Size of Proof-of-Work Blockchain
+              Applications
+          4. https://arxiv.org/pdf/2202.01497
+          5. performance-optimization-strategies-for-blockchain-networks.pdf
+          6. [2101.06350v4] Exponential Decay of Sensitivity in Dynamic Optimization: A Graph-Theoretic
+              Approach
+          7. https://arxiv.org/pdf/2101.06350.pdf
+          8. https://www.mdpi.com/2227-7080/12/9/154
+
+                                                                                                                               6
+                                           ********************************
+CS3BC Blockchain & Security Module
+Mini Blockchain Build
+FrequentlyAskedQuestions&Answers
+
+                                                                                                                         7
+Question 1
+
+Having completed the code for wallet creation, and the user interface buttons for the wallet private
+and public key, these do not appear on the designated text boxes for private and public key that I have
+created on the UI, what could be the problem?
+
+Answer to Q1
+
+I would check that the wallet constructor code has correctly output the private key and the UI
+textboxes for private and public key are correctly designated for displaying the respective keys and
+the validate button is correctly assigned to display them. Now if all code for the above is complete
+and you click on the Validate button, then the keys should be displayed in the designated textboxes,
+if this still does not occur, please use the debugging tools to step through the code as there must be
+something missing in the code- ensure that your code is identical to the fully commented code
+provided.
+
+Question 2
+
+When attempting to create and display a transaction, the sender's private and public keys are there
+ok but to send funds you have to provide the Recipient’s Key where do I find the Recipient Key? where
+is this generated in the code?
+
+Answer to Question 2
+A typical blockchain would have a large number of participants/nodes/wallets and for even a mini
+blockchain as in this case we should use the Wallet Constructor to create many wallets so that we
+could create many transactions so that we could have a transaction pool to select transaction from to
+include in a block. Every time the wallet class is used a new unique wallet is generated. Therefore if
+you are already trying to create transactions you must have some wallets that have been generated,
+if not, then you could generate some and then you would be able to display their keys and copy an
+paste their keys on the notepad and select from those a wallet as your Recipient and copy and paste
+its key to send funds to when attempting to complete a transaction.
+
+Question 3
+For the blockchain coursework do we need to include the difficulty in the creation of the hash?
+Because in the cookbook it asks to include it in the creation. However, in the highlighted code provided
+and the video in session 4 it is not included. So wasn't sure if we should add it or not. See below
+
+                                                                                                                          8
+Answer to Question 3
+
+Semantic confusion:
+by stating: ,...”include the degree-of-difficulty variable in the hash" it is meant not that one must hash
+the actual value of the degree-of-difficulty number together with block hash.
+
+This would not make any sense because the degree-of-difficulty is essentially to serve as a counter to
+check after each hashing cycle of the program whether the target number of the leading zeros have
+indeed been achieved in the resulting hash after each cycle and if not to continue with the next
+hashing cycle and so on until the target number of leading zeros are achieved.
+
+As has been stated previously, it is good programming practice not to hard-code the value of a variable
+into any program but to include it in the program as a variable whose value could be changeable as a
+dynamic value.
+
+The variable "degree-of-difficulty” happens to be set at the value of 4 for Parts 1-5 of the coursework
+but for task 6.1 and 6.2 you would need to run instances of the hashing program with varying degrees-
+of-difficulty when running multi-threaded Mine() and/or when attempting to run experiments for
+optimisation of the degree of difficulty and block update latency.
+
+Therefore, including the hash as a variable in the program makes sense as you can then run a program
+that passes a different value, as may be needed for the degree-of-difficulty, to the hashing program
+each time thereby ensuring it continues to go through the hashing loop until the number of leading
+zeros in the resulting hash of a final cycle has reached the particular degree-of-difficulty selected for
+that run.
+
+I hope it is now clear that "include the degree-of-difficulty variable in the hash…" means include it as
+a variable not hard-code it and certainly not hash it together with the block hash.
+Question 4
+
+Hi for the blockchain module which, can I create my own implementation of a PoW chain in python as
+that is my most proficient language?
+
+I was thinking to make a mini-bitcoin chain including
+Proof of Work
+2 nodes are enough for p2p (using 2 threads)
+1 minute block time adjusting after x blocks
+roll only the nonce for mining
+4 wallets, add a transaction every 1 minute automatically and random (2 miners and 2 users)
+
+Have a mempool (uncornfirmed transactions in queue)                                          9
+Accepted blocks are broadcasted to all nodes (validation)
+Would this be enough ?
+
+Answer to Question 4
+
+Looks like you are re-negotiating the coursework. Language of implementation is optional
+but we cannot change the requirements of the coursework to be addressed by the Implementation
+and the Report - to be fair to all the students.
+
+I would agree that a python implementation would be OK as long as all of the same blockchain features
+are replicated. For example wallets with Public/Private keys, transactions with rewards and fees for
+mining (Proof of Work) and Merkle Root algorithm implementation. This should be sufficient to show
+their understanding of the concepts of Blockchain.
+
+However, despite a student being more proficient in python this might be more work than if they used
+thre C# code given that C# should be very easy to pick up.
+
+Question 5
+
+I’m writing as I’m a little confused about the current assignment, particularly steps 1-5.
+My problem is that I’ve interpreted the brief as requiring independently programming steps 1-5 but
+I’ve noticed that there is complete sample code available on Blackboard.
+
+What are the requirements of this assignment - are we meant to use this code for part 6 and not
+program steps 1-5?
+
+The brief suggests that part 6 requires implementation of our own code written for steps 1-5.
+
+Answer to Question 5
+
+The sample code has been provided as a guide to help direct those less experienced with programming
+- whether that be in general or specifically in C# - so that these individuals are not disadvantaged in
+anyway.
+
+The assignment aims to give students the opportunity to display their knowledge of the fundamental
+components of a Blockchain and we do not put too much emphasis on the specifics of the
+implementation when marking - as long as the application is functional and logically correct. Instead,
+we focus on the understanding displayed by design justifications made in the code comments and
+accompanying report and evidenced by completed build evidenced by screens shots as indicated in
+the guide notes.
+
+A good understanding can be developed by either following the script and producing your own code
+(step-by-step) or by studying the sample code, running the application. Students would not be
+penalised for building upon the sample code for the assignment as long as a good understanding of
+the principles of a Blockchain is evident by the description of steps and screen shots.
+
+Question 6
+
+                                                                                                                          10
+Firstly, regarding the code you provided, assuming proper documentation we can just provide your
+code for these parts as the "Evidence of Implementation".
+
+Would you be able to clarify whether we must submit our own code for parts 1 - 5 for the coursework
+and then can proceed to use the code you provided for part 6 (additional tasks) or would we be able to
+use your code for all parts, provided sufficient documentation?
+
+Secondly, regarding the report, a page limit of 7 pages is mentioned, could you clarify that this is
+excluding images, screenshots and code snippets, as otherwise I believe it would be hard to write in
+detail for each of the required parts.
+
+Answer to Question 6
+
+1. The supplied code can be used for Parts 1-5 of the assignment provided it is well documented
+in the report supported by your own description and screenshots - This code, or your own equivalent
+if you prefer to implement your own code for Parts 1-5 ( for example if coding in Python), you can then
+built upon the code for Parts 1-5 by extending Mine( ) as you would need to do for the additional
+assignment tasks - Part 6.
+
+2. The report can make use of appendices, which does not count towards the page limit. The
+Appendix can be used for screenshots, tables and code snippets as you deem appropriate.
+
+Question 7
+
+I was trying to submit my work right now however it won't let me push my files into GitLab. I have
+attached a screenshot of the error, is there any way to fix this ? I will be submitting my report with all
+the screenshots of my code running, however my Gitlab link won't be in there as it won't allow me to
+upload my files. Do let me know if there's any other way I can upload my files.
+
+Answer to Question 7
+
+.There is a presentation on how to use the repository
+It can be quite difficult to debug issues with Git as it does not always provide the most helpful or clear
+error messages. The general process is to: (From the BlockchainAssignment directory)
+
+1. git init (Initialise the local repository)
+2. git add -A (Mark the files to include - all in this case)
+3. git commit -m '...' (Bundle the changes for upload)
+4. git remote add origin [url] (Link the remote repository)
+5. git push -f origin main (Overwrite remote with local commits)
+
+If any of the above stages were missed when you attempted to do upload, then I would suggest trying
+again, or if not, I would suggest uploading the solution (BlockchainAssignment folder) to a shared drive
+or zipping it all and including it in the submission on the Blackboard.
+
+Question 8
+
+I was following the tutorial about processing my transactions but I couldn't see what you had done
+and now have errors from line 30 to line 39. Can you help me please?
+
+                                                                                                                          11
+Answer to Question 8
+
+A common issue may arise due to the getPendingTransactions() function being incomplete and not
+returning a List of transactions as the message signature requires.
+
+The complete function should "pop" (get and remove) the first "n" transactions from the transaction
+pool where n is the lowest value of the two: the maximum number of transactions per block or the
+total number of pending transactions should this be lower. These transactions are then to be returned
+by the function to be used when creating a new block.
+
+The function should be as follows:
+
+     public List<Transaction> GetPendingTransactions()
+     {
+
+        // Determine the number of transactions to retrieve dependent on the number of pending
+
+          transactions and the limit specified
+        int n = Math.Min(transactionsPerBlock, transactionPool.Count);
+
+        // "Pull" transactions from the transaction list (modifying the original list)
+        List<Transaction> transactions = transactionPool.GetRange(0, n);
+        transactionPool.RemoveRange(0, n);
+
+        // Return the extracted transactions
+        return transactions;
+     }
+
+I hope this helps resolve your problem.
+
+Question 9
+
+I have created the merkle root and recieved a final singular hash, I have added it into the CreateHash()
+method within Block class and added it to the PrintBlock() method, is there anywhere else I need to
+use the merkle root to validate anything for checks anywhere?
+
+Answer to Question 9
+
+By including the Merkle root into the Block hash and subsequently the signature any change to a single
+transaction will result in a significantly different hash which will be easy to detect during the validation
+process. This is one of the main advantages of hashing.
+
+Note that during validation, the Merkle root is to be recalculated and compared with that of the
+submitted block and this should be sufficient to prove the validity of the contents of the transactions
+included within the Block.
+
+I hope this clarifies the use of the Merkle root in the validation process.
+
+Question 10  12
+I am not sure what points are most important in my description in my report to demonstrate my
+understanding of what I have done, could you please explain?
+
+Answer to Question 10
+
+You need to ensure that you include:
+
+1) Evidence of completion and execution of the code for Parts 1-5 and any Part 6 tasks (T6.1, 6.2,
+6.3) that you have implemented on top of the code for Parts1-5 and integrated with it (mainly by way
+of Mine() extensions as required] - all supported by resulting screenshots.
+
+2) Description of the steps for the above, in particular the main blockchain concepts for example
+the function and purpose of the following elements of Blockchain.
+
+I.Hashing for tamper-proofing of block contents – an important function and its application is described
+ (combining data to form a unique hash)
+
+II.Asymmetric cryptography
+
+a.  Public and Private Keys for pseudo-anonymous identities and authentication.
+
+b. Digital signatures for secure transactions and non-reputation of transactions.
+
+III.Proof-of-Work as a consensus algorithm in a decentralised network (trust mechanism).
+
+IV.Significance of the confirmation process in preventing attacks through irreversible transactions.
+
+Question 11
+
+I have completed up until the "Processing Transactions & Transaction Pools" section in the week 3
+Blockchain module practical.
+
+I am having trouble with the function associated with the button "create transaction" as I am unsure
+of where "sender address" and "receiver address" would come from in order to give to the transaction
+constructor. Also, I am unsure on what receiver key means and where it comes from. I tried to review
+the video demonstration however this did not show it.
+
+Answer to Question 11
+
+The sender and receiver address will be the public keys (aka IDs) belonging to the two parties involved
+in the transaction. In terms of our simulation parties or individuals are represented as wallets
+containing a public-private key pair and these are generated by pressing the "Generate Keys" button.
+This creates a new Wallet object and populates the two fields in the UI with the corresponding labels.
+Each time this button is pressed a new public-private key pair is generated and so for testing purposes,
+it is necessary to create and make a note of a few test "wallets" and then to create transactions
+between them.
+
+I hope this clarifies the source of the "address" fields in the transaction class.
+
+Question 12
+                                                                                                                          13
+So far in the assignment, I have managed to get everything working successfully up until generating
+the wallets and printing if the keys are valid. It is the create transactions part that I can't get to work.
+I have been struggling to work out how to complete the setting up transactions part of the assignment.
+I attach my code and hope you could explain what is wrong.
+
+Answer to Question 12
+
+The Transaction.cs class was developed has been developed as well as the UI elements for generating
+and validating Wallets (i.e. public-private keys) as presented in the colour coded fully commented
+code. The UI elements can be sued to create transactions which will be placed in a transaction pool
+where pending transactions await being mined.
+
+In the fully commented code, the following variables and functions have been added for this:
+
+1. Transaction.cs (All)
+
+2. BlockchainApp.cs (Functions)
+
+a.  GenerateWallet_Click()
+
+b.  ValidateKeys_Click()
+
+c.  CreateTransaction_Click()
+
+3. Blockchain.cs (Variables)
+
+a.  transactionsPerBlock
+
+b.  transactionPool
+
+Please check that your code for the above is identical to the correct and complete code provided for
+the above elements. Then it must and will work.
+
+Having checked your code, it is clear that you are very close to the solution. The only thing missing is
+the "public" access specifier for the Block attribute in Blockchain.cs (or alternatively, a public method
+in Block.cs to add a new block). This was preventing the application from being built as by default this
+variable is not visible or accessible outside of its class. By adding the public specifier:
+
+public List<Block> Blocks = new List<Block>();)
+
+this means the list will be modifiable within the Blockchain class.
+
+Mac user’s Questions
+
+Question 13
+I have got a Mac how can I set it up to get the coursework done
+
+Answer to Question 13
+                                                                                                                          14
+Jaydon Scarpa kindly provide this for the Mac User’s Club
+
+https://www.youtube.com/watch?v=uis3pvt4wBU
+
+Any issues Jaydon and his colleagues can advise
+Address: They are usually to be found at the row opposite the printer in G56
+
+Question 14
+
+I am using MacOS. I keep getting an error on visual studio "mono64 quit unexpectedly" when trying
+to run the Blockchain. I have tried looking up solutions but have found none. What should I do from
+here?
+
+Answer to Question 14
+
+This appears to be an issue with MacOS's "mono64" not supporting Windows Forms
+(see: https://www.mono-project.com/docs/gui/winforms/getting-started-guide/). The suggested
+solution is to switch to "Mono" (32-bit) in Visual Studio which can be found here:
+"Run > Run with > Custom Configuration > Advanced > Mono runtime settings > Runtime >
+Architecture > 32bit"
+
+I hope this helps resolve your issue and allows you to execute the code on your Mac.
+
+Question 15
+
+I am unable to open up the form design viewer in Visual Studio to modify the UI. I think this may be
+because I am using Mac OS so I've tried installing Xamarin instead but I am still unable to view/edit
+the form.
+
+Answer to Question 15
+
+Running the Blockchain application on Mac can be a bit challenging as the UI which is based on
+Windows Forms, relies on elements built into the Windows operating system. "Mono" on Mac
+attempts to bridge this and bring the same functionality to macOS however not everything is fully
+supported at this time. As a result, the best solution would be to install a Windows Virtual Machine
+(using Parallels, VMWare, Bootcamp, or VBox, etc.) on the Mac to host the Windows OS. This typically
+requires an x64-bit Intel processor however some providers are starting to support Apple chips (M1)
+too.
+
+(See: https://blogs.vmware.com/teamfusion/2021/09/fusion-for-m1-public-tech-preview-now-
+available.html)
+
+Should none of these options be successful, alternative solutions could be to translate the UI elements
+in (BlockchainApp.cs) to Xamarin Forms (see: https://docs.microsoft.com/en-us/xamarin/cross-
+platform/desktop/controls/ for guidance) or to work in another programming language if confident in
+
+                                                                                                                          15
+doing so. Finally, it is also possible to access a Windows machine in the lab or using a cloud provider
+(SaaS/IaaS) e.g. Windows Azure Virtual Machines
+(https://docs.microsoft.com/en-us/azure/virtual-machines/windows/using-visual-studio-vm).
+
+Other relevant sources on the web
+
+Preview: Bringing macOS to Xamarin.Forms - Xamarin Blog
+https://devblogs.microsoft.com/xamarin/preview-bringing-macos-to...
+Developing for macOS is a Mac only feature, so the same rules apply as when you are doing
+a Xamarin.Mac application. There is an excellent Xamarin.Mac guide here that covers the pre-
+requisites. When the time comes for you to integrate your Xamarin.Forms macOS project into a
+continuous integration system……
+See more on devblogs.microsoft.com
+
+EXPLORING FURTHER                                                    stackoverflow.com
+                                                                     www.c-sharpcorner.com
+          Xamarin.Forms targeting macOS - Stack Overflow             www.xamarinexpert.it
+          Creating a MAC Application Using Xamarin.Forms             nicksnettravels.builttoroam.com
+          How to test your Xamarin.Forms iOS apps without a Mac ...  docs.microsoft.com
+          Look iOS Developer, No Mac Required - Build an iOS ...
+          Mac Platform Setup - Xamarin | Microsoft Docs
+
+•  c# - How to run a Windows Forms application on macOS ...
+
+https://stackoverflow.com/questions/35566777
+
+Comments
+
+I've used Xamarin and GTK#, as well as Xamarin for code-behind and XCode for forms design. They
+both work pretty decently with C#
+
+Wine is capable of running some winforms-based Windows applications on Mac OSX. When it works
+as intended, all you have to do is install Wine.
+You might be able to cross-compile using Mono. http://www.mono-
+project.com/docs/gui/winforms/.
+
+c# - How to run a Windows Forms application on macOS
+tackoverflow.com/questions/35566777/how-to-run-a-win…
+
+Mac Platform Setup - Xamarin | Microsoft Docs
+https://docs.microsoft.com/en-us/xamarin/xamarin-forms/platform/other/mac
+
+Follow these instructions to add a Mac app that will run on macOS Sierra and macOS El Capitan: 1. In
+Visual Studio for Mac, right-click on the existing Xamarin.Forms solution and choose Add > Add New
+Project... 2. In the New Project window choose Mac > App > Cocoa App and press Next. 3. Type an
+App Name (and optionally choose a different name for the Dock Item), then press Ne…
+
+New Xamarin.Forms XAML IntelliSense in Visual Studio …                     16
+https://devblogs.microsoft.com/xamarin/xaml-intellisense-vs4m-xamarin-forms
+How To: Setting up macOS X Sierra on ... - Auri's Blog
+https://auri.net/2016/11/20/how-to-setting-up-macos-x-sierra-on...
+First, open Safari – unless you installed something else on the Mac already – and
+download Xamarin Studio for Mac. This is simple – go to Xamarin.com, and download the installer.
+Open the installer on your Mac from the Downloads folder, and click Open when it warns you that it’s
+an application downloaded from the Internet.
+System Requirements - Xamarin | Microsoft Docs
+https://docs.microsoft.com/en-us/xamarin/cross-platform/get-started/...
+
+                                                                                                                          17
+

commit e7106098387a4822d77984ac0101f7508bba17c4
Author: “nk002734” <“nk002734@student.reading.ac.uk”>
Date:   Tue Mar 25 13:23:40 2025 +0000

    start writing report

diff --git a/Luke Wilson CS3BC Coursework.docx b/Luke Wilson CS3BC Coursework.docx
index 3011b4a..a0e7453 100644
--- a/Luke Wilson CS3BC Coursework.docx	
+++ b/Luke Wilson CS3BC Coursework.docx	
@@ -5,7 +5,10 @@ Date (when the work was completed):
 Actual hrs spent for the assignment:
 Which Artificial Intelligence tools used (if applicable):
 
-Part 1:
+Part 1
+To get start with the project, a new windows forms project was created using Visual Studio which contains a blank customisable UI. I added a RichTextBox which will be used to print the outputs, along with a print button and a TextBox. Once these elements were added to the UI, I customised them so that when the button is pressed, whatever text is inside the TextBox, shows in the large RichTextBox. Now a blockchain is ready to be created.
+Part 2
+Next, I created two classes, one named Block and another named Blockchain. When our program starts and program.cs is called, we want to initialise a single blockchain, which will contain multiple blocks inside. The first block created is called the genesis block 
 
 
 Part 2:
@@ -21,3 +24,9 @@ Both blocks shown with the transaction shown in the second block
 
 
 Part 5: 
+
+Appendix
+Part 1
+
+Part 2
+

commit 880a49c0fad9dd7c9bdd437e19737b57deacc059
Author: Luke <lukefwilson@gmail.com>
Date:   Tue Mar 18 13:52:01 2025 +0000

    finish coursework

diff --git a/BlockchainAssignment/Block.cs b/BlockchainAssignment/Block.cs
index de020be..8bf7b6c 100644
--- a/BlockchainAssignment/Block.cs
+++ b/BlockchainAssignment/Block.cs
@@ -14,7 +14,8 @@ namespace BlockchainAssignment
         private DateTime timestamp; // Time of creation
 
         private int index, // Position of the block in the sequence of blocks
-            difficulty = 5; // An arbitrary number of 0's to proceed a hash value
+            difficulty,
+            prevDifficulty; // An arbitrary number of 0's to proceed a hash value
 
         public String prevHash, // A reference pointer to the previous block
             hash, // The current blocks "identity"
@@ -28,7 +29,9 @@ namespace BlockchainAssignment
 
         // Rewards
         public double reward; // Simple fixed reward established by "Coinbase"
+        private double targetBlockTime = 15; // Target time between blocks in seconds
         private double miningTime;
+        public double prevMiningTime; // Time taken to mine the previous block
         private string threadingType;
         const int threadCount = 4; // Hard-coded number of threads
 
@@ -37,6 +40,8 @@ namespace BlockchainAssignment
         {
             timestamp = DateTime.Now;
             index = 0;
+            prevMiningTime = 0;
+            difficulty = 4;
             transactionList = new List<Transaction>();
             hash = MineMultiThreaded();
         }
@@ -48,6 +53,9 @@ namespace BlockchainAssignment
 
             index = lastBlock.index + 1;
             prevHash = lastBlock.hash;
+            prevMiningTime = lastBlock.miningTime;
+            prevDifficulty = lastBlock.difficulty;
+            difficulty = CalculateDifficulty();
 
             this.minerAddress = minerAddress; // The wallet to be credited the reward for the mining effort
             reward = 1.0; // Assign a simple fixed value reward
@@ -58,6 +66,11 @@ namespace BlockchainAssignment
             hash = multithreaded ? MineMultiThreaded() : Mine(); // Conduct PoW to create a hash which meets the given difficulty requirement
         }
 
+        private int CalculateDifficulty()
+        {
+            return prevMiningTime < targetBlockTime ? prevDifficulty + 1 : prevDifficulty - 1;
+        }
+
         /* Hashes the entire Block object */
         public String CreateHash(long nonce)
         {
diff --git a/BlockchainAssignment/Blockchain.cs b/BlockchainAssignment/Blockchain.cs
index 26fe0fb..47a2cd8 100644
--- a/BlockchainAssignment/Blockchain.cs
+++ b/BlockchainAssignment/Blockchain.cs
@@ -43,11 +43,33 @@ namespace BlockchainAssignment
         }
 
         // Retrieve pending transactions and remove from pool
-        public List<Transaction> GetPendingTransactions()
+        public List<Transaction> GetPendingTransactions(MiningMode mode)
         {
             // Determine the number of transactions to retrieve dependent on the number of pending transactions and the limit specified
             int n = Math.Min(transactionsPerBlock, transactionPool.Count);
 
+            if (mode == MiningMode.Greedy)
+            {
+                transactionPool.Sort((x, y) => y.fee.CompareTo(x.fee));
+            }
+            else if (mode == MiningMode.Altruistic)
+            {
+                transactionPool.Sort((x, y) => x.timestamp.CompareTo(y.timestamp));
+            }
+            else if (mode == MiningMode.Random)
+            {
+                Random rng = new Random();
+                int i = transactionPool.Count;
+                while (i > 1)
+                {
+                    i--;
+                    int k = rng.Next(i + 1);
+                    Transaction value = transactionPool[k]; // swap the values around
+                    transactionPool[k] = transactionPool[i];
+                    transactionPool[i] = value;
+                }
+            }
+
             // "Pull" transactions from the transaction list (modifying the original list)
             List<Transaction> transactions = transactionPool.GetRange(0, n);
             transactionPool.RemoveRange(0, n);
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
index 2b3d984..bb4a342 100644
--- a/BlockchainAssignment/BlockchainApp.Designer.cs
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -54,6 +54,12 @@
             this.blocksLabel = new System.Windows.Forms.Label();
             this.validationLabel = new System.Windows.Forms.Label();
             this.newBlockSingleThread = new System.Windows.Forms.Button();
+            this.label1 = new System.Windows.Forms.Label();
+            this.GreedyButton = new System.Windows.Forms.RadioButton();
+            this.AltruisticButton = new System.Windows.Forms.RadioButton();
+            this.RandomButton = new System.Windows.Forms.RadioButton();
+            this.groupBox1 = new System.Windows.Forms.GroupBox();
+            this.groupBox1.SuspendLayout();
             this.SuspendLayout();
             // 
             // output
@@ -68,7 +74,7 @@
             // 
             // printBlock
             // 
-            this.printBlock.Location = new System.Drawing.Point(486, 224);
+            this.printBlock.Location = new System.Drawing.Point(486, 121);
             this.printBlock.Margin = new System.Windows.Forms.Padding(2);
             this.printBlock.Name = "printBlock";
             this.printBlock.Size = new System.Drawing.Size(66, 25);
@@ -79,7 +85,7 @@
             // 
             // blockNo
             // 
-            this.blockNo.Location = new System.Drawing.Point(556, 227);
+            this.blockNo.Location = new System.Drawing.Point(556, 124);
             this.blockNo.Margin = new System.Windows.Forms.Padding(2);
             this.blockNo.Name = "blockNo";
             this.blockNo.Size = new System.Drawing.Size(24, 20);
@@ -145,7 +151,7 @@
             // 
             // createTransaction
             // 
-            this.createTransaction.Location = new System.Drawing.Point(486, 391);
+            this.createTransaction.Location = new System.Drawing.Point(486, 288);
             this.createTransaction.Margin = new System.Windows.Forms.Padding(2);
             this.createTransaction.Name = "createTransaction";
             this.createTransaction.Size = new System.Drawing.Size(196, 26);
@@ -156,7 +162,7 @@
             // 
             // fee
             // 
-            this.fee.Location = new System.Drawing.Point(646, 343);
+            this.fee.Location = new System.Drawing.Point(646, 240);
             this.fee.Margin = new System.Windows.Forms.Padding(2);
             this.fee.Name = "fee";
             this.fee.Size = new System.Drawing.Size(36, 20);
@@ -164,7 +170,7 @@
             // 
             // amount
             // 
-            this.amount.Location = new System.Drawing.Point(577, 343);
+            this.amount.Location = new System.Drawing.Point(577, 240);
             this.amount.Margin = new System.Windows.Forms.Padding(2);
             this.amount.Name = "amount";
             this.amount.Size = new System.Drawing.Size(36, 20);
@@ -173,7 +179,7 @@
             // feeLabel
             // 
             this.feeLabel.AutoSize = true;
-            this.feeLabel.Location = new System.Drawing.Point(617, 346);
+            this.feeLabel.Location = new System.Drawing.Point(617, 243);
             this.feeLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.feeLabel.Name = "feeLabel";
             this.feeLabel.Size = new System.Drawing.Size(25, 13);
@@ -183,7 +189,7 @@
             // amountLabel
             // 
             this.amountLabel.AutoSize = true;
-            this.amountLabel.Location = new System.Drawing.Point(530, 346);
+            this.amountLabel.Location = new System.Drawing.Point(530, 243);
             this.amountLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.amountLabel.Name = "amountLabel";
             this.amountLabel.Size = new System.Drawing.Size(43, 13);
@@ -192,7 +198,7 @@
             // 
             // reciever
             // 
-            this.reciever.Location = new System.Drawing.Point(563, 367);
+            this.reciever.Location = new System.Drawing.Point(563, 264);
             this.reciever.Margin = new System.Windows.Forms.Padding(2);
             this.reciever.Name = "reciever";
             this.reciever.Size = new System.Drawing.Size(119, 20);
@@ -201,7 +207,7 @@
             // recieverKeyLabel
             // 
             this.recieverKeyLabel.AutoSize = true;
-            this.recieverKeyLabel.Location = new System.Drawing.Point(488, 370);
+            this.recieverKeyLabel.Location = new System.Drawing.Point(488, 267);
             this.recieverKeyLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.recieverKeyLabel.Name = "recieverKeyLabel";
             this.recieverKeyLabel.Size = new System.Drawing.Size(71, 13);
@@ -210,7 +216,7 @@
             // 
             // newBlockMultiThread
             // 
-            this.newBlockMultiThread.Location = new System.Drawing.Point(485, 194);
+            this.newBlockMultiThread.Location = new System.Drawing.Point(485, 91);
             this.newBlockMultiThread.Margin = new System.Windows.Forms.Padding(2);
             this.newBlockMultiThread.Name = "newBlockMultiThread";
             this.newBlockMultiThread.Size = new System.Drawing.Size(197, 26);
@@ -221,7 +227,7 @@
             // 
             // printBlockchain
             // 
-            this.printBlockchain.Location = new System.Drawing.Point(584, 224);
+            this.printBlockchain.Location = new System.Drawing.Point(584, 121);
             this.printBlockchain.Margin = new System.Windows.Forms.Padding(2);
             this.printBlockchain.Name = "printBlockchain";
             this.printBlockchain.Size = new System.Drawing.Size(98, 25);
@@ -232,7 +238,7 @@
             // 
             // readPendingTransactions
             // 
-            this.readPendingTransactions.Location = new System.Drawing.Point(486, 421);
+            this.readPendingTransactions.Location = new System.Drawing.Point(486, 318);
             this.readPendingTransactions.Margin = new System.Windows.Forms.Padding(2);
             this.readPendingTransactions.Name = "readPendingTransactions";
             this.readPendingTransactions.Size = new System.Drawing.Size(196, 25);
@@ -276,7 +282,7 @@
             // transactionLabel
             // 
             this.transactionLabel.AutoSize = true;
-            this.transactionLabel.Location = new System.Drawing.Point(483, 319);
+            this.transactionLabel.Location = new System.Drawing.Point(483, 216);
             this.transactionLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.transactionLabel.Name = "transactionLabel";
             this.transactionLabel.Size = new System.Drawing.Size(68, 13);
@@ -286,7 +292,7 @@
             // blocksLabel
             // 
             this.blocksLabel.AutoSize = true;
-            this.blocksLabel.Location = new System.Drawing.Point(483, 149);
+            this.blocksLabel.Location = new System.Drawing.Point(483, 46);
             this.blocksLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.blocksLabel.Name = "blocksLabel";
             this.blocksLabel.Size = new System.Drawing.Size(39, 13);
@@ -305,7 +311,7 @@
             // 
             // newBlockSingleThread
             // 
-            this.newBlockSingleThread.Location = new System.Drawing.Point(485, 164);
+            this.newBlockSingleThread.Location = new System.Drawing.Point(485, 61);
             this.newBlockSingleThread.Margin = new System.Windows.Forms.Padding(2);
             this.newBlockSingleThread.Name = "newBlockSingleThread";
             this.newBlockSingleThread.Size = new System.Drawing.Size(197, 26);
@@ -314,12 +320,69 @@
             this.newBlockSingleThread.UseVisualStyleBackColor = true;
             this.newBlockSingleThread.Click += new System.EventHandler(this.newBlockSingleThread_Click);
             // 
+            // label1
+            // 
+            this.label1.AutoSize = true;
+            this.label1.Location = new System.Drawing.Point(482, 383);
+            this.label1.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
+            this.label1.Name = "label1";
+            this.label1.Size = new System.Drawing.Size(0, 13);
+            this.label1.TabIndex = 27;
+            // 
+            // GreedyButton
+            // 
+            this.GreedyButton.AutoSize = true;
+            this.GreedyButton.Checked = true;
+            this.GreedyButton.Location = new System.Drawing.Point(31, 19);
+            this.GreedyButton.Name = "GreedyButton";
+            this.GreedyButton.Size = new System.Drawing.Size(59, 17);
+            this.GreedyButton.TabIndex = 28;
+            this.GreedyButton.TabStop = true;
+            this.GreedyButton.Text = "Greedy";
+            this.GreedyButton.UseVisualStyleBackColor = true;
+            // 
+            // AltruisticButton
+            // 
+            this.AltruisticButton.AutoSize = true;
+            this.AltruisticButton.Location = new System.Drawing.Point(31, 42);
+            this.AltruisticButton.Name = "AltruisticButton";
+            this.AltruisticButton.Size = new System.Drawing.Size(64, 17);
+            this.AltruisticButton.TabIndex = 29;
+            this.AltruisticButton.TabStop = true;
+            this.AltruisticButton.Text = "Altruistic";
+            this.AltruisticButton.UseVisualStyleBackColor = true;
+            // 
+            // RandomButton
+            // 
+            this.RandomButton.AutoSize = true;
+            this.RandomButton.Location = new System.Drawing.Point(31, 65);
+            this.RandomButton.Name = "RandomButton";
+            this.RandomButton.Size = new System.Drawing.Size(65, 17);
+            this.RandomButton.TabIndex = 30;
+            this.RandomButton.TabStop = true;
+            this.RandomButton.Text = "Random";
+            this.RandomButton.UseVisualStyleBackColor = true;
+            // 
+            // groupBox1
+            // 
+            this.groupBox1.Controls.Add(this.GreedyButton);
+            this.groupBox1.Controls.Add(this.AltruisticButton);
+            this.groupBox1.Controls.Add(this.RandomButton);
+            this.groupBox1.Location = new System.Drawing.Point(485, 406);
+            this.groupBox1.Name = "groupBox1";
+            this.groupBox1.Size = new System.Drawing.Size(200, 94);
+            this.groupBox1.TabIndex = 32;
+            this.groupBox1.TabStop = false;
+            this.groupBox1.Text = "Mining Mode";
+            // 
             // BlockchainApp
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.ActiveCaption;
             this.ClientSize = new System.Drawing.Size(693, 726);
+            this.Controls.Add(this.groupBox1);
+            this.Controls.Add(this.label1);
             this.Controls.Add(this.createTransaction);
             this.Controls.Add(this.newBlockSingleThread);
             this.Controls.Add(this.validationLabel);
@@ -349,6 +412,8 @@
             this.ForeColor = System.Drawing.Color.Black;
             this.Name = "BlockchainApp";
             this.Text = "Blockchain App";
+            this.groupBox1.ResumeLayout(false);
+            this.groupBox1.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
@@ -382,6 +447,11 @@
         private System.Windows.Forms.Label blocksLabel;
         private System.Windows.Forms.Label validationLabel;
         private System.Windows.Forms.Button newBlockSingleThread;
+        private System.Windows.Forms.Label label1;
+        private System.Windows.Forms.RadioButton GreedyButton;
+        private System.Windows.Forms.RadioButton AltruisticButton;
+        private System.Windows.Forms.RadioButton RandomButton;
+        private System.Windows.Forms.GroupBox groupBox1;
     }
 }
 
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
index bc81a49..42cb903 100644
--- a/BlockchainAssignment/BlockchainApp.cs
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -86,8 +86,17 @@ namespace BlockchainAssignment
 
         private void newBlock(bool multithreaded)
         {
+
+            var mode = new MiningMode();
+            if (GreedyButton.Enabled)
+                mode = MiningMode.Greedy;
+            else if (AltruisticButton.Enabled)
+                mode = MiningMode.Altruistic;
+            else if (RandomButton.Enabled)
+                mode = MiningMode.Random;
+
             // Retrieve pending transactions to be added to the newly generated Block
-            List<Transaction> transactions = blockchain.GetPendingTransactions();
+            List<Transaction> transactions = blockchain.GetPendingTransactions(mode);
 
             // Create and append the new block - requires a reference to the previous block, a set of transactions and the miners public address (For the reward to be issued)
             Block newBlock = new Block(blockchain.GetLastBlock(), transactions, publicKey.Text, multithreaded);
@@ -137,5 +146,10 @@ namespace BlockchainAssignment
             }
             UpdateText("Blockchain is valid");
         }
+
+        private void label1_Click(object sender, EventArgs e)
+        {
+
+        }
     }
 }
\ No newline at end of file
diff --git a/BlockchainAssignment/BlockchainAssignment.csproj b/BlockchainAssignment/BlockchainAssignment.csproj
index e2a0582..bf051c7 100644
--- a/BlockchainAssignment/BlockchainAssignment.csproj
+++ b/BlockchainAssignment/BlockchainAssignment.csproj
@@ -55,6 +55,7 @@
       <DependentUpon>BlockchainApp.cs</DependentUpon>
     </Compile>
     <Compile Include="HashCode\HashTools.cs" />
+    <Compile Include="MiningMode.cs" />
     <Compile Include="Program.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="Transaction.cs" />
diff --git a/BlockchainAssignment/MiningMode.cs b/BlockchainAssignment/MiningMode.cs
new file mode 100644
index 0000000..a1a32d6
--- /dev/null
+++ b/BlockchainAssignment/MiningMode.cs
@@ -0,0 +1,15 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+    public enum MiningMode
+    {
+        Greedy,
+        Altruistic,
+        Random,
+    }
+}
diff --git a/BlockchainAssignment/Transaction.cs b/BlockchainAssignment/Transaction.cs
index 69e42d5..1a657d7 100644
--- a/BlockchainAssignment/Transaction.cs
+++ b/BlockchainAssignment/Transaction.cs
@@ -10,7 +10,7 @@ namespace BlockchainAssignment
     class Transaction
     {
         /* Transaction Variables */
-        DateTime timestamp; // Time of creation
+        public DateTime timestamp; // Time of creation
         public String senderAddress, recipientAddress; // Participants public key addresses
         public double amount, fee; // Quantities transferred
         public String hash, signature; // Attributes for verification of validity

commit 236606257e6d02e21d9c86a6d46df038bfc20346
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Tue Mar 11 17:39:09 2025 +0000

    COMPLETE MULTITHREADING

diff --git a/BlockchainAssignment/Block.cs b/BlockchainAssignment/Block.cs
index d0ee88b..de020be 100644
--- a/BlockchainAssignment/Block.cs
+++ b/BlockchainAssignment/Block.cs
@@ -1,8 +1,10 @@
 ﻿using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
 using System.Security.Cryptography;
 using System.Text;
+using System.Threading;
 
 namespace BlockchainAssignment
 {
@@ -12,7 +14,7 @@ namespace BlockchainAssignment
         private DateTime timestamp; // Time of creation
 
         private int index, // Position of the block in the sequence of blocks
-            difficulty = 4; // An arbitrary number of 0's to proceed a hash value
+            difficulty = 5; // An arbitrary number of 0's to proceed a hash value
 
         public String prevHash, // A reference pointer to the previous block
             hash, // The current blocks "identity"
@@ -26,6 +28,9 @@ namespace BlockchainAssignment
 
         // Rewards
         public double reward; // Simple fixed reward established by "Coinbase"
+        private double miningTime;
+        private string threadingType;
+        const int threadCount = 4; // Hard-coded number of threads
 
         /* Genesis block constructor */
         public Block()
@@ -33,11 +38,11 @@ namespace BlockchainAssignment
             timestamp = DateTime.Now;
             index = 0;
             transactionList = new List<Transaction>();
-            hash = Mine();
+            hash = MineMultiThreaded();
         }
 
         /* New Block constructor */
-        public Block(Block lastBlock, List<Transaction> transactions, String minerAddress)
+        public Block(Block lastBlock, List<Transaction> transactions, String minerAddress, bool multithreaded)
         {
             timestamp = DateTime.Now;
 
@@ -50,11 +55,11 @@ namespace BlockchainAssignment
             transactionList = new List<Transaction>(transactions); // Assign provided transactions to the block
 
             merkleRoot = MerkleRoot(transactionList); // Calculate the merkle root of the blocks transactions
-            hash = Mine(); // Conduct PoW to create a hash which meets the given difficulty requirement
+            hash = multithreaded ? MineMultiThreaded() : Mine(); // Conduct PoW to create a hash which meets the given difficulty requirement
         }
 
         /* Hashes the entire Block object */
-        public String CreateHash()
+        public String CreateHash(long nonce)
         {
             String hash = String.Empty;
             SHA256 hasher = SHA256Managed.Create();
@@ -73,19 +78,78 @@ namespace BlockchainAssignment
         }
 
         // Create a Hash which satisfies the difficulty level required for PoW
+        public String MineMultiThreaded()
+        {
+            var stopwatch = Stopwatch.StartNew();
+            Thread[] miners = new Thread[threadCount];
+            bool found = false;
+            String finalHash = String.Empty;
+            long successfulNonce = 0;
+
+            String re = new string('0', difficulty); // A string for analysing the PoW requirement
+
+            object lockObject = new object();
+
+            void MineThread(object threadId)
+            {
+                long threadNonce = (int)threadId; // TODO check we can cast to int then set as long
+                String hash;
+
+                while (!found)
+                {
+                    hash = CreateHash(threadNonce);
+
+                    if (hash.StartsWith(re))
+                    {
+                        lock (lockObject)
+                        {
+                            if (!found)
+                            {
+                                found = true;
+                                finalHash = hash;
+                                successfulNonce = threadNonce;
+                            }
+                        }
+                        break;
+                    }
+                    threadNonce += threadCount;
+                }
+            }
+
+            for (int i = 0; i < threadCount; i++)
+            {
+                miners[i] = new Thread(MineThread);
+                miners[i].Start(i);
+            }
+
+            foreach (var thread in miners)
+            {
+                thread.Join();
+            }
+
+            nonce = successfulNonce;
+            stopwatch.Stop();
+            miningTime = stopwatch.Elapsed.TotalSeconds;
+            threadingType = "Multi";
+            return finalHash;
+        }
+
         public String Mine()
         {
+            var stopwatch = Stopwatch.StartNew();
             nonce = 0; // Initalise the nonce
-            String hash = CreateHash(); // Hash the block
-
+            String hash = CreateHash(nonce); // Hash the block
             String re = new string('0', difficulty); // A string for analysing the PoW requirement
 
             while (!hash.StartsWith(re)) // Check the resultant hash against the "re" string
             {
                 nonce++; // Increment the nonce should the difficulty level not be satisfied
-                hash = CreateHash(); // Rehash with the new nonce as to generate a different hash
+                hash = CreateHash(nonce); // Rehash with the new nonce as to generate a different hash
             }
 
+            stopwatch.Stop();
+            miningTime = stopwatch.Elapsed.TotalSeconds;
+            threadingType = "Single";
             return hash; // Return the hash meeting the difficulty requirement
         }
 
@@ -141,13 +205,15 @@ namespace BlockchainAssignment
                 + "\nDifficulty Level: " + difficulty
                 + "\nNonce: " + nonce
                 + "\nHash: " + hash
+                + $"\nMining Time: {miningTime:F3} seconds"
+                + "\nThreading Type: " + threadingType
                 + "\n-- Rewards --"
                 + "\nReward: " + reward
                 + "\nMiners Address: " + minerAddress
                 + "\n-- " + transactionList.Count + " Transactions --"
                 + "\nMerkle Root: " + merkleRoot
                 + "\n" + String.Join("\n", transactionList)
-                + "\n[BLOCK END]";
+                + "\n[BLOCK END]\n";
         }
     }
 }
diff --git a/BlockchainAssignment/Blockchain.cs b/BlockchainAssignment/Blockchain.cs
index fc16914..26fe0fb 100644
--- a/BlockchainAssignment/Blockchain.cs
+++ b/BlockchainAssignment/Blockchain.cs
@@ -59,7 +59,7 @@ namespace BlockchainAssignment
         // Check validity of a blocks hash by recomputing the hash and comparing with the mined value
         public static bool ValidateHash(Block b)
         {
-            String rehash = b.CreateHash();
+            String rehash = b.CreateHash(b.nonce);
             return rehash.Equals(b.hash);
         }
 
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
index 7465c58..2b3d984 100644
--- a/BlockchainAssignment/BlockchainApp.Designer.cs
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -44,7 +44,7 @@
             this.amountLabel = new System.Windows.Forms.Label();
             this.reciever = new System.Windows.Forms.TextBox();
             this.recieverKeyLabel = new System.Windows.Forms.Label();
-            this.newBlock = new System.Windows.Forms.Button();
+            this.newBlockMultiThread = new System.Windows.Forms.Button();
             this.printBlockchain = new System.Windows.Forms.Button();
             this.readPendingTransactions = new System.Windows.Forms.Button();
             this.validate = new System.Windows.Forms.Button();
@@ -53,24 +53,25 @@
             this.transactionLabel = new System.Windows.Forms.Label();
             this.blocksLabel = new System.Windows.Forms.Label();
             this.validationLabel = new System.Windows.Forms.Label();
+            this.newBlockSingleThread = new System.Windows.Forms.Button();
             this.SuspendLayout();
             // 
             // output
             // 
             this.output.BackColor = System.Drawing.SystemColors.InfoText;
             this.output.ForeColor = System.Drawing.SystemColors.ButtonHighlight;
-            this.output.Location = new System.Drawing.Point(18, 18);
-            this.output.Margin = new System.Windows.Forms.Padding(4, 5, 4, 5);
+            this.output.Location = new System.Drawing.Point(12, 12);
             this.output.Name = "output";
-            this.output.Size = new System.Drawing.Size(688, 341);
+            this.output.Size = new System.Drawing.Size(460, 602);
             this.output.TabIndex = 0;
             this.output.Text = "";
             // 
             // printBlock
             // 
-            this.printBlock.Location = new System.Drawing.Point(716, 99);
+            this.printBlock.Location = new System.Drawing.Point(486, 224);
+            this.printBlock.Margin = new System.Windows.Forms.Padding(2);
             this.printBlock.Name = "printBlock";
-            this.printBlock.Size = new System.Drawing.Size(99, 39);
+            this.printBlock.Size = new System.Drawing.Size(66, 25);
             this.printBlock.TabIndex = 1;
             this.printBlock.Text = "Block #";
             this.printBlock.UseVisualStyleBackColor = true;
@@ -78,16 +79,18 @@
             // 
             // blockNo
             // 
-            this.blockNo.Location = new System.Drawing.Point(821, 105);
+            this.blockNo.Location = new System.Drawing.Point(556, 227);
+            this.blockNo.Margin = new System.Windows.Forms.Padding(2);
             this.blockNo.Name = "blockNo";
-            this.blockNo.Size = new System.Drawing.Size(34, 26);
+            this.blockNo.Size = new System.Drawing.Size(24, 20);
             this.blockNo.TabIndex = 2;
             // 
             // generateWallet
             // 
-            this.generateWallet.Location = new System.Drawing.Point(38, 411);
+            this.generateWallet.Location = new System.Drawing.Point(11, 660);
+            this.generateWallet.Margin = new System.Windows.Forms.Padding(2);
             this.generateWallet.Name = "generateWallet";
-            this.generateWallet.Size = new System.Drawing.Size(119, 84);
+            this.generateWallet.Size = new System.Drawing.Size(79, 55);
             this.generateWallet.TabIndex = 3;
             this.generateWallet.Text = "Generate New Wallet";
             this.generateWallet.UseVisualStyleBackColor = true;
@@ -96,40 +99,45 @@
             // publicKeyLabel
             // 
             this.publicKeyLabel.AutoSize = true;
-            this.publicKeyLabel.Location = new System.Drawing.Point(169, 430);
+            this.publicKeyLabel.Location = new System.Drawing.Point(120, 674);
+            this.publicKeyLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.publicKeyLabel.Name = "publicKeyLabel";
-            this.publicKeyLabel.Size = new System.Drawing.Size(81, 20);
+            this.publicKeyLabel.Size = new System.Drawing.Size(57, 13);
             this.publicKeyLabel.TabIndex = 4;
             this.publicKeyLabel.Text = "Public Key";
             // 
             // privateKeyLabel
             // 
             this.privateKeyLabel.AutoSize = true;
-            this.privateKeyLabel.Location = new System.Drawing.Point(163, 462);
+            this.privateKeyLabel.Location = new System.Drawing.Point(120, 698);
+            this.privateKeyLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.privateKeyLabel.Name = "privateKeyLabel";
-            this.privateKeyLabel.Size = new System.Drawing.Size(87, 20);
+            this.privateKeyLabel.Size = new System.Drawing.Size(61, 13);
             this.privateKeyLabel.TabIndex = 5;
             this.privateKeyLabel.Text = "Private Key";
             // 
             // publicKey
             // 
-            this.publicKey.Location = new System.Drawing.Point(253, 424);
+            this.publicKey.Location = new System.Drawing.Point(185, 671);
+            this.publicKey.Margin = new System.Windows.Forms.Padding(2);
             this.publicKey.Name = "publicKey";
-            this.publicKey.Size = new System.Drawing.Size(282, 26);
+            this.publicKey.Size = new System.Drawing.Size(187, 20);
             this.publicKey.TabIndex = 6;
             // 
             // privateKey
             // 
-            this.privateKey.Location = new System.Drawing.Point(256, 456);
+            this.privateKey.Location = new System.Drawing.Point(185, 695);
+            this.privateKey.Margin = new System.Windows.Forms.Padding(2);
             this.privateKey.Name = "privateKey";
-            this.privateKey.Size = new System.Drawing.Size(279, 26);
+            this.privateKey.Size = new System.Drawing.Size(187, 20);
             this.privateKey.TabIndex = 7;
             // 
             // validateKeys
             // 
-            this.validateKeys.Location = new System.Drawing.Point(550, 421);
+            this.validateKeys.Location = new System.Drawing.Point(376, 669);
+            this.validateKeys.Margin = new System.Windows.Forms.Padding(2);
             this.validateKeys.Name = "validateKeys";
-            this.validateKeys.Size = new System.Drawing.Size(131, 34);
+            this.validateKeys.Size = new System.Drawing.Size(87, 22);
             this.validateKeys.TabIndex = 8;
             this.validateKeys.Text = "Validate Keys";
             this.validateKeys.UseVisualStyleBackColor = true;
@@ -137,9 +145,10 @@
             // 
             // createTransaction
             // 
-            this.createTransaction.Location = new System.Drawing.Point(714, 269);
+            this.createTransaction.Location = new System.Drawing.Point(486, 391);
+            this.createTransaction.Margin = new System.Windows.Forms.Padding(2);
             this.createTransaction.Name = "createTransaction";
-            this.createTransaction.Size = new System.Drawing.Size(293, 40);
+            this.createTransaction.Size = new System.Drawing.Size(196, 26);
             this.createTransaction.TabIndex = 9;
             this.createTransaction.Text = "Create Transaction";
             this.createTransaction.UseVisualStyleBackColor = true;
@@ -147,67 +156,75 @@
             // 
             // fee
             // 
-            this.fee.Location = new System.Drawing.Point(956, 206);
+            this.fee.Location = new System.Drawing.Point(646, 343);
+            this.fee.Margin = new System.Windows.Forms.Padding(2);
             this.fee.Name = "fee";
-            this.fee.Size = new System.Drawing.Size(52, 26);
+            this.fee.Size = new System.Drawing.Size(36, 20);
             this.fee.TabIndex = 13;
             // 
             // amount
             // 
-            this.amount.Location = new System.Drawing.Point(831, 206);
+            this.amount.Location = new System.Drawing.Point(577, 343);
+            this.amount.Margin = new System.Windows.Forms.Padding(2);
             this.amount.Name = "amount";
-            this.amount.Size = new System.Drawing.Size(52, 26);
+            this.amount.Size = new System.Drawing.Size(36, 20);
             this.amount.TabIndex = 12;
             // 
             // feeLabel
             // 
             this.feeLabel.AutoSize = true;
-            this.feeLabel.Location = new System.Drawing.Point(913, 209);
+            this.feeLabel.Location = new System.Drawing.Point(617, 346);
+            this.feeLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.feeLabel.Name = "feeLabel";
-            this.feeLabel.Size = new System.Drawing.Size(37, 20);
+            this.feeLabel.Size = new System.Drawing.Size(25, 13);
             this.feeLabel.TabIndex = 11;
             this.feeLabel.Text = "Fee";
             // 
             // amountLabel
             // 
             this.amountLabel.AutoSize = true;
-            this.amountLabel.Location = new System.Drawing.Point(760, 209);
+            this.amountLabel.Location = new System.Drawing.Point(530, 346);
+            this.amountLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.amountLabel.Name = "amountLabel";
-            this.amountLabel.Size = new System.Drawing.Size(65, 20);
+            this.amountLabel.Size = new System.Drawing.Size(43, 13);
             this.amountLabel.TabIndex = 10;
             this.amountLabel.Text = "Amount";
             // 
             // reciever
             // 
-            this.reciever.Location = new System.Drawing.Point(831, 237);
+            this.reciever.Location = new System.Drawing.Point(563, 367);
+            this.reciever.Margin = new System.Windows.Forms.Padding(2);
             this.reciever.Name = "reciever";
-            this.reciever.Size = new System.Drawing.Size(177, 26);
+            this.reciever.Size = new System.Drawing.Size(119, 20);
             this.reciever.TabIndex = 15;
             // 
             // recieverKeyLabel
             // 
             this.recieverKeyLabel.AutoSize = true;
-            this.recieverKeyLabel.Location = new System.Drawing.Point(724, 240);
+            this.recieverKeyLabel.Location = new System.Drawing.Point(488, 370);
+            this.recieverKeyLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.recieverKeyLabel.Name = "recieverKeyLabel";
-            this.recieverKeyLabel.Size = new System.Drawing.Size(101, 20);
+            this.recieverKeyLabel.Size = new System.Drawing.Size(71, 13);
             this.recieverKeyLabel.TabIndex = 14;
             this.recieverKeyLabel.Text = "Reciever Key";
             // 
-            // newBlock
+            // newBlockMultiThread
             // 
-            this.newBlock.Location = new System.Drawing.Point(717, 51);
-            this.newBlock.Name = "newBlock";
-            this.newBlock.Size = new System.Drawing.Size(294, 40);
-            this.newBlock.TabIndex = 16;
-            this.newBlock.Text = "Generate New Block";
-            this.newBlock.UseVisualStyleBackColor = true;
-            this.newBlock.Click += new System.EventHandler(this.NewBlock_Click);
+            this.newBlockMultiThread.Location = new System.Drawing.Point(485, 194);
+            this.newBlockMultiThread.Margin = new System.Windows.Forms.Padding(2);
+            this.newBlockMultiThread.Name = "newBlockMultiThread";
+            this.newBlockMultiThread.Size = new System.Drawing.Size(197, 26);
+            this.newBlockMultiThread.TabIndex = 16;
+            this.newBlockMultiThread.Text = "Generate New Block (Multi Thread)";
+            this.newBlockMultiThread.UseVisualStyleBackColor = true;
+            this.newBlockMultiThread.Click += new System.EventHandler(this.newBlockMultiThread_Click);
             // 
             // printBlockchain
             // 
-            this.printBlockchain.Location = new System.Drawing.Point(862, 99);
+            this.printBlockchain.Location = new System.Drawing.Point(584, 224);
+            this.printBlockchain.Margin = new System.Windows.Forms.Padding(2);
             this.printBlockchain.Name = "printBlockchain";
-            this.printBlockchain.Size = new System.Drawing.Size(148, 39);
+            this.printBlockchain.Size = new System.Drawing.Size(98, 25);
             this.printBlockchain.TabIndex = 17;
             this.printBlockchain.Text = "Entire Chain";
             this.printBlockchain.UseVisualStyleBackColor = true;
@@ -215,9 +232,10 @@
             // 
             // readPendingTransactions
             // 
-            this.readPendingTransactions.Location = new System.Drawing.Point(713, 320);
+            this.readPendingTransactions.Location = new System.Drawing.Point(486, 421);
+            this.readPendingTransactions.Margin = new System.Windows.Forms.Padding(2);
             this.readPendingTransactions.Name = "readPendingTransactions";
-            this.readPendingTransactions.Size = new System.Drawing.Size(294, 39);
+            this.readPendingTransactions.Size = new System.Drawing.Size(196, 25);
             this.readPendingTransactions.TabIndex = 18;
             this.readPendingTransactions.Text = "Read Pending Transactions";
             this.readPendingTransactions.UseVisualStyleBackColor = true;
@@ -225,9 +243,10 @@
             // 
             // validate
             // 
-            this.validate.Location = new System.Drawing.Point(713, 424);
+            this.validate.Location = new System.Drawing.Point(486, 669);
+            this.validate.Margin = new System.Windows.Forms.Padding(2);
             this.validate.Name = "validate";
-            this.validate.Size = new System.Drawing.Size(294, 71);
+            this.validate.Size = new System.Drawing.Size(196, 46);
             this.validate.TabIndex = 19;
             this.validate.Text = "Full Blockchain Validation";
             this.validate.UseVisualStyleBackColor = true;
@@ -235,9 +254,10 @@
             // 
             // checkBalance
             // 
-            this.checkBalance.Location = new System.Drawing.Point(550, 458);
+            this.checkBalance.Location = new System.Drawing.Point(376, 692);
+            this.checkBalance.Margin = new System.Windows.Forms.Padding(2);
             this.checkBalance.Name = "checkBalance";
-            this.checkBalance.Size = new System.Drawing.Size(131, 37);
+            this.checkBalance.Size = new System.Drawing.Size(87, 24);
             this.checkBalance.TabIndex = 20;
             this.checkBalance.Text = "Check Balance";
             this.checkBalance.UseVisualStyleBackColor = true;
@@ -246,45 +266,62 @@
             // currentWalletLabel
             // 
             this.currentWalletLabel.AutoSize = true;
-            this.currentWalletLabel.Location = new System.Drawing.Point(40, 383);
+            this.currentWalletLabel.Location = new System.Drawing.Point(11, 645);
+            this.currentWalletLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.currentWalletLabel.Name = "currentWalletLabel";
-            this.currentWalletLabel.Size = new System.Drawing.Size(110, 20);
+            this.currentWalletLabel.Size = new System.Drawing.Size(74, 13);
             this.currentWalletLabel.TabIndex = 22;
             this.currentWalletLabel.Text = "Current Wallet";
             // 
             // transactionLabel
             // 
             this.transactionLabel.AutoSize = true;
-            this.transactionLabel.Location = new System.Drawing.Point(712, 170);
+            this.transactionLabel.Location = new System.Drawing.Point(483, 319);
+            this.transactionLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.transactionLabel.Name = "transactionLabel";
-            this.transactionLabel.Size = new System.Drawing.Size(100, 20);
+            this.transactionLabel.Size = new System.Drawing.Size(68, 13);
             this.transactionLabel.TabIndex = 23;
             this.transactionLabel.Text = "Transactions";
             // 
             // blocksLabel
             // 
             this.blocksLabel.AutoSize = true;
-            this.blocksLabel.Location = new System.Drawing.Point(715, 19);
+            this.blocksLabel.Location = new System.Drawing.Point(483, 149);
+            this.blocksLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.blocksLabel.Name = "blocksLabel";
-            this.blocksLabel.Size = new System.Drawing.Size(56, 20);
+            this.blocksLabel.Size = new System.Drawing.Size(39, 13);
             this.blocksLabel.TabIndex = 24;
             this.blocksLabel.Text = "Blocks";
             // 
             // validationLabel
             // 
             this.validationLabel.AutoSize = true;
-            this.validationLabel.Location = new System.Drawing.Point(715, 385);
+            this.validationLabel.Location = new System.Drawing.Point(489, 654);
+            this.validationLabel.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);
             this.validationLabel.Name = "validationLabel";
-            this.validationLabel.Size = new System.Drawing.Size(79, 20);
+            this.validationLabel.Size = new System.Drawing.Size(53, 13);
             this.validationLabel.TabIndex = 25;
             this.validationLabel.Text = "Validation";
             // 
+            // newBlockSingleThread
+            // 
+            this.newBlockSingleThread.Location = new System.Drawing.Point(485, 164);
+            this.newBlockSingleThread.Margin = new System.Windows.Forms.Padding(2);
+            this.newBlockSingleThread.Name = "newBlockSingleThread";
+            this.newBlockSingleThread.Size = new System.Drawing.Size(197, 26);
+            this.newBlockSingleThread.TabIndex = 26;
+            this.newBlockSingleThread.Text = "Generate New Block (Single Thread)";
+            this.newBlockSingleThread.UseVisualStyleBackColor = true;
+            this.newBlockSingleThread.Click += new System.EventHandler(this.newBlockSingleThread_Click);
+            // 
             // BlockchainApp
             // 
-            this.AutoScaleDimensions = new System.Drawing.SizeF(9F, 20F);
+            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.ActiveCaption;
-            this.ClientSize = new System.Drawing.Size(1022, 536);
+            this.ClientSize = new System.Drawing.Size(693, 726);
+            this.Controls.Add(this.createTransaction);
+            this.Controls.Add(this.newBlockSingleThread);
             this.Controls.Add(this.validationLabel);
             this.Controls.Add(this.blocksLabel);
             this.Controls.Add(this.transactionLabel);
@@ -293,14 +330,13 @@
             this.Controls.Add(this.validate);
             this.Controls.Add(this.readPendingTransactions);
             this.Controls.Add(this.printBlockchain);
-            this.Controls.Add(this.newBlock);
+            this.Controls.Add(this.newBlockMultiThread);
             this.Controls.Add(this.reciever);
             this.Controls.Add(this.recieverKeyLabel);
             this.Controls.Add(this.fee);
             this.Controls.Add(this.amount);
             this.Controls.Add(this.feeLabel);
             this.Controls.Add(this.amountLabel);
-            this.Controls.Add(this.createTransaction);
             this.Controls.Add(this.validateKeys);
             this.Controls.Add(this.privateKey);
             this.Controls.Add(this.publicKey);
@@ -311,7 +347,6 @@
             this.Controls.Add(this.printBlock);
             this.Controls.Add(this.output);
             this.ForeColor = System.Drawing.Color.Black;
-            this.Margin = new System.Windows.Forms.Padding(4, 5, 4, 5);
             this.Name = "BlockchainApp";
             this.Text = "Blockchain App";
             this.ResumeLayout(false);
@@ -337,7 +372,7 @@
         private System.Windows.Forms.Label amountLabel;
         private System.Windows.Forms.TextBox reciever;
         private System.Windows.Forms.Label recieverKeyLabel;
-        private System.Windows.Forms.Button newBlock;
+        private System.Windows.Forms.Button newBlockMultiThread;
         private System.Windows.Forms.Button printBlockchain;
         private System.Windows.Forms.Button readPendingTransactions;
         private System.Windows.Forms.Button validate;
@@ -346,6 +381,7 @@
         private System.Windows.Forms.Label transactionLabel;
         private System.Windows.Forms.Label blocksLabel;
         private System.Windows.Forms.Label validationLabel;
+        private System.Windows.Forms.Button newBlockSingleThread;
     }
 }
 
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
index 719e119..bc81a49 100644
--- a/BlockchainAssignment/BlockchainApp.cs
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -84,27 +84,37 @@ namespace BlockchainAssignment
             UpdateText(transaction.ToString());
         }
 
-        /* BLOCK MANAGEMENT */
-        // Conduct Proof-of-work in order to mine transactions from the pool and submit a new block to the Blockchain
-        private void NewBlock_Click(object sender, EventArgs e)
+        private void newBlock(bool multithreaded)
         {
             // Retrieve pending transactions to be added to the newly generated Block
             List<Transaction> transactions = blockchain.GetPendingTransactions();
 
             // Create and append the new block - requires a reference to the previous block, a set of transactions and the miners public address (For the reward to be issued)
-            Block newBlock = new Block(blockchain.GetLastBlock(), transactions, publicKey.Text);
+            Block newBlock = new Block(blockchain.GetLastBlock(), transactions, publicKey.Text, multithreaded);
             blockchain.blocks.Add(newBlock);
 
             UpdateText(blockchain.ToString());
         }
 
+        /* BLOCK MANAGEMENT */
+        // Conduct Proof-of-work in order to mine transactions from the pool and submit a new block to the Blockchain
+        private void newBlockMultiThread_Click(object sender, EventArgs e)
+        {
+            newBlock(multithreaded: true);
+        }
+
+        private void newBlockSingleThread_Click(object sender, EventArgs e)
+        {
+            newBlock(multithreaded: false);
+        }
+
 
         /* BLOCKCHAIN VALIDATION */
         // Validate the integrity of the state of the Blockchain
         private void Validate_Click(object sender, EventArgs e)
         {
             // CASE: Genesis Block - Check only hash as no transactions are currently present
-            if(blockchain.blocks.Count == 1)
+            if (blockchain.blocks.Count == 1)
             {
                 if (!Blockchain.ValidateHash(blockchain.blocks[0])) // Recompute Hash to check validity
                     UpdateText("Blockchain is invalid");
@@ -113,9 +123,9 @@ namespace BlockchainAssignment
                 return;
             }
 
-            for (int i=1; i<blockchain.blocks.Count-1; i++)
+            for (int i = 1; i < blockchain.blocks.Count - 1; i++)
             {
-                if(
+                if (
                     blockchain.blocks[i].prevHash != blockchain.blocks[i - 1].hash || // Check hash "chain"
                     !Blockchain.ValidateHash(blockchain.blocks[i]) ||  // Check each blocks hash
                     !Blockchain.ValidateMerkleRoot(blockchain.blocks[i]) // Check transaction integrity using Merkle Root
diff --git a/BlockchainAssignment/BlockchainAssignment.sln b/BlockchainAssignment/BlockchainAssignment.sln
new file mode 100644
index 0000000..70bed0c
--- /dev/null
+++ b/BlockchainAssignment/BlockchainAssignment.sln
@@ -0,0 +1,24 @@
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 17
+VisualStudioVersion = 17.5.2.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BlockchainAssignment", "BlockchainAssignment.csproj", "{4624A4F3-BE6D-6975-C6E3-5FB61AD8AD87}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{4624A4F3-BE6D-6975-C6E3-5FB61AD8AD87}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{4624A4F3-BE6D-6975-C6E3-5FB61AD8AD87}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{4624A4F3-BE6D-6975-C6E3-5FB61AD8AD87}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{4624A4F3-BE6D-6975-C6E3-5FB61AD8AD87}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {0124B5F0-1C52-49AE-846A-1D26485C0082}
+	EndGlobalSection
+EndGlobal
diff --git a/BlockchainAssignment/Transaction.cs b/BlockchainAssignment/Transaction.cs
index cf92a2d..69e42d5 100644
--- a/BlockchainAssignment/Transaction.cs
+++ b/BlockchainAssignment/Transaction.cs
@@ -52,7 +52,7 @@ namespace BlockchainAssignment
         // Represent a transaction as a string for output to UI
         public override string ToString()
         {
-            return "  [TRANSACTION START]" 
+            return "\n  [TRANSACTION START]" 
                 + "\n  Timestamp: " + timestamp
                 + "\n  -- Verification --"
                 + "\n  Hash: " + hash
@@ -63,7 +63,7 @@ namespace BlockchainAssignment
                 + "\n  -- Participants --"
                 + "\n  Sender: " + senderAddress
                 + "\n  Reciever: " + recipientAddress 
-                + "\n  [TRANSACTION END]";
+                + "\n  [TRANSACTION END]\n";
         }
     }
 }

commit bb40b6e1effaa2bc426f823093e56404698c7c01
Author: “nk002734” <“nk002734@student.reading.ac.uk”>
Date:   Tue Mar 11 12:07:58 2025 +0000

    clean up word file

diff --git a/Blockchain Build Cookbook (2).pptx b/Blockchain Build Cookbook.pptx
similarity index 100%
rename from Blockchain Build Cookbook (2).pptx
rename to Blockchain Build Cookbook.pptx
diff --git a/Luke Wilson CS3BC Coursework.docx b/Luke Wilson CS3BC Coursework.docx
index 7922048..3011b4a 100644
--- a/Luke Wilson CS3BC Coursework.docx	
+++ b/Luke Wilson CS3BC Coursework.docx	
@@ -1,4 +1,9 @@
-
+Module Code: CS3BC
+Assignment report Title: Blockchain Coursework Assignment
+Student Number: 30002734
+Date (when the work was completed): 
+Actual hrs spent for the assignment:
+Which Artificial Intelligence tools used (if applicable):
 
 Part 1:
 

commit 8e1f87a6b0f13d0fa6df8ab07b520d2a6fbca882
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Sat Mar 1 23:23:43 2025 +0000

    part 5

diff --git a/BlockchainAssignment/Block.cs b/BlockchainAssignment/Block.cs
index fe8761c..d0ee88b 100644
--- a/BlockchainAssignment/Block.cs
+++ b/BlockchainAssignment/Block.cs
@@ -3,134 +3,151 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Security.Cryptography;
 using System.Text;
-using System.Threading.Tasks;
 
 namespace BlockchainAssignment
 {
     class Block
     {
-        int index;
-        String hash, prevHash, merkleRoot;
-        DateTime timestamp;
+        /* Block Variables */
+        private DateTime timestamp; // Time of creation
 
-        List<Transaction> transactionList;
+        private int index, // Position of the block in the sequence of blocks
+            difficulty = 4; // An arbitrary number of 0's to proceed a hash value
 
-        public long nonce = 0;
-        public int difficulty = 4;
+        public String prevHash, // A reference pointer to the previous block
+            hash, // The current blocks "identity"
+            merkleRoot,  // The merkle root of all transactions in the block
+            minerAddress; // Public Key (Wallet Address) of the Miner
 
-        public double reward = 1.0;
-        public String minerAddress = "";
+        public List<Transaction> transactionList; // List of transactions in this block
 
-        /* Genesis Block Constructor */
+        // Proof-of-work
+        public long nonce; // Number used once for Proof-of-Work and mining
+
+        // Rewards
+        public double reward; // Simple fixed reward established by "Coinbase"
+
+        /* Genesis block constructor */
         public Block()
         {
-            index = 0;
             timestamp = DateTime.Now;
-            prevHash = String.Empty;
+            index = 0;
             transactionList = new List<Transaction>();
             hash = Mine();
         }
 
-        public Block(int index, String hash)
-        {
-            this.index = index + 1;
-            timestamp = DateTime.Now;
-            prevHash = hash;
-            this.hash = Mine();
-        }
-
-        public Block(Block block, List<Transaction> transactions, String minerAddress)
+        /* New Block constructor */
+        public Block(Block lastBlock, List<Transaction> transactions, String minerAddress)
         {
-            index = block.index + 1;
             timestamp = DateTime.Now;
-            prevHash = block.hash;
 
-            this.minerAddress = minerAddress;
-            transactions.Add(CreateRewardTransaction(transactions));
+            index = lastBlock.index + 1;
+            prevHash = lastBlock.hash;
 
-            transactionList = transactions;
-            merkleRoot = MerkleRoot(transactions);
+            this.minerAddress = minerAddress; // The wallet to be credited the reward for the mining effort
+            reward = 1.0; // Assign a simple fixed value reward
+            transactions.Add(createRewardTransaction(transactions)); // Create and append the reward transaction
+            transactionList = new List<Transaction>(transactions); // Assign provided transactions to the block
 
-            hash = Mine();
+            merkleRoot = MerkleRoot(transactionList); // Calculate the merkle root of the blocks transactions
+            hash = Mine(); // Conduct PoW to create a hash which meets the given difficulty requirement
         }
 
+        /* Hashes the entire Block object */
         public String CreateHash()
         {
             String hash = String.Empty;
-
             SHA256 hasher = SHA256Managed.Create();
-            String input = index.ToString() + hash + prevHash + timestamp.ToString() + nonce;
 
+            /* Concatenate all of the blocks properties including nonce as to generate a new hash on each call */
+            String input = timestamp.ToString() + index + prevHash + nonce + merkleRoot;
+
+            /* Apply the hash function to the block as represented by the string "input" */
             Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
 
+            /* Reformat to a string */
             foreach (byte x in hashByte)
                 hash += String.Format("{0:x2}", x);
 
             return hash;
         }
 
+        // Create a Hash which satisfies the difficulty level required for PoW
         public String Mine()
         {
-            nonce = 0;
-            String hash = CreateHash();
+            nonce = 0; // Initalise the nonce
+            String hash = CreateHash(); // Hash the block
 
-            String re = new string('0', difficulty);
+            String re = new string('0', difficulty); // A string for analysing the PoW requirement
 
-            while (!hash.StartsWith(re))
+            while (!hash.StartsWith(re)) // Check the resultant hash against the "re" string
             {
-                nonce++;
-                hash = CreateHash();
+                nonce++; // Increment the nonce should the difficulty level not be satisfied
+                hash = CreateHash(); // Rehash with the new nonce as to generate a different hash
             }
-            return hash;
+
+            return hash; // Return the hash meeting the difficulty requirement
         }
 
+        // Merkle Root Algorithm - Encodes transactions within a block into a single hash
         public static String MerkleRoot(List<Transaction> transactionList)
         {
-            List<String> hashes = transactionList.Select(t => t.hash).ToList();
-            if (hashes.Count == 0)
+            List<String> hashes = transactionList.Select(t => t.hash).ToList(); // Get a list of transaction hashes for "combining"
+
+            // Handle Blocks with...
+            if (hashes.Count == 0) // No transactions
             {
                 return String.Empty;
             }
-            if (hashes.Count == 1)
+            if (hashes.Count == 1) // One transaction - hash with "self"
             {
-                return hashes[0];
+                return HashCode.HashTools.combineHash(hashes[0], hashes[0]);
             }
-            while (hashes.Count != 1)
+            while (hashes.Count != 1) // Multiple transactions - Repeat until tree has been traversed
             {
-                List<String> merkleLeaves = new List<String>();
-                for (int i = 0; i < hashes.Count; i += 2)
+                List<String> merkleLeaves = new List<String>(); // Keep track of current "level" of the tree
+
+                for (int i = 0; i < hashes.Count; i += 2) // Step over neighbouring pair combining each
                 {
                     if (i == hashes.Count - 1)
                     {
-                        merkleLeaves.Add(HashCode.HashTools.CombineHash(hashes[i], hashes[i]));
+                        merkleLeaves.Add(HashCode.HashTools.combineHash(hashes[i], hashes[i])); // Handle an odd number of leaves
                     }
                     else
                     {
-                        merkleLeaves.Add(HashCode.HashTools.CombineHash(hashes[i], hashes[i + 1]));
+                        merkleLeaves.Add(HashCode.HashTools.combineHash(hashes[i], hashes[i + 1])); // Hash neighbours leaves
                     }
                 }
-                hashes = merkleLeaves;
+                hashes = merkleLeaves; // Update the working "layer"
             }
-
-            return hashes[0];
+            return hashes[0]; // Return the root node
         }
 
-        public Transaction CreateRewardTransaction(List<Transaction> transactions)
+        // Create reward for incentivising the mining of block
+        public Transaction createRewardTransaction(List<Transaction> transactions)
         {
-            double fees = transactions.Aggregate(0.0, (acc, t) => acc + t.fee);
-            return new Transaction("Mine Rewards", minerAddress, (reward + fees), 0, "");
+            double fees = transactions.Aggregate(0.0, (acc, t) => acc + t.fee); // Sum all transaction fees
+            return new Transaction("Mine Rewards", minerAddress, (reward + fees), 0, ""); // Issue reward as a transaction in the new block
         }
 
+        /* Concatenate all properties to output to the UI */
         public override string ToString()
         {
-            return "Index: " + index.ToString() +
-                "\nTimestamp: " + timestamp.ToString() +
-                "\nHash: " + hash +
-                "\nPrevious Hash: " + prevHash +
-                "\nTransactions: " + String.Join("\n", transactionList) +
-                "\nNonce: " + nonce.ToString() +
-                "\nMerkle Root: " + merkleRoot +
-                "\n";
+            return "[BLOCK START]"
+                + "\nIndex: " + index
+                + "\tTimestamp: " + timestamp
+                + "\nPrevious Hash: " + prevHash
+                + "\n-- PoW --"
+                + "\nDifficulty Level: " + difficulty
+                + "\nNonce: " + nonce
+                + "\nHash: " + hash
+                + "\n-- Rewards --"
+                + "\nReward: " + reward
+                + "\nMiners Address: " + minerAddress
+                + "\n-- " + transactionList.Count + " Transactions --"
+                + "\nMerkle Root: " + merkleRoot
+                + "\n" + String.Join("\n", transactionList)
+                + "\n[BLOCK END]";
         }
     }
 }
diff --git a/BlockchainAssignment/Blockchain.cs b/BlockchainAssignment/Blockchain.cs
index 3f24488..fc16914 100644
--- a/BlockchainAssignment/Blockchain.cs
+++ b/BlockchainAssignment/Blockchain.cs
@@ -8,42 +8,96 @@ namespace BlockchainAssignment
 {
     class Blockchain
     {
-        public List<Block> Blocks;
+        // List of block objects forming the blockchain
+        public List<Block> blocks;
 
-        public int transactionsPerBlock = 5;
-        public List<Transaction> transactionPool;
+        // Maximum number of transactions per block
+        private int transactionsPerBlock = 5;
 
+        // List of pending transactions to be mined
+        public List<Transaction> transactionPool = new List<Transaction>();
+
+        // Default Constructor - initialises the list of blocks and generates the genesis block
         public Blockchain()
         {
-            Blocks = new List<Block>() {
-                new Block()
+            blocks = new List<Block>()
+            {
+                new Block() // Create and append the Genesis Block
             };
-            transactionPool = new List<Transaction>();
         }
 
-        public String getBlock(int index)
+        // Prints the block at the specified index to the UI
+        public String GetBlockAsString(int index)
         {
-            if (index >= 0 && index < Blocks.Count)
-                return Blocks[index].ToString();
-            return "Block does not Exist";
+            // Check if referenced block exists
+            if (index >= 0 && index < blocks.Count)
+                return blocks[index].ToString(); // Return block as a string
+            else
+                return "No such block exists";
         }
 
-        public Block getLastBlock()
+        // Retrieves the most recently appended block in the blockchain
+        public Block GetLastBlock()
         {
-            return Blocks[Blocks.Count - 1];
+            return blocks[blocks.Count - 1];
         }
 
+        // Retrieve pending transactions and remove from pool
         public List<Transaction> GetPendingTransactions()
         {
+            // Determine the number of transactions to retrieve dependent on the number of pending transactions and the limit specified
             int n = Math.Min(transactionsPerBlock, transactionPool.Count);
+
+            // "Pull" transactions from the transaction list (modifying the original list)
             List<Transaction> transactions = transactionPool.GetRange(0, n);
             transactionPool.RemoveRange(0, n);
+
+            // Return the extracted transactions
             return transactions;
         }
 
+        // Check validity of a blocks hash by recomputing the hash and comparing with the mined value
+        public static bool ValidateHash(Block b)
+        {
+            String rehash = b.CreateHash();
+            return rehash.Equals(b.hash);
+        }
+
+        // Check validity of the merkle root by recalculating the root and comparing with the mined value
+        public static bool ValidateMerkleRoot(Block b)
+        {
+            String reMerkle = Block.MerkleRoot(b.transactionList);
+            return reMerkle.Equals(b.merkleRoot);
+        }
+
+        // Check the balance associated with a wallet based on the public key
+        public double GetBalance(String address)
+        {
+            // Accumulator value
+            double balance = 0;
+
+            // Loop through all approved transactions in order to assess account balance
+            foreach(Block b in blocks)
+            {
+                foreach(Transaction t in b.transactionList)
+                {
+                    if (t.recipientAddress.Equals(address))
+                    {
+                        balance += t.amount; // Credit funds recieved
+                    }
+                    if (t.senderAddress.Equals(address))
+                    {
+                        balance -= (t.amount + t.fee); // Debit payments placed
+                    }
+                }
+            }
+            return balance;
+        }
+
+        // Output all blocks of the blockchain as a string
         public override string ToString()
         {
-            return String.Join("\n", Blocks);
+            return String.Join("\n", blocks);
         }
     }
 }
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
index db5db9b..7465c58 100644
--- a/BlockchainAssignment/BlockchainApp.Designer.cs
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -28,223 +28,292 @@
         /// </summary>
         private void InitializeComponent()
         {
-            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
-            this.button1 = new System.Windows.Forms.Button();
-            this.textBox1 = new System.Windows.Forms.TextBox();
-            this.button2 = new System.Windows.Forms.Button();
+            this.output = new System.Windows.Forms.RichTextBox();
+            this.printBlock = new System.Windows.Forms.Button();
+            this.blockNo = new System.Windows.Forms.TextBox();
+            this.generateWallet = new System.Windows.Forms.Button();
+            this.publicKeyLabel = new System.Windows.Forms.Label();
+            this.privateKeyLabel = new System.Windows.Forms.Label();
             this.publicKey = new System.Windows.Forms.TextBox();
-            this.privKey = new System.Windows.Forms.TextBox();
-            this.label1 = new System.Windows.Forms.Label();
-            this.label2 = new System.Windows.Forms.Label();
-            this.button3 = new System.Windows.Forms.Button();
-            this.button4 = new System.Windows.Forms.Button();
-            this.amount = new System.Windows.Forms.TextBox();
+            this.privateKey = new System.Windows.Forms.TextBox();
+            this.validateKeys = new System.Windows.Forms.Button();
+            this.createTransaction = new System.Windows.Forms.Button();
             this.fee = new System.Windows.Forms.TextBox();
-            this.receiver = new System.Windows.Forms.TextBox();
-            this.label3 = new System.Windows.Forms.Label();
-            this.label4 = new System.Windows.Forms.Label();
-            this.label5 = new System.Windows.Forms.Label();
-            this.button5 = new System.Windows.Forms.Button();
-            this.button6 = new System.Windows.Forms.Button();
-            this.button7 = new System.Windows.Forms.Button();
+            this.amount = new System.Windows.Forms.TextBox();
+            this.feeLabel = new System.Windows.Forms.Label();
+            this.amountLabel = new System.Windows.Forms.Label();
+            this.reciever = new System.Windows.Forms.TextBox();
+            this.recieverKeyLabel = new System.Windows.Forms.Label();
+            this.newBlock = new System.Windows.Forms.Button();
+            this.printBlockchain = new System.Windows.Forms.Button();
+            this.readPendingTransactions = new System.Windows.Forms.Button();
+            this.validate = new System.Windows.Forms.Button();
+            this.checkBalance = new System.Windows.Forms.Button();
+            this.currentWalletLabel = new System.Windows.Forms.Label();
+            this.transactionLabel = new System.Windows.Forms.Label();
+            this.blocksLabel = new System.Windows.Forms.Label();
+            this.validationLabel = new System.Windows.Forms.Label();
             this.SuspendLayout();
             // 
-            // richTextBox1
+            // output
+            // 
+            this.output.BackColor = System.Drawing.SystemColors.InfoText;
+            this.output.ForeColor = System.Drawing.SystemColors.ButtonHighlight;
+            this.output.Location = new System.Drawing.Point(18, 18);
+            this.output.Margin = new System.Windows.Forms.Padding(4, 5, 4, 5);
+            this.output.Name = "output";
+            this.output.Size = new System.Drawing.Size(688, 341);
+            this.output.TabIndex = 0;
+            this.output.Text = "";
+            // 
+            // printBlock
+            // 
+            this.printBlock.Location = new System.Drawing.Point(716, 99);
+            this.printBlock.Name = "printBlock";
+            this.printBlock.Size = new System.Drawing.Size(99, 39);
+            this.printBlock.TabIndex = 1;
+            this.printBlock.Text = "Block #";
+            this.printBlock.UseVisualStyleBackColor = true;
+            this.printBlock.Click += new System.EventHandler(this.PrintBlock_Click);
+            // 
+            // blockNo
+            // 
+            this.blockNo.Location = new System.Drawing.Point(821, 105);
+            this.blockNo.Name = "blockNo";
+            this.blockNo.Size = new System.Drawing.Size(34, 26);
+            this.blockNo.TabIndex = 2;
+            // 
+            // generateWallet
+            // 
+            this.generateWallet.Location = new System.Drawing.Point(38, 411);
+            this.generateWallet.Name = "generateWallet";
+            this.generateWallet.Size = new System.Drawing.Size(119, 84);
+            this.generateWallet.TabIndex = 3;
+            this.generateWallet.Text = "Generate New Wallet";
+            this.generateWallet.UseVisualStyleBackColor = true;
+            this.generateWallet.Click += new System.EventHandler(this.GenerateWallet_Click);
+            // 
+            // publicKeyLabel
+            // 
+            this.publicKeyLabel.AutoSize = true;
+            this.publicKeyLabel.Location = new System.Drawing.Point(169, 430);
+            this.publicKeyLabel.Name = "publicKeyLabel";
+            this.publicKeyLabel.Size = new System.Drawing.Size(81, 20);
+            this.publicKeyLabel.TabIndex = 4;
+            this.publicKeyLabel.Text = "Public Key";
+            // 
+            // privateKeyLabel
+            // 
+            this.privateKeyLabel.AutoSize = true;
+            this.privateKeyLabel.Location = new System.Drawing.Point(163, 462);
+            this.privateKeyLabel.Name = "privateKeyLabel";
+            this.privateKeyLabel.Size = new System.Drawing.Size(87, 20);
+            this.privateKeyLabel.TabIndex = 5;
+            this.privateKeyLabel.Text = "Private Key";
             // 
-            this.richTextBox1.BackColor = System.Drawing.SystemColors.InfoText;
-            this.richTextBox1.ForeColor = System.Drawing.SystemColors.ButtonHighlight;
-            this.richTextBox1.Location = new System.Drawing.Point(12, 12);
-            this.richTextBox1.Name = "richTextBox1";
-            this.richTextBox1.Size = new System.Drawing.Size(657, 314);
-            this.richTextBox1.TabIndex = 0;
-            this.richTextBox1.Text = "";
+            // publicKey
             // 
-            // button1
+            this.publicKey.Location = new System.Drawing.Point(253, 424);
+            this.publicKey.Name = "publicKey";
+            this.publicKey.Size = new System.Drawing.Size(282, 26);
+            this.publicKey.TabIndex = 6;
             // 
-            this.button1.Location = new System.Drawing.Point(12, 333);
-            this.button1.Name = "button1";
-            this.button1.Size = new System.Drawing.Size(75, 23);
-            this.button1.TabIndex = 1;
-            this.button1.Text = "Print";
-            this.button1.UseVisualStyleBackColor = true;
-            this.button1.Click += new System.EventHandler(this.button1_Click);
+            // privateKey
             // 
-            // textBox1
+            this.privateKey.Location = new System.Drawing.Point(256, 456);
+            this.privateKey.Name = "privateKey";
+            this.privateKey.Size = new System.Drawing.Size(279, 26);
+            this.privateKey.TabIndex = 7;
             // 
-            this.textBox1.Location = new System.Drawing.Point(94, 335);
-            this.textBox1.Name = "textBox1";
-            this.textBox1.Size = new System.Drawing.Size(100, 20);
-            this.textBox1.TabIndex = 2;
+            // validateKeys
             // 
-            // button2
+            this.validateKeys.Location = new System.Drawing.Point(550, 421);
+            this.validateKeys.Name = "validateKeys";
+            this.validateKeys.Size = new System.Drawing.Size(131, 34);
+            this.validateKeys.TabIndex = 8;
+            this.validateKeys.Text = "Validate Keys";
+            this.validateKeys.UseVisualStyleBackColor = true;
+            this.validateKeys.Click += new System.EventHandler(this.ValidateKeys_Click);
             // 
-            this.button2.Location = new System.Drawing.Point(594, 335);
-            this.button2.Name = "button2";
-            this.button2.Size = new System.Drawing.Size(75, 53);
-            this.button2.TabIndex = 3;
-            this.button2.Text = "Generate Keys";
-            this.button2.UseVisualStyleBackColor = true;
-            this.button2.Click += new System.EventHandler(this.button2_Click);
+            // createTransaction
             // 
-            // publicKey
+            this.createTransaction.Location = new System.Drawing.Point(714, 269);
+            this.createTransaction.Name = "createTransaction";
+            this.createTransaction.Size = new System.Drawing.Size(293, 40);
+            this.createTransaction.TabIndex = 9;
+            this.createTransaction.Text = "Create Transaction";
+            this.createTransaction.UseVisualStyleBackColor = true;
+            this.createTransaction.Click += new System.EventHandler(this.CreateTransaction_Click);
             // 
-            this.publicKey.Location = new System.Drawing.Point(409, 335);
-            this.publicKey.Name = "publicKey";
-            this.publicKey.Size = new System.Drawing.Size(179, 20);
-            this.publicKey.TabIndex = 4;
-            // 
-            // privKey
-            // 
-            this.privKey.Location = new System.Drawing.Point(409, 365);
-            this.privKey.Name = "privKey";
-            this.privKey.Size = new System.Drawing.Size(179, 20);
-            this.privKey.TabIndex = 5;
-            // 
-            // label1
-            // 
-            this.label1.AutoSize = true;
-            this.label1.Location = new System.Drawing.Point(324, 338);
-            this.label1.Name = "label1";
-            this.label1.Size = new System.Drawing.Size(57, 13);
-            this.label1.TabIndex = 6;
-            this.label1.Text = "Public Key";
-            // 
-            // label2
-            // 
-            this.label2.AutoSize = true;
-            this.label2.Location = new System.Drawing.Point(324, 368);
-            this.label2.Name = "label2";
-            this.label2.Size = new System.Drawing.Size(61, 13);
-            this.label2.TabIndex = 7;
-            this.label2.Text = "Private Key";
-            // 
-            // button3
-            // 
-            this.button3.Location = new System.Drawing.Point(594, 395);
-            this.button3.Name = "button3";
-            this.button3.Size = new System.Drawing.Size(75, 47);
-            this.button3.TabIndex = 8;
-            this.button3.Text = "Validate Keys";
-            this.button3.UseVisualStyleBackColor = true;
-            this.button3.Click += new System.EventHandler(this.button3_Click);
-            // 
-            // button4
-            // 
-            this.button4.Location = new System.Drawing.Point(12, 423);
-            this.button4.Name = "button4";
-            this.button4.Size = new System.Drawing.Size(75, 46);
-            this.button4.TabIndex = 9;
-            this.button4.Text = "Create Transaction";
-            this.button4.UseVisualStyleBackColor = true;
-            this.button4.Click += new System.EventHandler(this.button4_Click);
+            // fee
+            // 
+            this.fee.Location = new System.Drawing.Point(956, 206);
+            this.fee.Name = "fee";
+            this.fee.Size = new System.Drawing.Size(52, 26);
+            this.fee.TabIndex = 13;
             // 
             // amount
             // 
-            this.amount.Location = new System.Drawing.Point(146, 423);
+            this.amount.Location = new System.Drawing.Point(831, 206);
             this.amount.Name = "amount";
-            this.amount.Size = new System.Drawing.Size(48, 20);
-            this.amount.TabIndex = 10;
-            // 
-            // fee
-            // 
-            this.fee.Location = new System.Drawing.Point(146, 450);
-            this.fee.Name = "fee";
-            this.fee.Size = new System.Drawing.Size(48, 20);
-            this.fee.TabIndex = 11;
-            // 
-            // receiver
-            // 
-            this.receiver.Location = new System.Drawing.Point(288, 450);
-            this.receiver.Name = "receiver";
-            this.receiver.Size = new System.Drawing.Size(173, 20);
-            this.receiver.TabIndex = 12;
-            // 
-            // label3
-            // 
-            this.label3.AutoSize = true;
-            this.label3.Location = new System.Drawing.Point(94, 429);
-            this.label3.Name = "label3";
-            this.label3.Size = new System.Drawing.Size(43, 13);
-            this.label3.TabIndex = 13;
-            this.label3.Text = "Amount";
-            // 
-            // label4
-            // 
-            this.label4.AutoSize = true;
-            this.label4.Location = new System.Drawing.Point(94, 453);
-            this.label4.Name = "label4";
-            this.label4.Size = new System.Drawing.Size(25, 13);
-            this.label4.TabIndex = 14;
-            this.label4.Text = "Fee";
-            // 
-            // label5
-            // 
-            this.label5.AutoSize = true;
-            this.label5.Location = new System.Drawing.Point(211, 453);
-            this.label5.Name = "label5";
-            this.label5.Size = new System.Drawing.Size(71, 13);
-            this.label5.TabIndex = 15;
-            this.label5.Text = "Receiver Key";
-            // 
-            // button5
-            // 
-            this.button5.Location = new System.Drawing.Point(12, 374);
-            this.button5.Name = "button5";
-            this.button5.Size = new System.Drawing.Size(75, 43);
-            this.button5.TabIndex = 16;
-            this.button5.Text = "Generate New Block";
-            this.button5.UseVisualStyleBackColor = true;
-            this.button5.Click += new System.EventHandler(this.button5_Click);
-            // 
-            // button6
-            // 
-            this.button6.Location = new System.Drawing.Point(201, 333);
-            this.button6.Name = "button6";
-            this.button6.Size = new System.Drawing.Size(75, 23);
-            this.button6.TabIndex = 17;
-            this.button6.Text = "Print All";
-            this.button6.UseVisualStyleBackColor = true;
-            this.button6.Click += new System.EventHandler(this.button6_Click);
-            // 
-            // button7
-            // 
-            this.button7.Location = new System.Drawing.Point(201, 362);
-            this.button7.Name = "button7";
-            this.button7.Size = new System.Drawing.Size(75, 54);
-            this.button7.TabIndex = 18;
-            this.button7.Text = "Print Pending Transactions";
-            this.button7.UseVisualStyleBackColor = true;
-            this.button7.Click += new System.EventHandler(this.button7_Click);
+            this.amount.Size = new System.Drawing.Size(52, 26);
+            this.amount.TabIndex = 12;
+            // 
+            // feeLabel
+            // 
+            this.feeLabel.AutoSize = true;
+            this.feeLabel.Location = new System.Drawing.Point(913, 209);
+            this.feeLabel.Name = "feeLabel";
+            this.feeLabel.Size = new System.Drawing.Size(37, 20);
+            this.feeLabel.TabIndex = 11;
+            this.feeLabel.Text = "Fee";
+            // 
+            // amountLabel
+            // 
+            this.amountLabel.AutoSize = true;
+            this.amountLabel.Location = new System.Drawing.Point(760, 209);
+            this.amountLabel.Name = "amountLabel";
+            this.amountLabel.Size = new System.Drawing.Size(65, 20);
+            this.amountLabel.TabIndex = 10;
+            this.amountLabel.Text = "Amount";
+            // 
+            // reciever
+            // 
+            this.reciever.Location = new System.Drawing.Point(831, 237);
+            this.reciever.Name = "reciever";
+            this.reciever.Size = new System.Drawing.Size(177, 26);
+            this.reciever.TabIndex = 15;
+            // 
+            // recieverKeyLabel
+            // 
+            this.recieverKeyLabel.AutoSize = true;
+            this.recieverKeyLabel.Location = new System.Drawing.Point(724, 240);
+            this.recieverKeyLabel.Name = "recieverKeyLabel";
+            this.recieverKeyLabel.Size = new System.Drawing.Size(101, 20);
+            this.recieverKeyLabel.TabIndex = 14;
+            this.recieverKeyLabel.Text = "Reciever Key";
+            // 
+            // newBlock
+            // 
+            this.newBlock.Location = new System.Drawing.Point(717, 51);
+            this.newBlock.Name = "newBlock";
+            this.newBlock.Size = new System.Drawing.Size(294, 40);
+            this.newBlock.TabIndex = 16;
+            this.newBlock.Text = "Generate New Block";
+            this.newBlock.UseVisualStyleBackColor = true;
+            this.newBlock.Click += new System.EventHandler(this.NewBlock_Click);
+            // 
+            // printBlockchain
+            // 
+            this.printBlockchain.Location = new System.Drawing.Point(862, 99);
+            this.printBlockchain.Name = "printBlockchain";
+            this.printBlockchain.Size = new System.Drawing.Size(148, 39);
+            this.printBlockchain.TabIndex = 17;
+            this.printBlockchain.Text = "Entire Chain";
+            this.printBlockchain.UseVisualStyleBackColor = true;
+            this.printBlockchain.Click += new System.EventHandler(this.ReadAll_Click);
+            // 
+            // readPendingTransactions
+            // 
+            this.readPendingTransactions.Location = new System.Drawing.Point(713, 320);
+            this.readPendingTransactions.Name = "readPendingTransactions";
+            this.readPendingTransactions.Size = new System.Drawing.Size(294, 39);
+            this.readPendingTransactions.TabIndex = 18;
+            this.readPendingTransactions.Text = "Read Pending Transactions";
+            this.readPendingTransactions.UseVisualStyleBackColor = true;
+            this.readPendingTransactions.Click += new System.EventHandler(this.PrintPendingTransactions_Click);
+            // 
+            // validate
+            // 
+            this.validate.Location = new System.Drawing.Point(713, 424);
+            this.validate.Name = "validate";
+            this.validate.Size = new System.Drawing.Size(294, 71);
+            this.validate.TabIndex = 19;
+            this.validate.Text = "Full Blockchain Validation";
+            this.validate.UseVisualStyleBackColor = true;
+            this.validate.Click += new System.EventHandler(this.Validate_Click);
+            // 
+            // checkBalance
+            // 
+            this.checkBalance.Location = new System.Drawing.Point(550, 458);
+            this.checkBalance.Name = "checkBalance";
+            this.checkBalance.Size = new System.Drawing.Size(131, 37);
+            this.checkBalance.TabIndex = 20;
+            this.checkBalance.Text = "Check Balance";
+            this.checkBalance.UseVisualStyleBackColor = true;
+            this.checkBalance.Click += new System.EventHandler(this.CheckBalance_Click);
+            // 
+            // currentWalletLabel
+            // 
+            this.currentWalletLabel.AutoSize = true;
+            this.currentWalletLabel.Location = new System.Drawing.Point(40, 383);
+            this.currentWalletLabel.Name = "currentWalletLabel";
+            this.currentWalletLabel.Size = new System.Drawing.Size(110, 20);
+            this.currentWalletLabel.TabIndex = 22;
+            this.currentWalletLabel.Text = "Current Wallet";
+            // 
+            // transactionLabel
+            // 
+            this.transactionLabel.AutoSize = true;
+            this.transactionLabel.Location = new System.Drawing.Point(712, 170);
+            this.transactionLabel.Name = "transactionLabel";
+            this.transactionLabel.Size = new System.Drawing.Size(100, 20);
+            this.transactionLabel.TabIndex = 23;
+            this.transactionLabel.Text = "Transactions";
+            // 
+            // blocksLabel
+            // 
+            this.blocksLabel.AutoSize = true;
+            this.blocksLabel.Location = new System.Drawing.Point(715, 19);
+            this.blocksLabel.Name = "blocksLabel";
+            this.blocksLabel.Size = new System.Drawing.Size(56, 20);
+            this.blocksLabel.TabIndex = 24;
+            this.blocksLabel.Text = "Blocks";
+            // 
+            // validationLabel
+            // 
+            this.validationLabel.AutoSize = true;
+            this.validationLabel.Location = new System.Drawing.Point(715, 385);
+            this.validationLabel.Name = "validationLabel";
+            this.validationLabel.Size = new System.Drawing.Size(79, 20);
+            this.validationLabel.TabIndex = 25;
+            this.validationLabel.Text = "Validation";
             // 
             // BlockchainApp
             // 
-            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+            this.AutoScaleDimensions = new System.Drawing.SizeF(9F, 20F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.ActiveCaption;
-            this.ClientSize = new System.Drawing.Size(681, 481);
-            this.Controls.Add(this.button7);
-            this.Controls.Add(this.button6);
-            this.Controls.Add(this.button5);
-            this.Controls.Add(this.label5);
-            this.Controls.Add(this.label4);
-            this.Controls.Add(this.label3);
-            this.Controls.Add(this.receiver);
+            this.ClientSize = new System.Drawing.Size(1022, 536);
+            this.Controls.Add(this.validationLabel);
+            this.Controls.Add(this.blocksLabel);
+            this.Controls.Add(this.transactionLabel);
+            this.Controls.Add(this.currentWalletLabel);
+            this.Controls.Add(this.checkBalance);
+            this.Controls.Add(this.validate);
+            this.Controls.Add(this.readPendingTransactions);
+            this.Controls.Add(this.printBlockchain);
+            this.Controls.Add(this.newBlock);
+            this.Controls.Add(this.reciever);
+            this.Controls.Add(this.recieverKeyLabel);
             this.Controls.Add(this.fee);
             this.Controls.Add(this.amount);
-            this.Controls.Add(this.button4);
-            this.Controls.Add(this.button3);
-            this.Controls.Add(this.label2);
-            this.Controls.Add(this.label1);
-            this.Controls.Add(this.privKey);
+            this.Controls.Add(this.feeLabel);
+            this.Controls.Add(this.amountLabel);
+            this.Controls.Add(this.createTransaction);
+            this.Controls.Add(this.validateKeys);
+            this.Controls.Add(this.privateKey);
             this.Controls.Add(this.publicKey);
-            this.Controls.Add(this.button2);
-            this.Controls.Add(this.textBox1);
-            this.Controls.Add(this.button1);
-            this.Controls.Add(this.richTextBox1);
+            this.Controls.Add(this.privateKeyLabel);
+            this.Controls.Add(this.publicKeyLabel);
+            this.Controls.Add(this.generateWallet);
+            this.Controls.Add(this.blockNo);
+            this.Controls.Add(this.printBlock);
+            this.Controls.Add(this.output);
             this.ForeColor = System.Drawing.Color.Black;
+            this.Margin = new System.Windows.Forms.Padding(4, 5, 4, 5);
             this.Name = "BlockchainApp";
             this.Text = "Blockchain App";
-            this.Load += new System.EventHandler(this.Form1_Load);
             this.ResumeLayout(false);
             this.PerformLayout();
 
@@ -252,25 +321,31 @@
 
         #endregion
 
-        private System.Windows.Forms.RichTextBox richTextBox1;
-        private System.Windows.Forms.Button button1;
-        private System.Windows.Forms.TextBox textBox1;
-        private System.Windows.Forms.Button button2;
+        private System.Windows.Forms.RichTextBox output;
+        private System.Windows.Forms.Button printBlock;
+        private System.Windows.Forms.TextBox blockNo;
+        private System.Windows.Forms.Button generateWallet;
+        private System.Windows.Forms.Label publicKeyLabel;
+        private System.Windows.Forms.Label privateKeyLabel;
         private System.Windows.Forms.TextBox publicKey;
-        private System.Windows.Forms.TextBox privKey;
-        private System.Windows.Forms.Label label1;
-        private System.Windows.Forms.Label label2;
-        private System.Windows.Forms.Button button3;
-        private System.Windows.Forms.Button button4;
-        private System.Windows.Forms.TextBox amount;
+        private System.Windows.Forms.TextBox privateKey;
+        private System.Windows.Forms.Button validateKeys;
+        private System.Windows.Forms.Button createTransaction;
         private System.Windows.Forms.TextBox fee;
-        private System.Windows.Forms.TextBox receiver;
-        private System.Windows.Forms.Label label3;
-        private System.Windows.Forms.Label label4;
-        private System.Windows.Forms.Label label5;
-        private System.Windows.Forms.Button button5;
-        private System.Windows.Forms.Button button6;
-        private System.Windows.Forms.Button button7;
+        private System.Windows.Forms.TextBox amount;
+        private System.Windows.Forms.Label feeLabel;
+        private System.Windows.Forms.Label amountLabel;
+        private System.Windows.Forms.TextBox reciever;
+        private System.Windows.Forms.Label recieverKeyLabel;
+        private System.Windows.Forms.Button newBlock;
+        private System.Windows.Forms.Button printBlockchain;
+        private System.Windows.Forms.Button readPendingTransactions;
+        private System.Windows.Forms.Button validate;
+        private System.Windows.Forms.Button checkBalance;
+        private System.Windows.Forms.Label currentWalletLabel;
+        private System.Windows.Forms.Label transactionLabel;
+        private System.Windows.Forms.Label blocksLabel;
+        private System.Windows.Forms.Label validationLabel;
     }
 }
 
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
index 36ad476..719e119 100644
--- a/BlockchainAssignment/BlockchainApp.cs
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -1,80 +1,131 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.ComponentModel;
-using System.Data;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.Windows.Forms;
 
 namespace BlockchainAssignment
 {
     public partial class BlockchainApp : Form
     {
-        Blockchain blockchain;
+        // Global blockchain object
+        private Blockchain blockchain;
 
+        // Default App Constructor
         public BlockchainApp()
         {
+            // Initialise UI Components
             InitializeComponent();
+            // Create a new blockchain 
             blockchain = new Blockchain();
-            richTextBox1.Text = "Blockchain Initialised";
+            // Update UI with an initalisation message
+            UpdateText("New blockchain initialised!");
         }
 
-        private void Form1_Load(object sender, EventArgs e)
+        /* PRINTING */
+        // Helper method to update the UI with a provided message
+        private void UpdateText(String text)
         {
+            output.Text = text;
         }
 
-        private void button1_Click(object sender, EventArgs e)
+        // Print entire blockchain to UI
+        private void ReadAll_Click(object sender, EventArgs e)
         {
-            if (Int32.TryParse(textBox1.Text, out int index))
-                richTextBox1.Text = blockchain.getBlock(index);
+            UpdateText(blockchain.ToString());
+        }
+
+        // Print Block N (based on user input)
+        private void PrintBlock_Click(object sender, EventArgs e)
+        {
+            if (Int32.TryParse(blockNo.Text, out int index))
+                UpdateText(blockchain.GetBlockAsString(index));
             else
-                richTextBox1.Text = "Not a number";
+                UpdateText("Invalid Block No.");
+        }
+
+        // Print pending transactions from the transaction pool to the UI
+        private void PrintPendingTransactions_Click(object sender, EventArgs e)
+        {
+            UpdateText(String.Join("\n", blockchain.transactionPool));
         }
 
-        private void button2_Click(object sender, EventArgs e)
+        /* WALLETS */
+        // Generate a new Wallet and fill the public and private key fields of the UI
+        private void GenerateWallet_Click(object sender, EventArgs e)
         {
-            String privKey;
-            Wallet.Wallet myNewWallet = new Wallet.Wallet(out privKey);
+            Wallet.Wallet myNewWallet = new Wallet.Wallet(out string privKey);
+
             publicKey.Text = myNewWallet.publicID;
-            this.privKey.Text = privKey;
+            privateKey.Text = privKey;
         }
 
-        private void button3_Click(object sender, EventArgs e)
+        // Validate the keys loaded in the UI by comparing their mathematical relationship
+        private void ValidateKeys_Click(object sender, EventArgs e)
         {
-            if (Wallet.Wallet.ValidatePrivateKey(privKey.Text, publicKey.Text))
-            {
-                richTextBox1.Text = "Keys are valid";
-            } 
+            if (Wallet.Wallet.ValidatePrivateKey(privateKey.Text, publicKey.Text))
+                UpdateText("Keys are valid");
             else
-            {
-                richTextBox1.Text = "Keys are invalid";
-            }
+                UpdateText("Keys are invalid");
         }
 
-        private void button4_Click(object sender, EventArgs e)
+        // Check the balance of current user
+        private void CheckBalance_Click(object sender, EventArgs e)
         {
-            Transaction newTransaction = new Transaction(publicKey.Text, receiver.Text, Double.Parse(amount.Text), Double.Parse(fee.Text), privKey.Text);
-            blockchain.transactionPool.Add(newTransaction);
-            richTextBox1.Text = newTransaction.ToString();
+            UpdateText(blockchain.GetBalance(publicKey.Text).ToString() + " Assignment Coin");
         }
 
-        private void button5_Click(object sender, EventArgs e)
+
+        /* TRANSACTION MANAGEMENT */
+        // Create a new pending transaction and add it to the transaction pool
+        private void CreateTransaction_Click(object sender, EventArgs e)
         {
-            Block newBlock = new Block(blockchain.getLastBlock(), blockchain.GetPendingTransactions(), publicKey.Text);
-            blockchain.Blocks.Add(newBlock);
-            richTextBox1.Text = newBlock.ToString();
+            Transaction transaction = new Transaction(publicKey.Text, reciever.Text, Double.Parse(amount.Text), Double.Parse(fee.Text), privateKey.Text);
+            /* TODO: Validate transaction */
+            blockchain.transactionPool.Add(transaction);
+            UpdateText(transaction.ToString());
         }
 
-        private void button6_Click(object sender, EventArgs e)
+        /* BLOCK MANAGEMENT */
+        // Conduct Proof-of-work in order to mine transactions from the pool and submit a new block to the Blockchain
+        private void NewBlock_Click(object sender, EventArgs e)
         {
-            richTextBox1.Text = blockchain.ToString();
+            // Retrieve pending transactions to be added to the newly generated Block
+            List<Transaction> transactions = blockchain.GetPendingTransactions();
+
+            // Create and append the new block - requires a reference to the previous block, a set of transactions and the miners public address (For the reward to be issued)
+            Block newBlock = new Block(blockchain.GetLastBlock(), transactions, publicKey.Text);
+            blockchain.blocks.Add(newBlock);
+
+            UpdateText(blockchain.ToString());
         }
 
-        private void button7_Click(object sender, EventArgs e)
+
+        /* BLOCKCHAIN VALIDATION */
+        // Validate the integrity of the state of the Blockchain
+        private void Validate_Click(object sender, EventArgs e)
         {
-            richTextBox1.Text = String.Join("\n", blockchain.transactionPool);
+            // CASE: Genesis Block - Check only hash as no transactions are currently present
+            if(blockchain.blocks.Count == 1)
+            {
+                if (!Blockchain.ValidateHash(blockchain.blocks[0])) // Recompute Hash to check validity
+                    UpdateText("Blockchain is invalid");
+                else
+                    UpdateText("Blockchain is valid");
+                return;
+            }
+
+            for (int i=1; i<blockchain.blocks.Count-1; i++)
+            {
+                if(
+                    blockchain.blocks[i].prevHash != blockchain.blocks[i - 1].hash || // Check hash "chain"
+                    !Blockchain.ValidateHash(blockchain.blocks[i]) ||  // Check each blocks hash
+                    !Blockchain.ValidateMerkleRoot(blockchain.blocks[i]) // Check transaction integrity using Merkle Root
+                )
+                {
+                    UpdateText("Blockchain is invalid");
+                    return;
+                }
+            }
+            UpdateText("Blockchain is valid");
         }
     }
-}
+}
\ No newline at end of file
diff --git a/BlockchainAssignment/HashCode/HashTools.cs b/BlockchainAssignment/HashCode/HashTools.cs
index 4caf583..c2461f8 100644
--- a/BlockchainAssignment/HashCode/HashTools.cs
+++ b/BlockchainAssignment/HashCode/HashTools.cs
@@ -4,24 +4,30 @@ using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
 using System.Security.Cryptography;
-using System.Collections;
 
-namespace BlockchainAssignment.HashCode {
 
+namespace BlockchainAssignment.HashCode
+{
     public static class HashTools
     {
-        // Takes byte array and returns hexadecimal string
+        /// <summary>
+        /// Takes byte array and returns hexadecimal string
+        /// </summary>
+        /// <param name="ba"></param>
+        /// <returns></returns>
         public static string ByteArrayToString(byte[] ba)
         {
             StringBuilder hex = new StringBuilder(ba.Length * 2);
-
             foreach (byte b in ba)
                 hex.AppendFormat("{0:x2}", b);
-            
             return hex.ToString();
         }
 
-        // Converts String to ByteArray
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="hex"></param>
+        /// <returns></returns>
         public static byte[] StringToByteArray(string hex)
         {
             return Enumerable.Range(0, hex.Length)
@@ -30,7 +36,8 @@ namespace BlockchainAssignment.HashCode {
                              .ToArray();
         }
 
-        public static String CombineHash(String hash1, String hash2)
+
+        public static String combineHash(String hash1, String hash2)
         {
             Byte[] bytes1 = StringToByteArray(hash1);
             Byte[] bytes2 = StringToByteArray(hash2);
@@ -40,6 +47,6 @@ namespace BlockchainAssignment.HashCode {
 
             return ByteArrayToString(combinedbytes);
         }
-    }
 
-}
\ No newline at end of file
+    }
+}
diff --git a/BlockchainAssignment/Transaction.cs b/BlockchainAssignment/Transaction.cs
index 88cb0cc..cf92a2d 100644
--- a/BlockchainAssignment/Transaction.cs
+++ b/BlockchainAssignment/Transaction.cs
@@ -9,45 +9,61 @@ namespace BlockchainAssignment
 {
     class Transaction
     {
-        DateTime timestamp;
-        public String senderAddress, recipientAddress, hash, signature;
-        public Double amount, fee;
+        /* Transaction Variables */
+        DateTime timestamp; // Time of creation
+        public String senderAddress, recipientAddress; // Participants public key addresses
+        public double amount, fee; // Quantities transferred
+        public String hash, signature; // Attributes for verification of validity
 
-        public Transaction(String senderAddress, String recipientAddress, Double amount, Double fee, String privateKey)
+        /* Transaction Constructor */
+        public Transaction(String from, String to, double amount, double fee, String privateKey)
         {
             timestamp = DateTime.Now;
-            this.senderAddress = senderAddress;
-            this.recipientAddress = recipientAddress;
+
+            senderAddress = from;
+            recipientAddress = to;
+
             this.amount = amount;
             this.fee = fee;
-            hash = CreateHash();
-            signature = Wallet.Wallet.CreateSignature(senderAddress, privateKey, hash);
+
+            hash = CreateHash(); // Hash the transaction attributes
+            signature = Wallet.Wallet.CreateSignature(from, privateKey, hash); // Sign the hash with the senders private key ensuring validity
         }
 
+        /* Hash the transaction attributes using SHA256 */
         public String CreateHash()
         {
             String hash = String.Empty;
-
             SHA256 hasher = SHA256Managed.Create();
-            String input = timestamp.ToString() + senderAddress + recipientAddress + amount.ToString() + fee.ToString();
 
+            /* Concatenate all transaction properties */
+            String input = timestamp + senderAddress + recipientAddress + amount + fee;
+
+            /* Apply the hash function to the "input" string */
             Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
 
+            /* Reformat to a string */
             foreach (byte x in hashByte)
                 hash += String.Format("{0:x2}", x);
 
             return hash;
         }
 
+        // Represent a transaction as a string for output to UI
         public override string ToString()
         {
-            return "Timestamp: " + timestamp.ToString() + 
-                "\nSender Address: " + senderAddress + 
-                "\nRecipient Address: " + recipientAddress + 
-                "\nAmount: " + amount.ToString() + " Assignment coin" + 
-                "\nFee: " + fee.ToString() + " Assignment Coin" + 
-                "\nHash: " + hash +
-                "\nSignature: " + signature;
+            return "  [TRANSACTION START]" 
+                + "\n  Timestamp: " + timestamp
+                + "\n  -- Verification --"
+                + "\n  Hash: " + hash
+                + "\n  Signature: " + signature
+                + "\n  -- Quantities --"
+                + "\n  Transferred: " + amount + " Assignment Coin"
+                + "\t  Fee: " + fee
+                + "\n  -- Participants --"
+                + "\n  Sender: " + senderAddress
+                + "\n  Reciever: " + recipientAddress 
+                + "\n  [TRANSACTION END]";
         }
     }
 }
diff --git a/BlockchainAssignment/Wallet/Wallet.cs b/BlockchainAssignment/Wallet/Wallet.cs
index 64e2be4..7a667d3 100644
--- a/BlockchainAssignment/Wallet/Wallet.cs
+++ b/BlockchainAssignment/Wallet/Wallet.cs
@@ -8,19 +8,20 @@ using System.IO;
 
 namespace BlockchainAssignment.Wallet
 {
-    // Below is the code for generating key pairs and signatures, and validating signatures and private keys
+    /// <summary>
+    /// Below is the code for generating key pairs and signatures, and validating signatures and private keys
+    /// </summary>
     class Wallet
     {
-        // Public ID - viewable to all (Derived from the users private key)
-        public String publicID; 
-
+        public String publicID; //public id viewable to all (created using private key)
+        
         public Wallet(out String privateKey)
         {
             privateKey = String.Empty;
             
             byte[] pubKey;
             byte[] privKey;
-
+            
             CngKeyCreationParameters keyCreationParameters = new CngKeyCreationParameters();
             keyCreationParameters.ExportPolicy = CngExportPolicies.AllowPlaintextExport;
             keyCreationParameters.KeyUsage = CngKeyUsages.Signing;
@@ -29,61 +30,73 @@ namespace BlockchainAssignment.Wallet
 
             byte[] KeyBlob = key.Export(CngKeyBlobFormat.EccPrivateBlob); 
             byte[] pubBlob = key.Export(CngKeyBlobFormat.EccPublicBlob);
-
             pubKey = KeyBlob.Skip(8).Take(KeyBlob.Length - 40).ToArray();
             privKey = KeyBlob.Skip(72).Take(KeyBlob.Length).ToArray();
-
             publicID = Convert.ToBase64String(pubKey);
-            privateKey = Convert.ToBase64String(privKey);
+            privateKey = Convert.ToBase64String(privKey); 
         }
 
         public static bool ValidatePrivateKey(String privateKey, String publicID)
         {
-            // Random string used to create a verification signature
-            String testHash = "0000abc1e11b8d37c1e1232a2ea6d290cddb0c678058c37aa766f813cbbb366e"; 
+            String testHash = "0000abc1e11b8d37c1e1232a2ea6d290cddb0c678058c37aa766f813cbbb366e"; //just a random string to create a sig with
 
             if (privateKey.Length != 44 || publicID.Length != 88)
+            {
                 return false;
+            }
 
             String sig = CreateSignature(publicID, privateKey, testHash);
 
             return ValidateSignature(publicID, testHash, sig);
+
         }
 
-        // Validates if a signiture is legitimate.
-        // publicID is the Id of the wallet making the transaction.
-        // datahash is the hash of transaction
-        // datasig is the hash created by the private key and datahash
-        // The datasig can be validated with the above parameters.
+
+        /// <summary>
+        /// Validates if a signiture is legitimate.
+        /// publicID is the Id of the wallet making the transaction.
+        /// datahash is the hash of transaction
+        /// datasig is the hash created by the private key and datahash
+        /// The datasig can be validated with the above parameters.
+        /// </summary>
+        /// <param name="publicID"></param>
+        /// <param name="datahash"></param>
+        /// <param name="datasig"></param>
+        /// <returns></returns>
         public static bool ValidateSignature(String publicID, String datahash, String datasig)
         {
             if (publicID.Equals("Mine Rewards"))
+            {
                 publicID = "QfF3+9GgTxyGLvb+ScOAI6nJxBh8IyZbeD0r6BJBMyabZmyuP82yrSLKMq/F05OG0VZ4gg63uHFZUKzCu3wZuA==";
-            
+            }
+
             if (publicID.Length != 88 || datasig.Equals("null"))
+            {
                 return false;
-            
+            }
             CngKey key = createKey(publicID);
 
             if (key == null)
+            {
                 return false;
+            }
 
             ECDsaCng dsa = new ECDsaCng(key);
             return dsa.VerifyData(Convert.FromBase64String(datahash), Convert.FromBase64String(datasig));
+
         }
 
         public static String CreateSignature(String publicID, String privateKey, String datahash) //need to have checks that publicID and privatekey are correct before using this method
         {
             CngKey key = createKey(publicID, privateKey);
-
             if (key == null)
+            {
                 return "null";
-            
+            }
             Byte[] datahashByte = Convert.FromBase64String(datahash);
 
             ECDsaCng dsa = new ECDsaCng(key);
             Byte[] byteSig = dsa.SignData(datahashByte);
-
             return Convert.ToBase64String(byteSig);
         }
 
@@ -96,7 +109,6 @@ namespace BlockchainAssignment.Wallet
                     publicID = "QfF3+9GgTxyGLvb+ScOAI6nJxBh8IyZbeD0r6BJBMyabZmyuP82yrSLKMq/F05OG0VZ4gg63uHFZUKzCu3wZuA==";
                     privateKey = "mkT1Iu3YF4NSruHBptVytyDkNcxwemrkclndJH0+73o=";
                 }
-
                 CngKey key;
                 byte[] keyByte = new Byte[] { 69, 67, 83, 49, 32, 0, 0, 0 }; //first 8 bytes always same
                 byte[] publicBytes = Convert.FromBase64String(publicID);
@@ -124,6 +136,10 @@ namespace BlockchainAssignment.Wallet
                 Console.WriteLine(error.ToString());
                 return null;
             }
+
         }
+
+        
+
     }
 }

commit f083330ebdebe99c5e1d98450e5dcf078b4e590b
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Sat Mar 1 23:14:25 2025 +0000

    part 4

diff --git a/BlockchainAssignment/Block.cs b/BlockchainAssignment/Block.cs
index fef7b4f..fe8761c 100644
--- a/BlockchainAssignment/Block.cs
+++ b/BlockchainAssignment/Block.cs
@@ -10,24 +10,48 @@ namespace BlockchainAssignment
     class Block
     {
         int index;
-        String hash, prevHash;
+        String hash, prevHash, merkleRoot;
         DateTime timestamp;
 
+        List<Transaction> transactionList;
+
+        public long nonce = 0;
+        public int difficulty = 4;
+
+        public double reward = 1.0;
+        public String minerAddress = "";
+
         /* Genesis Block Constructor */
         public Block()
         {
-            this.index = 0;
-            this.timestamp = DateTime.Now;
-            this.prevHash = String.Empty;
-            this.hash = CreateHash();
+            index = 0;
+            timestamp = DateTime.Now;
+            prevHash = String.Empty;
+            transactionList = new List<Transaction>();
+            hash = Mine();
         }
 
         public Block(int index, String hash)
         {
             this.index = index + 1;
-            this.timestamp = DateTime.Now;
-            this.prevHash = hash;
-            this.hash = CreateHash();
+            timestamp = DateTime.Now;
+            prevHash = hash;
+            this.hash = Mine();
+        }
+
+        public Block(Block block, List<Transaction> transactions, String minerAddress)
+        {
+            index = block.index + 1;
+            timestamp = DateTime.Now;
+            prevHash = block.hash;
+
+            this.minerAddress = minerAddress;
+            transactions.Add(CreateRewardTransaction(transactions));
+
+            transactionList = transactions;
+            merkleRoot = MerkleRoot(transactions);
+
+            hash = Mine();
         }
 
         public String CreateHash()
@@ -35,7 +59,7 @@ namespace BlockchainAssignment
             String hash = String.Empty;
 
             SHA256 hasher = SHA256Managed.Create();
-            String input = index.ToString() + hash + prevHash + timestamp.ToString();
+            String input = index.ToString() + hash + prevHash + timestamp.ToString() + nonce;
 
             Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
 
@@ -45,12 +69,68 @@ namespace BlockchainAssignment
             return hash;
         }
 
+        public String Mine()
+        {
+            nonce = 0;
+            String hash = CreateHash();
+
+            String re = new string('0', difficulty);
+
+            while (!hash.StartsWith(re))
+            {
+                nonce++;
+                hash = CreateHash();
+            }
+            return hash;
+        }
+
+        public static String MerkleRoot(List<Transaction> transactionList)
+        {
+            List<String> hashes = transactionList.Select(t => t.hash).ToList();
+            if (hashes.Count == 0)
+            {
+                return String.Empty;
+            }
+            if (hashes.Count == 1)
+            {
+                return hashes[0];
+            }
+            while (hashes.Count != 1)
+            {
+                List<String> merkleLeaves = new List<String>();
+                for (int i = 0; i < hashes.Count; i += 2)
+                {
+                    if (i == hashes.Count - 1)
+                    {
+                        merkleLeaves.Add(HashCode.HashTools.CombineHash(hashes[i], hashes[i]));
+                    }
+                    else
+                    {
+                        merkleLeaves.Add(HashCode.HashTools.CombineHash(hashes[i], hashes[i + 1]));
+                    }
+                }
+                hashes = merkleLeaves;
+            }
+
+            return hashes[0];
+        }
+
+        public Transaction CreateRewardTransaction(List<Transaction> transactions)
+        {
+            double fees = transactions.Aggregate(0.0, (acc, t) => acc + t.fee);
+            return new Transaction("Mine Rewards", minerAddress, (reward + fees), 0, "");
+        }
+
         public override string ToString()
         {
-            return "Index: " + index.ToString() + 
+            return "Index: " + index.ToString() +
                 "\nTimestamp: " + timestamp.ToString() +
                 "\nHash: " + hash +
-                "\nPrevious Hash: " + prevHash;
+                "\nPrevious Hash: " + prevHash +
+                "\nTransactions: " + String.Join("\n", transactionList) +
+                "\nNonce: " + nonce.ToString() +
+                "\nMerkle Root: " + merkleRoot +
+                "\n";
         }
     }
 }
diff --git a/BlockchainAssignment/Blockchain.cs b/BlockchainAssignment/Blockchain.cs
index 83552f4..3f24488 100644
--- a/BlockchainAssignment/Blockchain.cs
+++ b/BlockchainAssignment/Blockchain.cs
@@ -10,11 +10,15 @@ namespace BlockchainAssignment
     {
         public List<Block> Blocks;
 
+        public int transactionsPerBlock = 5;
+        public List<Transaction> transactionPool;
+
         public Blockchain()
         {
             Blocks = new List<Block>() {
                 new Block()
             };
+            transactionPool = new List<Transaction>();
         }
 
         public String getBlock(int index)
@@ -24,6 +28,19 @@ namespace BlockchainAssignment
             return "Block does not Exist";
         }
 
+        public Block getLastBlock()
+        {
+            return Blocks[Blocks.Count - 1];
+        }
+
+        public List<Transaction> GetPendingTransactions()
+        {
+            int n = Math.Min(transactionsPerBlock, transactionPool.Count);
+            List<Transaction> transactions = transactionPool.GetRange(0, n);
+            transactionPool.RemoveRange(0, n);
+            return transactions;
+        }
+
         public override string ToString()
         {
             return String.Join("\n", Blocks);
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
index 8ad5e84..db5db9b 100644
--- a/BlockchainAssignment/BlockchainApp.Designer.cs
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -44,6 +44,9 @@
             this.label3 = new System.Windows.Forms.Label();
             this.label4 = new System.Windows.Forms.Label();
             this.label5 = new System.Windows.Forms.Label();
+            this.button5 = new System.Windows.Forms.Button();
+            this.button6 = new System.Windows.Forms.Button();
+            this.button7 = new System.Windows.Forms.Button();
             this.SuspendLayout();
             // 
             // richTextBox1
@@ -183,12 +186,45 @@
             this.label5.TabIndex = 15;
             this.label5.Text = "Receiver Key";
             // 
+            // button5
+            // 
+            this.button5.Location = new System.Drawing.Point(12, 374);
+            this.button5.Name = "button5";
+            this.button5.Size = new System.Drawing.Size(75, 43);
+            this.button5.TabIndex = 16;
+            this.button5.Text = "Generate New Block";
+            this.button5.UseVisualStyleBackColor = true;
+            this.button5.Click += new System.EventHandler(this.button5_Click);
+            // 
+            // button6
+            // 
+            this.button6.Location = new System.Drawing.Point(201, 333);
+            this.button6.Name = "button6";
+            this.button6.Size = new System.Drawing.Size(75, 23);
+            this.button6.TabIndex = 17;
+            this.button6.Text = "Print All";
+            this.button6.UseVisualStyleBackColor = true;
+            this.button6.Click += new System.EventHandler(this.button6_Click);
+            // 
+            // button7
+            // 
+            this.button7.Location = new System.Drawing.Point(201, 362);
+            this.button7.Name = "button7";
+            this.button7.Size = new System.Drawing.Size(75, 54);
+            this.button7.TabIndex = 18;
+            this.button7.Text = "Print Pending Transactions";
+            this.button7.UseVisualStyleBackColor = true;
+            this.button7.Click += new System.EventHandler(this.button7_Click);
+            // 
             // BlockchainApp
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.ActiveCaption;
             this.ClientSize = new System.Drawing.Size(681, 481);
+            this.Controls.Add(this.button7);
+            this.Controls.Add(this.button6);
+            this.Controls.Add(this.button5);
             this.Controls.Add(this.label5);
             this.Controls.Add(this.label4);
             this.Controls.Add(this.label3);
@@ -232,6 +268,9 @@
         private System.Windows.Forms.Label label3;
         private System.Windows.Forms.Label label4;
         private System.Windows.Forms.Label label5;
+        private System.Windows.Forms.Button button5;
+        private System.Windows.Forms.Button button6;
+        private System.Windows.Forms.Button button7;
     }
 }
 
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
index 2f8a236..36ad476 100644
--- a/BlockchainAssignment/BlockchainApp.cs
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -56,7 +56,25 @@ namespace BlockchainAssignment
         private void button4_Click(object sender, EventArgs e)
         {
             Transaction newTransaction = new Transaction(publicKey.Text, receiver.Text, Double.Parse(amount.Text), Double.Parse(fee.Text), privKey.Text);
+            blockchain.transactionPool.Add(newTransaction);
             richTextBox1.Text = newTransaction.ToString();
         }
+
+        private void button5_Click(object sender, EventArgs e)
+        {
+            Block newBlock = new Block(blockchain.getLastBlock(), blockchain.GetPendingTransactions(), publicKey.Text);
+            blockchain.Blocks.Add(newBlock);
+            richTextBox1.Text = newBlock.ToString();
+        }
+
+        private void button6_Click(object sender, EventArgs e)
+        {
+            richTextBox1.Text = blockchain.ToString();
+        }
+
+        private void button7_Click(object sender, EventArgs e)
+        {
+            richTextBox1.Text = String.Join("\n", blockchain.transactionPool);
+        }
     }
 }
diff --git a/BlockchainAssignment/Transaction.cs b/BlockchainAssignment/Transaction.cs
index 3b1e711..88cb0cc 100644
--- a/BlockchainAssignment/Transaction.cs
+++ b/BlockchainAssignment/Transaction.cs
@@ -10,18 +10,18 @@ namespace BlockchainAssignment
     class Transaction
     {
         DateTime timestamp;
-        String senderAddress, recipientAddress, hash, signature;
-        Double amount, fee;
+        public String senderAddress, recipientAddress, hash, signature;
+        public Double amount, fee;
 
         public Transaction(String senderAddress, String recipientAddress, Double amount, Double fee, String privateKey)
         {
-            this.timestamp = DateTime.Now;
+            timestamp = DateTime.Now;
             this.senderAddress = senderAddress;
             this.recipientAddress = recipientAddress;
             this.amount = amount;
             this.fee = fee;
-            this.hash = CreateHash();
-            this.signature = Wallet.Wallet.CreateSignature(senderAddress, privateKey, hash);
+            hash = CreateHash();
+            signature = Wallet.Wallet.CreateSignature(senderAddress, privateKey, hash);
         }
 
         public String CreateHash()
diff --git a/Luke Wilson CS3BC Coursework.docx b/Luke Wilson CS3BC Coursework.docx
index a636953..7922048 100644
--- a/Luke Wilson CS3BC Coursework.docx	
+++ b/Luke Wilson CS3BC Coursework.docx	
@@ -1,3 +1,18 @@
 
 
+Part 1:
 
+
+Part 2:
+
+
+Part 3:
+
+Can send transactions but they are not validated on the blockchain
+Part 4:
+Created a new block and sent a transaction which is pending
+
+Both blocks shown with the transaction shown in the second block
+
+
+Part 5: 

commit 57fcb4314e8b1eb5ffbb3ccfcad9a75f56710b4b
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Sat Mar 1 16:41:38 2025 +0000

    part 3

diff --git a/BlockchainAssignment/Block.cs b/BlockchainAssignment/Block.cs
index 576c84e..fef7b4f 100644
--- a/BlockchainAssignment/Block.cs
+++ b/BlockchainAssignment/Block.cs
@@ -9,59 +9,46 @@ namespace BlockchainAssignment
 {
     class Block
     {
-        /** Block Properties */
-        DateTime timestamp;
         int index;
         String hash, prevHash;
+        DateTime timestamp;
 
         /* Genesis Block Constructor */
         public Block()
         {
-            this.timestamp = DateTime.Now;
             this.index = 0;
-            this.prevHash = String.Empty; // No prior block hash
-            this.hash = CreateHash();
-        }
-
-        /* Block Constructors */
-        public Block(int index, String hash) 
-        { 
             this.timestamp = DateTime.Now;
-            this.index = index + 1;
-            this.prevHash = hash;
+            this.prevHash = String.Empty;
             this.hash = CreateHash();
         }
 
-        // Overloaded block constructor accepting a Block object
-        public Block(Block prevBlock)
+        public Block(int index, String hash)
         {
+            this.index = index + 1;
             this.timestamp = DateTime.Now;
-            this.index = prevBlock.index + 1;
-            this.prevHash = prevBlock.hash;
+            this.prevHash = hash;
             this.hash = CreateHash();
         }
 
-        /* Generate a blocks hash using the SHA256 algorithm */
         public String CreateHash()
         {
-            SHA256 hasher = SHA256Managed.Create(); 
+            String hash = String.Empty;
 
-            String input = index.ToString() + timestamp.ToString() + prevHash; 
-            Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input)); 
+            SHA256 hasher = SHA256Managed.Create();
+            String input = index.ToString() + hash + prevHash + timestamp.ToString();
 
-            String hash = string.Empty; 
+            Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
 
-            foreach (byte x in hashByte) 
-                hash += String.Format("{0:x2}", x); 
+            foreach (byte x in hashByte)
+                hash += String.Format("{0:x2}", x);
 
             return hash;
         }
 
-        /* Return a human-readable representation of a block */
         public override string ToString()
         {
-            return
-                "Index: " + index.ToString() + "\tTimestamp: " + timestamp.ToString() +
+            return "Index: " + index.ToString() + 
+                "\nTimestamp: " + timestamp.ToString() +
                 "\nHash: " + hash +
                 "\nPrevious Hash: " + prevHash;
         }
diff --git a/BlockchainAssignment/Blockchain.cs b/BlockchainAssignment/Blockchain.cs
index f777bf1..83552f4 100644
--- a/BlockchainAssignment/Blockchain.cs
+++ b/BlockchainAssignment/Blockchain.cs
@@ -8,10 +8,8 @@ namespace BlockchainAssignment
 {
     class Blockchain
     {
-        /* Blockchain Properties */
-        List<Block> Blocks;
+        public List<Block> Blocks;
 
-        /* Blockchain Constructor - Initialises a new blockchain with a single genesis block */
         public Blockchain()
         {
             Blocks = new List<Block>() {
@@ -19,12 +17,16 @@ namespace BlockchainAssignment
             };
         }
 
-        /* Helper function to get a block at a user specified index */
-        public String getBlockAsString(int index)
+        public String getBlock(int index)
         {
             if (index >= 0 && index < Blocks.Count)
                 return Blocks[index].ToString();
-            return "Block does not exist at index: " + index.ToString();
+            return "Block does not Exist";
+        }
+
+        public override string ToString()
+        {
+            return String.Join("\n", Blocks);
         }
     }
 }
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
index dc38cbc..8ad5e84 100644
--- a/BlockchainAssignment/BlockchainApp.Designer.cs
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -29,8 +29,21 @@
         private void InitializeComponent()
         {
             this.richTextBox1 = new System.Windows.Forms.RichTextBox();
-            this.printBlock = new System.Windows.Forms.Button();
-            this.blockIndex = new System.Windows.Forms.TextBox();
+            this.button1 = new System.Windows.Forms.Button();
+            this.textBox1 = new System.Windows.Forms.TextBox();
+            this.button2 = new System.Windows.Forms.Button();
+            this.publicKey = new System.Windows.Forms.TextBox();
+            this.privKey = new System.Windows.Forms.TextBox();
+            this.label1 = new System.Windows.Forms.Label();
+            this.label2 = new System.Windows.Forms.Label();
+            this.button3 = new System.Windows.Forms.Button();
+            this.button4 = new System.Windows.Forms.Button();
+            this.amount = new System.Windows.Forms.TextBox();
+            this.fee = new System.Windows.Forms.TextBox();
+            this.receiver = new System.Windows.Forms.TextBox();
+            this.label3 = new System.Windows.Forms.Label();
+            this.label4 = new System.Windows.Forms.Label();
+            this.label5 = new System.Windows.Forms.Label();
             this.SuspendLayout();
             // 
             // richTextBox1
@@ -43,24 +56,132 @@
             this.richTextBox1.TabIndex = 0;
             this.richTextBox1.Text = "";
             // 
-            // printBlock
+            // button1
             // 
-            this.printBlock.Location = new System.Drawing.Point(12, 331);
-            this.printBlock.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);
-            this.printBlock.Name = "printBlock";
-            this.printBlock.Size = new System.Drawing.Size(79, 26);
-            this.printBlock.TabIndex = 1;
-            this.printBlock.Text = "Print Block";
-            this.printBlock.UseVisualStyleBackColor = true;
-            this.printBlock.Click += new System.EventHandler(this.button1_Click);
+            this.button1.Location = new System.Drawing.Point(12, 333);
+            this.button1.Name = "button1";
+            this.button1.Size = new System.Drawing.Size(75, 23);
+            this.button1.TabIndex = 1;
+            this.button1.Text = "Print";
+            this.button1.UseVisualStyleBackColor = true;
+            this.button1.Click += new System.EventHandler(this.button1_Click);
             // 
-            // blockIndex
+            // textBox1
             // 
-            this.blockIndex.Location = new System.Drawing.Point(95, 335);
-            this.blockIndex.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);
-            this.blockIndex.Name = "blockIndex";
-            this.blockIndex.Size = new System.Drawing.Size(72, 20);
-            this.blockIndex.TabIndex = 2;
+            this.textBox1.Location = new System.Drawing.Point(94, 335);
+            this.textBox1.Name = "textBox1";
+            this.textBox1.Size = new System.Drawing.Size(100, 20);
+            this.textBox1.TabIndex = 2;
+            // 
+            // button2
+            // 
+            this.button2.Location = new System.Drawing.Point(594, 335);
+            this.button2.Name = "button2";
+            this.button2.Size = new System.Drawing.Size(75, 53);
+            this.button2.TabIndex = 3;
+            this.button2.Text = "Generate Keys";
+            this.button2.UseVisualStyleBackColor = true;
+            this.button2.Click += new System.EventHandler(this.button2_Click);
+            // 
+            // publicKey
+            // 
+            this.publicKey.Location = new System.Drawing.Point(409, 335);
+            this.publicKey.Name = "publicKey";
+            this.publicKey.Size = new System.Drawing.Size(179, 20);
+            this.publicKey.TabIndex = 4;
+            // 
+            // privKey
+            // 
+            this.privKey.Location = new System.Drawing.Point(409, 365);
+            this.privKey.Name = "privKey";
+            this.privKey.Size = new System.Drawing.Size(179, 20);
+            this.privKey.TabIndex = 5;
+            // 
+            // label1
+            // 
+            this.label1.AutoSize = true;
+            this.label1.Location = new System.Drawing.Point(324, 338);
+            this.label1.Name = "label1";
+            this.label1.Size = new System.Drawing.Size(57, 13);
+            this.label1.TabIndex = 6;
+            this.label1.Text = "Public Key";
+            // 
+            // label2
+            // 
+            this.label2.AutoSize = true;
+            this.label2.Location = new System.Drawing.Point(324, 368);
+            this.label2.Name = "label2";
+            this.label2.Size = new System.Drawing.Size(61, 13);
+            this.label2.TabIndex = 7;
+            this.label2.Text = "Private Key";
+            // 
+            // button3
+            // 
+            this.button3.Location = new System.Drawing.Point(594, 395);
+            this.button3.Name = "button3";
+            this.button3.Size = new System.Drawing.Size(75, 47);
+            this.button3.TabIndex = 8;
+            this.button3.Text = "Validate Keys";
+            this.button3.UseVisualStyleBackColor = true;
+            this.button3.Click += new System.EventHandler(this.button3_Click);
+            // 
+            // button4
+            // 
+            this.button4.Location = new System.Drawing.Point(12, 423);
+            this.button4.Name = "button4";
+            this.button4.Size = new System.Drawing.Size(75, 46);
+            this.button4.TabIndex = 9;
+            this.button4.Text = "Create Transaction";
+            this.button4.UseVisualStyleBackColor = true;
+            this.button4.Click += new System.EventHandler(this.button4_Click);
+            // 
+            // amount
+            // 
+            this.amount.Location = new System.Drawing.Point(146, 423);
+            this.amount.Name = "amount";
+            this.amount.Size = new System.Drawing.Size(48, 20);
+            this.amount.TabIndex = 10;
+            // 
+            // fee
+            // 
+            this.fee.Location = new System.Drawing.Point(146, 450);
+            this.fee.Name = "fee";
+            this.fee.Size = new System.Drawing.Size(48, 20);
+            this.fee.TabIndex = 11;
+            // 
+            // receiver
+            // 
+            this.receiver.Location = new System.Drawing.Point(288, 450);
+            this.receiver.Name = "receiver";
+            this.receiver.Size = new System.Drawing.Size(173, 20);
+            this.receiver.TabIndex = 12;
+            // 
+            // label3
+            // 
+            this.label3.AutoSize = true;
+            this.label3.Location = new System.Drawing.Point(94, 429);
+            this.label3.Name = "label3";
+            this.label3.Size = new System.Drawing.Size(43, 13);
+            this.label3.TabIndex = 13;
+            this.label3.Text = "Amount";
+            // 
+            // label4
+            // 
+            this.label4.AutoSize = true;
+            this.label4.Location = new System.Drawing.Point(94, 453);
+            this.label4.Name = "label4";
+            this.label4.Size = new System.Drawing.Size(25, 13);
+            this.label4.TabIndex = 14;
+            this.label4.Text = "Fee";
+            // 
+            // label5
+            // 
+            this.label5.AutoSize = true;
+            this.label5.Location = new System.Drawing.Point(211, 453);
+            this.label5.Name = "label5";
+            this.label5.Size = new System.Drawing.Size(71, 13);
+            this.label5.TabIndex = 15;
+            this.label5.Text = "Receiver Key";
             // 
             // BlockchainApp
             // 
@@ -68,8 +189,21 @@
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.ActiveCaption;
             this.ClientSize = new System.Drawing.Size(681, 481);
-            this.Controls.Add(this.blockIndex);
-            this.Controls.Add(this.printBlock);
+            this.Controls.Add(this.label5);
+            this.Controls.Add(this.label4);
+            this.Controls.Add(this.label3);
+            this.Controls.Add(this.receiver);
+            this.Controls.Add(this.fee);
+            this.Controls.Add(this.amount);
+            this.Controls.Add(this.button4);
+            this.Controls.Add(this.button3);
+            this.Controls.Add(this.label2);
+            this.Controls.Add(this.label1);
+            this.Controls.Add(this.privKey);
+            this.Controls.Add(this.publicKey);
+            this.Controls.Add(this.button2);
+            this.Controls.Add(this.textBox1);
+            this.Controls.Add(this.button1);
             this.Controls.Add(this.richTextBox1);
             this.ForeColor = System.Drawing.Color.Black;
             this.Name = "BlockchainApp";
@@ -83,8 +217,21 @@
         #endregion
 
         private System.Windows.Forms.RichTextBox richTextBox1;
-        private System.Windows.Forms.Button printBlock;
-        private System.Windows.Forms.TextBox blockIndex;
+        private System.Windows.Forms.Button button1;
+        private System.Windows.Forms.TextBox textBox1;
+        private System.Windows.Forms.Button button2;
+        private System.Windows.Forms.TextBox publicKey;
+        private System.Windows.Forms.TextBox privKey;
+        private System.Windows.Forms.Label label1;
+        private System.Windows.Forms.Label label2;
+        private System.Windows.Forms.Button button3;
+        private System.Windows.Forms.Button button4;
+        private System.Windows.Forms.TextBox amount;
+        private System.Windows.Forms.TextBox fee;
+        private System.Windows.Forms.TextBox receiver;
+        private System.Windows.Forms.Label label3;
+        private System.Windows.Forms.Label label4;
+        private System.Windows.Forms.Label label5;
     }
 }
 
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
index cd1c1e5..2f8a236 100644
--- a/BlockchainAssignment/BlockchainApp.cs
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -7,35 +7,56 @@ using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
 using System.Windows.Forms;
-using static System.Windows.Forms.VisualStyles.VisualStyleElement;
 
 namespace BlockchainAssignment
 {
     public partial class BlockchainApp : Form
     {
-        /* Global Blockchain object - Our working blockchain */
         Blockchain blockchain;
 
-        /* Initialize blockchain on startup of application UI */
         public BlockchainApp()
         {
             InitializeComponent();
             blockchain = new Blockchain();
-            richTextBox1.Text = "New blockchain initialised!";
+            richTextBox1.Text = "Blockchain Initialised";
         }
 
         private void Form1_Load(object sender, EventArgs e)
         {
         }
 
-        // Duplicate the value input into our new textbox (textBox1) in the large "console" (richTextBox1)
         private void button1_Click(object sender, EventArgs e)
         {
-            if (Int32.TryParse(blockIndex.Text, out int index))
-                richTextBox1.Text = blockchain.getBlockAsString(index);
+            if (Int32.TryParse(textBox1.Text, out int index))
+                richTextBox1.Text = blockchain.getBlock(index);
             else
-                richTextBox1.Text = "Please enter a valid number";
+                richTextBox1.Text = "Not a number";
+        }
 
+        private void button2_Click(object sender, EventArgs e)
+        {
+            String privKey;
+            Wallet.Wallet myNewWallet = new Wallet.Wallet(out privKey);
+            publicKey.Text = myNewWallet.publicID;
+            this.privKey.Text = privKey;
+        }
+
+        private void button3_Click(object sender, EventArgs e)
+        {
+            if (Wallet.Wallet.ValidatePrivateKey(privKey.Text, publicKey.Text))
+            {
+                richTextBox1.Text = "Keys are valid";
+            } 
+            else
+            {
+                richTextBox1.Text = "Keys are invalid";
+            }
+        }
+
+        private void button4_Click(object sender, EventArgs e)
+        {
+            Transaction newTransaction = new Transaction(publicKey.Text, receiver.Text, Double.Parse(amount.Text), Double.Parse(fee.Text), privKey.Text);
+            richTextBox1.Text = newTransaction.ToString();
         }
     }
 }
diff --git a/BlockchainAssignment/BlockchainAssignment.csproj b/BlockchainAssignment/BlockchainAssignment.csproj
index 3c0fe85..e2a0582 100644
--- a/BlockchainAssignment/BlockchainAssignment.csproj
+++ b/BlockchainAssignment/BlockchainAssignment.csproj
@@ -57,6 +57,7 @@
     <Compile Include="HashCode\HashTools.cs" />
     <Compile Include="Program.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="Transaction.cs" />
     <Compile Include="Wallet\Wallet.cs" />
     <EmbeddedResource Include="BlockchainApp.resx">
       <DependentUpon>BlockchainApp.cs</DependentUpon>
diff --git a/BlockchainAssignment/Transaction.cs b/BlockchainAssignment/Transaction.cs
new file mode 100644
index 0000000..3b1e711
--- /dev/null
+++ b/BlockchainAssignment/Transaction.cs
@@ -0,0 +1,53 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Security.Cryptography;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+    class Transaction
+    {
+        DateTime timestamp;
+        String senderAddress, recipientAddress, hash, signature;
+        Double amount, fee;
+
+        public Transaction(String senderAddress, String recipientAddress, Double amount, Double fee, String privateKey)
+        {
+            this.timestamp = DateTime.Now;
+            this.senderAddress = senderAddress;
+            this.recipientAddress = recipientAddress;
+            this.amount = amount;
+            this.fee = fee;
+            this.hash = CreateHash();
+            this.signature = Wallet.Wallet.CreateSignature(senderAddress, privateKey, hash);
+        }
+
+        public String CreateHash()
+        {
+            String hash = String.Empty;
+
+            SHA256 hasher = SHA256Managed.Create();
+            String input = timestamp.ToString() + senderAddress + recipientAddress + amount.ToString() + fee.ToString();
+
+            Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
+
+            foreach (byte x in hashByte)
+                hash += String.Format("{0:x2}", x);
+
+            return hash;
+        }
+
+        public override string ToString()
+        {
+            return "Timestamp: " + timestamp.ToString() + 
+                "\nSender Address: " + senderAddress + 
+                "\nRecipient Address: " + recipientAddress + 
+                "\nAmount: " + amount.ToString() + " Assignment coin" + 
+                "\nFee: " + fee.ToString() + " Assignment Coin" + 
+                "\nHash: " + hash +
+                "\nSignature: " + signature;
+        }
+    }
+}

commit 2b308c7306a8e7e56b68e436de453318005f520b
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Sat Mar 1 16:11:47 2025 +0000

    part 1 and 2

diff --git a/BlockchainAssignment/Block.cs b/BlockchainAssignment/Block.cs
new file mode 100644
index 0000000..576c84e
--- /dev/null
+++ b/BlockchainAssignment/Block.cs
@@ -0,0 +1,69 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Security.Cryptography;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+    class Block
+    {
+        /** Block Properties */
+        DateTime timestamp;
+        int index;
+        String hash, prevHash;
+
+        /* Genesis Block Constructor */
+        public Block()
+        {
+            this.timestamp = DateTime.Now;
+            this.index = 0;
+            this.prevHash = String.Empty; // No prior block hash
+            this.hash = CreateHash();
+        }
+
+        /* Block Constructors */
+        public Block(int index, String hash) 
+        { 
+            this.timestamp = DateTime.Now;
+            this.index = index + 1;
+            this.prevHash = hash;
+            this.hash = CreateHash();
+        }
+
+        // Overloaded block constructor accepting a Block object
+        public Block(Block prevBlock)
+        {
+            this.timestamp = DateTime.Now;
+            this.index = prevBlock.index + 1;
+            this.prevHash = prevBlock.hash;
+            this.hash = CreateHash();
+        }
+
+        /* Generate a blocks hash using the SHA256 algorithm */
+        public String CreateHash()
+        {
+            SHA256 hasher = SHA256Managed.Create(); 
+
+            String input = index.ToString() + timestamp.ToString() + prevHash; 
+            Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input)); 
+
+            String hash = string.Empty; 
+
+            foreach (byte x in hashByte) 
+                hash += String.Format("{0:x2}", x); 
+
+            return hash;
+        }
+
+        /* Return a human-readable representation of a block */
+        public override string ToString()
+        {
+            return
+                "Index: " + index.ToString() + "\tTimestamp: " + timestamp.ToString() +
+                "\nHash: " + hash +
+                "\nPrevious Hash: " + prevHash;
+        }
+    }
+}
diff --git a/BlockchainAssignment/Blockchain.cs b/BlockchainAssignment/Blockchain.cs
new file mode 100644
index 0000000..f777bf1
--- /dev/null
+++ b/BlockchainAssignment/Blockchain.cs
@@ -0,0 +1,30 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace BlockchainAssignment
+{
+    class Blockchain
+    {
+        /* Blockchain Properties */
+        List<Block> Blocks;
+
+        /* Blockchain Constructor - Initialises a new blockchain with a single genesis block */
+        public Blockchain()
+        {
+            Blocks = new List<Block>() {
+                new Block()
+            };
+        }
+
+        /* Helper function to get a block at a user specified index */
+        public String getBlockAsString(int index)
+        {
+            if (index >= 0 && index < Blocks.Count)
+                return Blocks[index].ToString();
+            return "Block does not exist at index: " + index.ToString();
+        }
+    }
+}
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
index e5bcb4e..dc38cbc 100644
--- a/BlockchainAssignment/BlockchainApp.Designer.cs
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -29,6 +29,8 @@
         private void InitializeComponent()
         {
             this.richTextBox1 = new System.Windows.Forms.RichTextBox();
+            this.printBlock = new System.Windows.Forms.Button();
+            this.blockIndex = new System.Windows.Forms.TextBox();
             this.SuspendLayout();
             // 
             // richTextBox1
@@ -41,24 +43,48 @@
             this.richTextBox1.TabIndex = 0;
             this.richTextBox1.Text = "";
             // 
+            // printBlock
+            // 
+            this.printBlock.Location = new System.Drawing.Point(12, 331);
+            this.printBlock.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);
+            this.printBlock.Name = "printBlock";
+            this.printBlock.Size = new System.Drawing.Size(79, 26);
+            this.printBlock.TabIndex = 1;
+            this.printBlock.Text = "Print Block";
+            this.printBlock.UseVisualStyleBackColor = true;
+            this.printBlock.Click += new System.EventHandler(this.button1_Click);
+            // 
+            // blockIndex
+            // 
+            this.blockIndex.Location = new System.Drawing.Point(95, 335);
+            this.blockIndex.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);
+            this.blockIndex.Name = "blockIndex";
+            this.blockIndex.Size = new System.Drawing.Size(72, 20);
+            this.blockIndex.TabIndex = 2;
+            // 
             // BlockchainApp
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.ActiveCaption;
             this.ClientSize = new System.Drawing.Size(681, 481);
+            this.Controls.Add(this.blockIndex);
+            this.Controls.Add(this.printBlock);
             this.Controls.Add(this.richTextBox1);
             this.ForeColor = System.Drawing.Color.Black;
             this.Name = "BlockchainApp";
             this.Text = "Blockchain App";
             this.Load += new System.EventHandler(this.Form1_Load);
             this.ResumeLayout(false);
+            this.PerformLayout();
 
         }
 
         #endregion
 
         private System.Windows.Forms.RichTextBox richTextBox1;
+        private System.Windows.Forms.Button printBlock;
+        private System.Windows.Forms.TextBox blockIndex;
     }
 }
 
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
index 81b84b3..cd1c1e5 100644
--- a/BlockchainAssignment/BlockchainApp.cs
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -7,18 +7,35 @@ using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
 using System.Windows.Forms;
+using static System.Windows.Forms.VisualStyles.VisualStyleElement;
 
 namespace BlockchainAssignment
 {
     public partial class BlockchainApp : Form
     {
+        /* Global Blockchain object - Our working blockchain */
+        Blockchain blockchain;
+
+        /* Initialize blockchain on startup of application UI */
         public BlockchainApp()
         {
             InitializeComponent();
+            blockchain = new Blockchain();
+            richTextBox1.Text = "New blockchain initialised!";
         }
 
         private void Form1_Load(object sender, EventArgs e)
         {
         }
+
+        // Duplicate the value input into our new textbox (textBox1) in the large "console" (richTextBox1)
+        private void button1_Click(object sender, EventArgs e)
+        {
+            if (Int32.TryParse(blockIndex.Text, out int index))
+                richTextBox1.Text = blockchain.getBlockAsString(index);
+            else
+                richTextBox1.Text = "Please enter a valid number";
+
+        }
     }
 }
diff --git a/BlockchainAssignment/BlockchainAssignment.csproj b/BlockchainAssignment/BlockchainAssignment.csproj
index a1fec3d..3c0fe85 100644
--- a/BlockchainAssignment/BlockchainAssignment.csproj
+++ b/BlockchainAssignment/BlockchainAssignment.csproj
@@ -46,6 +46,8 @@
     <Reference Include="System.Xml" />
   </ItemGroup>
   <ItemGroup>
+    <Compile Include="Block.cs" />
+    <Compile Include="Blockchain.cs" />
     <Compile Include="BlockchainApp.cs">
       <SubType>Form</SubType>
     </Compile>
diff --git a/Luke Wilson CS3BC Coursework.docx b/Luke Wilson CS3BC Coursework.docx
new file mode 100644
index 0000000..a636953
--- /dev/null
+++ b/Luke Wilson CS3BC Coursework.docx	
@@ -0,0 +1,3 @@
+
+
+

commit ecb2b9667f609033cd276f63339a9d6f86ab9a53
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Tue Feb 25 20:34:49 2025 +0000

    useful docs

diff --git a/1- Practical Exercises and Coursework Support.docx b/1- Practical Exercises and Coursework Support.docx
new file mode 100644
index 0000000..7cd41ea
--- /dev/null
+++ b/1- Practical Exercises and Coursework Support.docx	
@@ -0,0 +1,356 @@
+Blockchain Lab Practical Guided Exercises to Support the Coursework Assignment
+
+Introduction
+The goal of these practical sessions is to create an offline Blockchain application.  This application can be developed in a language of your choice, although it is highly recommended to use C#.  This brief operates on the assumption that C# is used and resources such as the template code are in C#. C# is an object-oriented language and is very similar to Java, and it should be relatively easy to pick up.  Visual Studio is the recommended IDE for developing in C#, the latest version can be found here [HYPERLINK: https://visualstudio.microsoft.com/vs/community/].
+Along with this brief you should find a visual studio project which will provide the template code for the assignment.  This code should be built upon during the practicals.  The template makes use of Windows Forms for the UI.  Windows Forms is simple and quick to use, meaning you can focus on the technical aspects more than the appearance.  This template also includes ready-made classes that will be used to develop features. 
+
+Practical Guided Exercises and Assignment
+It is expected that you will complete the first 5 parts of this brief during the practical sessions.  The assignment tasks are based on the application you will have made in the first 5 parts.  Marks for the assignment are allocated as follows:
+PROVISIONAL Marking Scheme (to be confirmed by way of formal Assignment Sheet to be notified by 12/01/21). 
+
+Evidence of implementation
+Report
+Total
+Part 1  -  Project Setup
+3
+2
+5
+Part 2  -  Blocks and the Blockchain
+5
+5
+10
+Part 3  -  Transactions and Digital Signatures
+5
+5
+10
+Part 4  -  Consensus Algorithms (Proof-of-Work)
+10
+10
+20
+Part 5 - Validation
+10
+10
+20
+Part 6  -  Assignment Tasks
+15
+20
+35
+
+48
+52
+(100)
+
+
+
+
+
+For each part in this brief, you are expected to provide evidence of implementation alongside a report which details your understanding of the topic. 
+In part 6 of the assignment, you are only expected to complete 3 out of 4 of the sections to achieve the maximum of 35 marks.  However, if you choose to do all four you may be able to score more marks (not more than 35).
+This brief will require students to develop a basic offline Blockchain application that includes the following:
+ Blockchain made of cryptographically connected Blocks
+ Transaction generation  -  including digital signature via asymmetric encryption
+ A Proof-of-Work consensus algorithm  -  including hashing and threading
+ Validation methods to ensure the Blockchain is valid
+ A basic UI that can verify the implementation of the above features
+The following instructions are built to ease you into programming with C# and Windows Forms and gradually get more complex throughout. 
+
+Part 1  -  Project Setup
+Setup
+Download the BlockchainAssignment Project from Blackboard. Open Visual Studio click open project/solution and select BlockchainAssignment.sln.  In the Solution explorer you will see the BlockchainAssignment.csproj.  Expand this to find the components of the project, including the code, references and properties.  For us, the important parts are the BlockchainApp.cs, HashCode folder, and Wallet folder. 
+Double click the BlockchainApp.cs to open a Windows Form, which shows the basic UI of the App. You are free to modify it during this assignment as you see fit but ensure that the results are clear (as you are required to provide screenshots in your report).  Right click BlockchainApp.cs and click view code to see the underlying code behind the UI.  Currently it is mostly empty.
+The HashCode and Wallet folders are host to ready-made code that will be applied later in this assignment.  Wallet is responsible for the asymmetric encryption (public and private key pairs) and digital signatures in transaction.  HashCode is responsible for combining hashes and converting hashes to and from byte arrays to strings both ways.  This code is provided to help reduce the workload of the project, such that time can be evenly distributed across each of the components.
+
+Customising the UI
+To familiarise yourself with Windows Forms and C# briefly add some functionality to the UI.  First add a button, on the left side of the screen a horizontal tab titled Toolbox should be visible.
+
+                                       
+Click Toolbox and a window will expand, click All Windows Forms or Common Controls and click and drag Button onto the UI.  Now search for a TextBox in the toolbox and drag it onto the UI.  Your UI should now appear as the following:
+
+                                       
+                                       
+Click button1 once to open its properties in the bottom left.  Change its text property to say `Print' instead of `button1'.  Now double click the button and you will be taken to the underlying code, a new function for clicking the button is created after double clicking it.    Next you can write some code that takes the text from the TextBox we added and prints it to the larger textbox above, when we click the Button.  To get the names of the Textboxes you can click them in the UI form, in this case the large black text box is richTextBox1 and the smaller text box is textBox1. 
+Code:
+                                       
+Output:
+                                       
+This textbox and button can be removed or re-purposed after this section as you wish.
+
+
+
+Part 2  -  Blocks and the Blockchain
+
+Creating the classes and their contents
+C# is an object-orientated language.  Therefore, it makes sense to exploit this with the object-orientated nature of Blockchain.  Right click BlockchainAssignmentAnswer.csproj and click add then new item.  Add a new class called Blockchain.cs and another class called Block.cs.  A Blockchain consists of a chain of blocks, so add a list variable into Blockchain.cs that holds Blocks. 
+
+                                       
+                              Blockchains.cs code
+The Blockchain itself needs to be initialised in the code.  You can initialise in it BlockchainApp.cs or initialise it in Program.cs (Main) and pass into the BlockchainApp.cs. 
+
+                                       
+                    Initialising blockchain within the form
+Now you can add variables into Block.cs.  Typically, a Block within a Blockchain would have many variables.  Many of these will be added throughout the duration of the assignment, so write the code carefully such that it can be easily changed at a later point.  For now, the following variables should be added to the Block class with appropriate types:
+ A timestamp, set when the Block is made
+ An index; the position of the Block within the Blockchain
+ Hash of the Block
+ Hash of the previous Block
+Now create a constructor for a new Block to assign these variables.  The constructor should have two arguments, the hash of the prior Block and the index of the prior Block.  Alternatively, you can pass the whole previous Block through (In this case you will need to set the access modifiers for the variables to public).  The timestamp should be set to the current time (current time can be retrieved using Datetime.Now), and the previous hash and current index should be set with respect to the given arguments.  Assignment of the hash of the Block will be covered in the next section.
+
+                                       
+                     A Constructor with one argument in C#
+
+Hashing and creating the Genesis Block 
+A genesis block is the first block of a block chain [HYPERLINK: https://en.bitcoin.it/wiki/Block_chain]. Modern versions of Bitcoin number it as block 0, though very early versions counted it as block 1
+We now need to generate a hash to finish the assignment of the variables in Block.cs.  First, we need to create a new method in Block.cs that will create the hash.  This method will also be extended as we require during the course of the assignment.
+                                       
+               An empty method in C# that should return a String
+
+The hash of a Block is normally the hash of all information within the Block.  Therefore, we want to combine the index, timestamp and previous hash and hash the combination.  The code displayed  below uses the SHA256 to produce a hash.  You can copy it into your CreateHash method. 
+SHA-256 and SHA-512 are novel hash functions computed with 32-bit and 64-bit words, respectively.
+https://emn178.github.io/online-tools/sha256.html
+SHA256 hasher;
+hasher = SHA256Managed.Create();
+String input = index.ToString() + timestamp.ToString() + prevHash;
+Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes((input)));
+
+String hash = string.Empty;
+
+foreach (byte x in hashByte)
+{
+   hash += String.Format("{0:x2}", x);
+}
+return hash;
+Finally, now assign the value of the hash variable in the constructor to the output of CreateHash()
+Now we have a constructor to create Blocks, but no methods that actually create them.  As stated, the first Block in a Blockchain has no previous hash and is called the Genesis Block.  To generate a Genesis Block we must create another constructor in Block.cs.  This constructor will have no arguments, it will assign the previous hash to an empty string and the index to 0. 
+Now do the following:
+ Create a constructor for Blockchain.cs 
+ This constructor calls the Genesis Block constructor in Block.cs.
+ The Genesis Block is then added to the Blockchains list of Blocks.
+Now a genesis Block should be created when the app is started.
+Tip: Debugging in C# is very easy and very useful.  You can place a breakpoint at any point in the code and view the state of variables and objects in real-time. 
+
+                                       
+        An example of debugging in C# that shows the contents of Blocks
+                 after the first Genesis Block has been added.
+
+Printing a Block to the UI
+Now that we have generated a Genesis Block we should verify this by displaying its variables to the UI.  To achieve this the following should be done.
+ Add a new method in Block.cs to return a string containing the Block index, previous hash, hash and timestamp.
+ Add a new method in Blockchain.cs that takes a Block index as an argument, then calls the above method in the chosen block and returns the output.
+Add a button in the UI that calls the Blockchain.cs method to read a given Block. Print this text to the large black text box. Tip: You can re-purpose the buttons you made earlier for this purpose.  Also, you may want to make a method dedicated to changing the text of richTextBox1, as you may be changing it frequently. 
+
+                                       
+                  The output of the Genesis Block  -  for now
+Note: You may notice that the hash is in hexadecimal meaning that each character in the hash can be one of 16 characters: 0-9 and A,B,C,D,E,F.  This is more relevant later when we focus on mining and proof-of-work. 
+
+Part 3  -  Transactions and Digital Signatures
+
+Wallets & Private and Public Key Generation
+Blockchain technology is capable of storing almost any type of data within the blocks; although typically Blockchains store a ledger of transactions.  Transactions on a Blockchain are a receipt of the movement of digital crypto-currency from one wallet to another.  This digital currency is generated through the consensus algorithm, which will be discussed in detail in  later section.  In this section we are interested in the generation of the wallets.  In Blockchain a wallet has two components, a private key and a public key.  A public key is public to all entities in a Blockchain, while a private key must be kept secret, as it gives the owner control of the wallet funds. 
+Public and Private Key Pairs are mathematically related to each other, but a private key cannot be solved (deciphered, decoded) simply by exploiting this relationship with the public key.  There exist many asymmetric encryption algorithms for the purpose of generating key pairs; in this assignment we will use the Elliptic Curve Digital Signature Algorithm (ECDSA).  This is the same algorithm that Bitcoin and other Crypto-currencies use, therefore we can consider our key generation to be cryptographically strong. 
+Within the folder Wallet, Wallet.cs can be found.  This class includes the code for key pair generation and validation.  Feel free to look at this code to familiarise yourself with its structure.  This code is provided for your convenience to free up your time to focus on and grasp the essential  framework.  process. 
+  The following methods are included:
+ Wallet(out String privateKey)  -  Constructor for a Wallet object. The Wallet object has one variable, public key. The private key is an output parameter. Example code of constructing a Wallet:
+
+      String privKey;
+      Wallet.Wallet myNewWallet = new Wallet.Wallet(out privKey);
+      String publicKey = myNewWallet.publicID;
+      Console.WriteLine(publicKey + "\n" + privKey);
+
+ ValidatePrivateKey(privateKey, publicID)  -  Returns true if private and public key are mathematically related. Returns false otherwise. 
+ CreateSignature(publicID, privateKey, data)  -  Digitally signs the given data using the private key given. Returns the digital signature.
+ ValidateSignature(publicID, data, digitalSig)  - Confirms that a given signature has been signed by a private key related to the given public key. Returns true/false.
+
+Most of these methods are static, meaning that they can be called without creating an instance of the Wallet object.  Next, we can  make use of this code in our Blockchain application; so let us go ahead as follows:
+ Add a new button to the UI that generates a new Wallet.
+ Add two new text boxes to the UI to display the public and private keys after a wallet has been generated.
+ Add labels to the UI to distinguish which key is public and private, respectively.
+ Add a button to validate the public and private keys present in the textboxes(Call the ValidatePrivateKey method to do this)
+Note: The public key is 64 characters, and the private key 32 characters. 
+                                       
+          An example of key pair generation with validation message.
+
+Setting up Transactions  
+Now that we have created wallets, we want to be able to send funds between them.  To achieve this, as mentioned previously we need to add transactions to the Blockchain.  First, we need to  develop a Transaction.cs class.   Next, we can add the appropriate variables you would expect to see in a Blockchain transaction.   You can consider an example of a transaction from Bitcoin [HYPERLINK: https://www.blockchain.com/btc/tx/14d79f57e2ca21150876bc6f23c03721b2d22f553330e0475ab38eca60f0c0ba].  From this example the following variables can be adopted  (implement them in Transaction.cs with appropriate types):
+ Hash  -  the hash of the transaction and its contents
+ Signature  -  the hash of the transaction signed with the private key of the sender
+ SenderAddress  -  the public key of the sender
+ RecipientAddress  -  the public key of the receiver
+ Timestamp  -  the time at which the transaction was made/sent
+ Amount  -  the amount of currency being sent to the receiver
+ Fee  -  the fee added to the transaction (this will be implemented later)
+Now create a constructor for transaction, it should accept arguments for the above variables and also the sender's private key, although you should exclude hash, signature and timestamp as the method will generate these.  The constructor should assign the arguments to their respective properties, then the timestamp should be set to current time. 
+The transaction should now have a sender, receiver, timestamp, amount, and fee.  We can use this information to generate the hash.  Take the code extract used in Part 2 to generate a SHA256 hash and adjust it to make a method to generate a transaction hash, then assign the hash with the result.
+Finally, you need to sign the hash with the sender's private key (this was supplied in the argument of the constructor).  You can generate a signature using the static method  of Wallet.cs   CreateSignature(), and provide the sender's address, their private key, and the hash of the transaction as arguments.
+Note: The private key should not be left in the memory of the transaction instance, so do not save it as a variable.
+
+Processing  Transactions & Transaction Pools
+Now that we have made the infrastructure for a transaction, we want to actually be able to generate and process transactions.  For this we can first generate a transaction and then display it to the UI.  This will require a new UI element; in particular: 
+ An `Amount to send' label and textbox
+ A `Fee' label and textbox
+ A `receiver address' label and textbox
+ A button to `send the transaction', once the above fields have been completed
+Note: You can re-use the private and public textboxes for this purpose.
+
+                                       
+                            New UI for transactions
+
+When the `Create Transaction' button is clicked the following should occur:
+ Amount, Fee, Public Key, Private Key, and Receiver Key fields are passed through to a new instance of Transaction
+ The Transaction is generated
+ The Transaction is printed to the UI large text box
+Tip: It could be useful to make a method in Transaction.cs that returns the contents of a transaction as a string.
+Note: Now is your chance to come up with the name of your own crypto-currency!
+
+                      Sending some `AssignmentCoins'
+
+Note: You may notice there are no checks in place currently to verify if the information being provided is valid.   For example, does the sender have the 10 AssignmentCoins to send?  -safeguarding against double-spend!  
+ We will add these checks in a later section, once  it is possible to check the balance of a wallet.
+We have successfully generated a transaction, but we are not yet able to process it so that the blockchain could show it recorded in the next update.    In Bitcoin when a transaction is created it is then processed by being shared with  the network and placed in a transaction pool which consists of transactions that are waiting to be added to the next block on the Blockchain.
+A transaction is not confirmed or considered valid until it has been added to the Blockchain.  Even then it is not always immediately accepted, some services that accept crypto-currency as payment require X number of confirmations.  A transaction has one confirmation when it is first added to the Blockchain; when the next block is added it has two confirmations.  Each additional block adds another confirmation.  Transactions are not accepted until they reach a threshold of confirmations to reduce the impact of forks and attacks on the Blockchain.  This is covered in more detail in the lectures.
+Our Blockchain is offline, so we do not need to worry about sharing it to the network.  However, we should still place it in a transaction pool with other transactions while it is waiting to be added to the Blockchain.  Now we can create a place to store pending transactions by adding a list of transactions to Blockchain.cs class called `transactionpool' or `pendingtransactions'. 
+Now when we generate a transaction, we can add it to the transaction pool, so it is ready to be added to the Blockchain.
+
+Part 4  -  Consensus Algorithms (Proof-of-Work)
+Generating new Blocks
+Your application should now be able to generate transactions and generate a genesis block.  One Block on its own is not a Blockchain, therefore we need to generate some more blocks.   We can add a button to the UI with the purpose of generating a new Blocks.  When you click this button, it should call the Block constructor and pass it the variables from the previous block.  Once this new Block has been generated, you can add it to the Blockchain (the List<Blocks> variable in Blockchain.cs).  Now you can update the UI with the contents of the Block. 
+Tip: It may be useful to create a GetLastBlock method in Blockchain.cs to get the latest block on the chain.  This method can be as simple as return blocks[blocks.Count - 1]; Also ensure that the list of Blocks in Blockchain.cs is public or at least there is a public method to add new blocks to the list. 
+
+                                       
+The second block  -  connected to the prior Genesis Block through reference to its previous hash
+
+If you have not already done so, you can now add a method or button to read all Blocks from the Blockchain and write them to the large text box.
+                                       
+           Read All button displaying the 4 blocks within the chain
+
+Adding transactions into Blocks
+We will now make use of the transaction pool that we created earlier.  Blocks should carry transactions within them.    We can examine this by first adding a new data field to Block.cs  -  transactionList, which should contain transactions.  When a new Block is generated it should be accompanied with transactions from the transaction pool.  You can write some code to add transactions from the transaction pool to newly generated Blocks (This should occur during the Block generation process  -  before the hash is generated).  Please make sure that the constructor of the Block is changed to accept a list of transactions in the arguments.  We will edit the hashing mechanism in the Block later to consider transactions (by adding the "Merkle root").
+Note: Blocks cannot take an infinite number of transactions from the transaction pool, you can add a reasonable finite limit to the number of transactions that each block can take (such as 5). 
+Note: Ensure that transactions picked from the transaction pool are removed once the new block is added to the chain.  You may find the following line helpful: 
+transactionPool = transactionPool.Except(chosenTransactions).ToList();
+Now you can edit the Read function of Block to print out the contents of transactions within the Block.
+Tip: Making use of a foreach loop in the Read code can make this task easier.  See below.
+
+foreach (Transaction t in transactions)
+            {
+                output += "\n" + t.ReadTransaction();
+            }
+Tip: It may be useful to add a button to read all transactions in the pool, to ensure that the code is working as intended.
+                                       
+                    Newly mined Block with two transactions
+
+Proof-of-Work
+In an online Blockchain which is distributed across nodes in a peer-2-peer network, the nodes must reach a consensus on how the next Block should be added to the chain.  In Bitcoin and other existing Crypto-currencies, Proof-of-Work is used.  Proof-of-Work dictates that for a new Block to be added to the chain, this Block must have a hash that satisfies a given difficulty threshold.  In Proof-of-Work nodes compete to create a Block that satisfies this difficulty threshold in the shortest time Consider the example below where the difficulty threshold is set as 2.
+ A Blockchain node has generated a new Blockchain, however they cannot add it to the chain until the hash begins with a number of zeros corresponding to the difficulty threshold. (Difficulty = 2, therefore number of zeros required = 2).
+ The node generates a hash of - 57169c0619650ff122a8d74776e74a5e6b6e8e517aea48579b2be0af19440488 for the block using the block attributes.
+ This hash does not satisfy the difficulty threshold, a new hash must be  generated based on this hash  (re-hash).  ; However hashing algorithms such as SHA256 always generate the same hash given the same input.  To generate a non-identical hash the Block has an extra data property  -  nonce (number only used once).  This nonce value is incremented after each hash attempt until the resulting hash satisfies the difficulty threshold. 
+ So, the Blockchain node increments the nonce and rehashes until the difficulty threshold is met.  Finally, the following hash is generated that satisfies the threshold: 008a78f40bb59bf4c9da8cfccf6a9c8e1202b01933d2363eabb277ad867ba738
+ The winning node having achieved the difficulty in shortest time then goes on to  shares the Block with  the other nodes on the network, these nodes accept the new Block and add it to their identical copies of the Blockchain.  In this way the blockchain as universal record of transactions is kept updated.
+To implement Proof-of-Work within  our example Blockchain we need to add a new data property to Block.cs  -  nonce (set it to 0 by default) and set a global difficulty threshold float that must be satisfied. We recommend selecting a difficulty threshold of either 4, or 5. 
+With the above complete, to create the Proof-of-Work algorithm the following must be implemented:
+ Include the nonce in the CreateHash() method such that it is included in the process of the composition of the hash.
+ Create a new method Mine() that executes the CreateHash() method within a while loop, which continues until the given hash starts with a number of zeros correlating to the difficulty. 
+ Change the Block.cs constructor to call Mine() instead of CreateHash().
+ Increment the nonce after each failed hashing attempt.  Do not increment the nonce after the process has already resulted in a hash that has satisfied the difficulty criteria.  
+ Change the Read() method in Block.cs to also return the last value of nonce and the difficulty level the Block was mined at.
+Note: If you implemented this incorrectly your code could get stuck in a while loop.  Making use of debug mode (and reducing the difficulty) may help you investigate this problem.
+
+                                       
+                    Three Blocks mined at a difficulty of 4
+
+Difficulty (Level) 
+The difficulty level as set in Proof-of-Work is proportional to   the number of zeros at the beginning of the hash that constitute a valid block.  The more zeros required there, the longer it will take to mine.  SHA256 represents characters in hex format; meaning each character can be 1 of 16 different characters. Therefore, each extra zero required to mine in Proof-of-Work increases the difficulty by a factor of 16.  For now, we are using a fixed difficulty of 4 or 5 zeros (up to you) at the beginning of the hash. Later however we will discuss the topic of a dynamic difficulty (which is why the data type of difficulty is float). 
+For this section, the only action you need to take is to include the  difficulty to the hash composition used in CreateHash().
+Rewards & Fees
+If we take a random Block from Bitcoin [HYPERLINK: https://www.blockchain.com/btc/block/661933] and look at the number of zeros required, we can see that 19 zeros were required.  The chance of generating a hash that begins with 19 zeros is 1/1619.  This requires a huge amount of work to be done to generate a Block.  Nodes all over the world compete to be the next one to generate a Block FIRST.  Specialist computation hardware and much electricity is required to even have a slim chance of being the next node to mine a Block.  Right now, in our Blockchain there is no incentive for nodes to mine, other than to get their transaction on the chain.  In Bitcoin and other Proof-of-Work crypto-currencies the incentive comes in the form of a reward and 
+fees. 
+After each Block is mined in Bitcoin, a flat reward is given to the winning miner's address.  This reward is given as a transaction; the receiver address is the mining node address and the sending node is technically from nowhere (as the currency is generated there and then).  In Bitcoin the sender's address is `Coinbase', which is simply the terminology to refer to currency generated as a reward.  In our implementation the sender's address should be `Mine Rewards' (because Wallet.cs is configured for reward currency to be sent from `Mine Rewards'.  You can change this if you reconfigure Wallet.cs too).  You can set the reward amount to any number you wish; you can even add conditions to the way rewards are PAID if you wish.  For example in Bitcoin, rewards are halved every 210,000 blocks; as a result only a finite amount in Bitcoins will ever exist. 
+Fees are a small sum added to each transaction to incentivise the mining node to choose their transaction in the next Block.  The higher the fee, the more likely the node will pick it.  When the node successfully mines a Block, they receive a flat reward and the accumulative fees from all transactions in the Block.  As we have already implemented fees in our transactions, we are ready to implement rewards and fees to mining nodes. 
+To implemented fees and rewards we need to do the following:
+ Add the logic for rewards; it can be fixed, variable, anything you decide.
+ Update the UI code; such that the public address for the miner is sent through to the Block constructor.
+ Before we start mining the Block, we need to add all new transaction to the transaction list ( the pool) used by Block .t.  In the constructor of the Block add a new method (before Mine() is called) this method will calculate the reward and total fees owed (from all the transactions in the Block) and create a transaction for it.
+ Create this new transaction using the following line of code: 
+ Transaction transaction = new Transaction("Mine Rewards", minerAddress, (reward + fees), 0,"")
+ Wallet.cs is configured to deal with `Mine Rewards' so a private key does not need to be provided.
+ Now add this new transaction to the transaction list in the Block.
+ Add the reward to the hash composition used in CreateHash()
+ Finally update the read method of Block.cs  to print the reward, fees, and the miner's address {wallet).
+ 
+
+                                       
+       Block with rewards implemented. Miner gets a reward of 25.001; 25
+        from the reward and 0.001 from fees in the Blocks transactions.
+
+At this point we have successfully created an offline Blockchain.  We have a consensus algorithm, a Blockchain, and can create transactions and get them published on the chain.  However, we have not added any validation methods along the way.  The next part covers validation and how we can prevent malicious actors from attacking the chain by utilising what we have already implemented.
+
+Part 5  -  Validation
+A Blockchain is normally hosted by many nodes in a peer-2-peer network.  By definition being a trustless network, it is impossible to trust any node in the system, as they could be malicious.  Therefore, instead of trusting the other nodes, you must trust the system.  So far, we have developed a system that can generate digital keys, generate transactions with signatures, and generate and add Blocks to the Blockchain.  However, we have no/minimal checks along the way to validate the Blockchain.  The following section will highlight the areas that need validation and checks to ensure that the Blockchain is operating as intended, with no incorrect or malicious activity. 
+Validating the Blockchain Structure
+As we already know, Blockchain is a linear structure of connected Blocks.  The component that `connects' the Blocks is the reference to the hash of the previous Block.  We should validate that the Blocks are properly connected, by checking that each Block correctly refer to the hash of the previous Block (Block Coherence, Contiguity) 
+We can now  include a new button within  the UI that will perform full validation of the Blockchain.  For now, you can make a method that iterates through the Blocks in the chain and checks the hashes of each block with its previous block to see if they match.  This is so   that  each previous hash reference matches the hash of its  previous block (the block that immediately preceded it; came just before it in the chain) If all Blocks pass (match their respective precursor block) , then this method must return a success message; otherwise return a failure message.   
+Checking and Validating Balance
+So far, we  have had no way to check the balance of a wallet, and we do not have checks before transactions are made to see if a wallet can afford to spend the funds needed to be sent to another wallet for  given transaction.   We can include another button in the UI that checks the balance of a given wallet and include further checks within  the transaction generation logic to ensure that the sender has sufficient funds before a transaction can be permitted to proceed.  
+(Remember currency is generated through mining so all wallets start with zero)  
+Tip: You will need to create code that goes through all Blocks and searches for transactions involving the wallet you are checking. 
+
+                                       
+          Check balance showing the balance of an address along with
+              the transactions in which the address was involved.
+
+Validating Blocks & Merkle Root
+So far, we have had have no verification method in the Blocks to check if the transactions within it have been tampered with   Merkle root is a scalable and efficient method to encode data on the Blocks in an efficient manner. We can use the Merkle root algorithm to encode the transactions within a Block to a single hash. You can now include a new data field within Block.cs, as merkleRoot. We can include a new method within Block.cs to calculate the Merkle root too. 
+The Merkle root algorithm combines the hashes of multiple transactions iteratively, until only one resulting hash remains after the hash of the latest block has been included.  Consider the following example for how Merkle root is implemented:
+ A Block has five transactions within: T1, T2, T3, T4, and T5.
+ The hash of T1 and T2 are combined to make H1,2
+ The hash of T3 and T4 are combined to make H3,4
+ The hash of T5 is left untouched for now to make H5
+ Now the hashes H1,2 and H3,4 are combined to make H1,2,3,4
+ Finally, the hashes H1,2,3,4 and H5 are combined to make H1,2,3,4,5
+ H1,2,3,4,5 is the final hash, and therefore it is the Merkle root.
+Now implement the Merkle root method in code.  To help with  this task you can  make use of HashTools.cs made available for you in the HashCode folder.  Use the method 
+combineHash(hash1,hash2) to combine the hashes of transactions.
+Tip: It may be useful to make the Merkle root algorithm static, as it will be useful for verification.
+Once the Merkle root algorithm and assignment are completed, Include the Merkle root validation with  the validation method you made earlier.  (Please do not forget to include the Merkle root within  the Read() method in Block.cs)
+We do not just perform comparison of the  hash of the  Blocks for the purpose of Proof-of-Work [i.e.to check if a miner has submitted a block that is i) carries the content of all previous blocks and  ii) satisfies the difficulty level, iii) has included all the  transactions] we also use it to ensure that none of the data in a Block has been tampered with.  As hashing algorithms always create the same hash given the same input, we can rehash the contents of a Block and compare the result with which hash ? to check  that the provided hash for the Block matches the combinatorial hash of all the previous blocks (their Merkle root.  If the hashes do not match, then it is likely that some data in some  Block(s) has been tampered with.  If this happens the entire Block has to be  rejected.   So now we need to include this facility within our   full Blockchain validation method, to check if the hash of a Block submitted by a miner does match the expected reference hash (who computed that, can they be trusted, who validates them? )  indeed hash provided is correct. 
+Finally we can include the merkleRoot data property within the SHA256 hashing method that generates a Block hash.  This means if any transactions have been tampered with, then the Merkle Root will be different from what? , and as a result the hash of the Block will be wrong.
+Validating Transactions
+Similarly to the last section, here we can include checks within the validation method to recalculate the hash of the transactions  to  arrive at the hash of a given block and compare it with   a given hash of transaction within a submitted block.  In addition to this we can also   include logic to verify the signature provided in the transaction, to check to see that i the transaction has been signed off with the correct private key i.e. to authenticate the person making the transaction .  For this purpose, Wallet.cs has a verification method that you can make use of: ValidateSignature(publicKey, hash, signature).
+Testing the validation
+You can test the validation methods that you have implemented in various ways.  For example you can  try some of the following steps 
+ Sending a transaction with  address that does not have enough funds to support it
+ Sending a transaction and providing an invalid private key
+ Creating  a button/method that generates invalid Blocks with incorrect features  -  e.g. wrong previous hash, wrong hash, invalid transactions within the block.
+
+Part 6  -  Assignment Tasks
+This part will consist of 4 sections, to earn full marks for implementation (15) in this part of the assignment you only need to include in your submission correct implementations of three out of four of these sections. T
+This part carries 35 marks overall, 15 for implementation and 20 for report.  You can earn the full 20 marks for the report section if you only implement three sections. However you may be able to pick up lost marks due to incomplete implementation of any three  if you choose to implement all four (You cannot score more than 35 for this section). 
+Research and reference to other Blockchain implementations is valued highly for this section, especially if you incorporate  their logic into your solution.
+Threading during Proof-of-Work
+Currently when a node performs Proof-of-Work to find a hash to satisfy the difficulty, only one core in the CPU is working, the rest are idle.  
+ Extend the Proof-of-Work algorithm to parallelize this task such that multiple threads are in use.  For the report, document the implementation and prove that there is a performance efficiency gain when using multiple threads as opposed to one 
+Hint: Take multiple samples of mining times and compare them; make use of 
+system.Diagnostics.Stopwatch). 
+Do not forget to consider the fact that threads may repeat work (hashing the same data and creating hashes that have already been generated).  Provide a solution to this problem and explain in the report how it prevents work from being repeated.
+Tip: The following C# resources may help implementation: Callbacks/Delegates [HYPERLINK: https://docs.microsoft.com/en-us/dotnet/api/system.func-2?view=net-5.0] and Threading [HYPERLINK: https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-5.0].  If you have problems updating the UI using threads the following line may be useful: 
+textBox1.Invoke(new Action(() => textBox1.Text += message))
+
+Adjusting the Difficulty Level in Proof-of-Work
+As previously mentioned in this brief, the difficulty level is a static type right now and so does not change from Block to Block.  In existing Blockchain (Proof-of-Work) implementations a dynamic difficulty level is used.  In Proof-of-Work crypto-currencies `Block Time' is considered the average amount of time required until the next Block is added to the chain.  In Bitcoin this is 10 minutes and in Ethereum this is 10-20 seconds. 
+  Decide your own `Block time' (with justification in the report) and implement an adaptive  difficulty level algorithm.  Prove that the implementation works in the report and discuss how you developed  your solution for your implementation. 
+Note: In our current implementation increasing the difficulty by one would increase the amount of work by a factor of 16.  This is not suitable for dynamic difficulty level setting.  You would need to consider another approach;  you may wish to review the existing approaches. 
+In your report, please detail how you developed your implemented dynamic difficulty level and why you chose a particular  approach while also providing evidence that it works.  Also state what the duration of your `Block Time' was and justify why. 
+
+Mining Settings 
+Currently, when Blocks are added to the chain, they pick transactions from the transaction pool arbitrarily.  In reality, there are many ways that a node may wish to pick transactions from the pool. They may wish to be altruistic and pick the transactions that have been waiting the longest.  They may wish to be greedy and pick the transactions with the largest fees.  They may wish to be unpredictable and pick entirely randomly.  They may have their own transactions pending and choose to pick up transactions involving their address first. 
+ Implement a setting within the UI  to enables the node to decide how it wishes to pick transactions from the pool.  Include "Greedy" (highest fee first), "Altruistic" (longest wait first), "Random" and Address Preference. 
+In your report discuss what you believe would be the optimal setting to choose and why.  Also discuss how to choose to implement the settings and provide evidence that each setting works. 
+
+Your own idea
+ You are welcome, within the scope of this work,  to come up with your own extension/change to add to the application.  This change cannot be trivial and should take a similar amount of implementation time to the other 3 sections. Some ideas, for example include:
+
+ The  implementation of a different consensus algorithm (Proof-of-Stake), 
+ Creating multiple nodes running in a local network, automating  the generation of transactions,
+ Smart contracts (if you are really ambitious). 
+You will need to justify your choice to add any  extension to the application, document your implementation and provide proof that it works as intended. 
+
+                 ********************************************
diff --git a/Assignment Starter.docx b/Assignment Starter.docx
new file mode 100644
index 0000000..4d2f5b4
--- /dev/null
+++ b/Assignment Starter.docx	
@@ -0,0 +1,17 @@
+
+Task 1: Exploiting a threading capability for proof of work 
+Each thread needs to have its own nonce to do its mining in parallel trying to get to arrive at a string with the right number of zeros preceding the hash of the block, but each threat needs to use its own nonce to avoid duplication of results ...  we have said there is such a thing as an "enonce"  (extra nonce), and each thread could have its extra nonce assigned i.e. own distinct one-time-token (number) to keep incrementing to use in each cycke of mining  - enonce( type long). In this way as a distinct number shall be used for each enonce of each threat in each cycle of hash composition, no duplicated effort could occur.
+=====================================================================================================================================================================================================================================================================
+
+Task 2: Adjusting the Difficulty Level in Proof-of-Work  
+In our current implementation increasing the difficulty by one would increase the amount of work by a factor of 16. This is not suitable for a dynamic difficulty. You are going to need to think of another approach, consider researching  existing approaches. 
+In your report, please detail how you implemented dynamic difficulty and why you chose that approach while also providing evidence that it works. Also mention the length of your `Block Time' and justify why. 
+Note: Any `Block Time'/implementations is OK as long as you feel it has been fairly justified (and it works).
+=====================================================================================================================================================================================================================================================================
+
+Task 3: Selection of Transactions to Mine 
+A Miner may consider picking the transaction with lowest fees which tend to be also amongst the ones that  may have been waiting to be mined the longest  (Altruistic Approach)  or picking the largest transactions with the largest fees first as most Miners tend to go for as the most profitable approach (Greedy Approach).  You will be able to add buttons for each of the above approaches to select the transactions according to the Miner's Approach  - your approach as you wish but you need to reflect on the side-effects of an approach on the Blockchain as a whole....     
+=====================================================================================================================================================================================================================================================================
+
+Task 4: up to you to choose instead of any one of the three tasks above or in combination if you would like to submit 4 task  -  max available mark is 35 which can be obtained with reasonably complete solutions to the three tasks set. 
+=====================================================================================================================================================================================================================================================================
diff --git a/Blockchain Build Cookbook (2).pptx b/Blockchain Build Cookbook (2).pptx
new file mode 100644
index 0000000..64c437f
Binary files /dev/null and b/Blockchain Build Cookbook (2).pptx differ
diff --git a/Blockchain Code Highlighted Presentation.pptx b/Blockchain Code Highlighted Presentation.pptx
new file mode 100644
index 0000000..7ebe171
Binary files /dev/null and b/Blockchain Code Highlighted Presentation.pptx differ
diff --git a/CS3BC -Practical_Exercises & CourseWork_Support- 2025-AB(1).pdf b/CS3BC -Practical_Exercises & CourseWork_Support- 2025-AB(1).pdf
new file mode 100644
index 0000000..e5a9247
--- /dev/null
+++ b/CS3BC -Practical_Exercises & CourseWork_Support- 2025-AB(1).pdf	
@@ -0,0 +1,781 @@
+Blockchain Lab Practical Guided Exercises
+to Support the Coursework Assignment
+
+Contents
+Introduction ............................................................................................................................................ 1
+
+   Practical Guided Exercises and Assignment........................................................................................ 1
+Part 1 – Project Setup ............................................................................................................................. 2
+
+   Setup ................................................................................................................................................... 2
+   Customising the UI .............................................................................................................................. 2
+Part 2 – Blocks and the Blockchain ......................................................................................................... 4
+   Creating the classes and their contents.............................................................................................. 4
+   Hashing and creating the Genesis Block ............................................................................................. 5
+   Printing a Block to the UI .................................................................................................................... 6
+Part 3 – Transactions and Digital Signatures .......................................................................................... 8
+   Wallets & Private and Public Key Generation..................................................................................... 8
+   Setting up Transactions....................................................................................................................... 9
+   Processing Transactions & Transaction Pools...................................................................................10
+Part 4 – Consensus Algorithms (Proof-of-Work)................................................................................... 12
+   Generating new Blocks ..................................................................................................................... 12
+   Adding transactions into Blocks........................................................................................................13
+   Proof-of-Work ................................................................................................................................... 14
+   Difficulty (Level) ................................................................................................................................ 15
+   Rewards & Fees.................................................................................................................................15
+Part 5 – Validation.................................................................................................................................18
+   Validating the Blockchain Structure..................................................................................................18
+   Checking and Validating Balance ...................................................................................................... 18
+   Validating Blocks & Merkle Root ...................................................................................................... 19
+   Validating Transactions.....................................................................................................................20
+   Testing the validation........................................................................................................................ 20
+Part 6 – Assignment Tasks .................................................................................................................... 20
+   Threading during Proof-of-Work ...................................................................................................... 20
+   Adjusting the Difficulty Level in Proof-of-Work ................................................................................ 21
+   Mining Settings ................................................................................................................................. 21
+
+      Your own idea ............................................................................................................................... 21
+Introduction
+
+The goal of these practical sessions is to create an offline Blockchain application. This application can
+be developed in a language of your choice, although it is highly recommended to use C#. This brief
+operates on the assumption that C# is used and resources such as the template code are in C#. C# is
+an object-oriented language and is very similar to Java, and it should be relatively easy to pick up.
+Visual Studio is the recommended IDE for developing in C#, the latest version can be found here.
+
+Along with this brief you should find a visual studio project which will provide the template code for
+the assignment. This code should be built upon during the practicals. The template makes use of
+Windows Forms for the UI. Windows Forms is simple and quick to use, meaning you can focus on the
+technical aspects more than the appearance. This template also includes ready-made classes that will
+be used to develop features.
+
+Practical Guided Exercises and Assignment
+
+It is expected that you will complete the first 5 parts of this brief during the practical sessions. The
+assignment tasks are based on the application you will have made in the first 5 parts. Marks for the
+assignment are allocated as follows:
+
+Table 1: Marking Scheme
+
+Part 1 – Project Setup                            Evidence of      Report      Total
+Part 2 – Blocks and the Blockchain             implementation
+Part 3 – Transactions and Digital Signatures   3               2           5
+Part 4 – Consensus Algorithms (Proof-of-Work)  5               5           10
+Part 5 – Validation                            5               5           10
+Part 6 – Assignment Tasks                      10              10          20
+                                               10              10          20
+                                               15              20          35
+                                               48              52          (100)
+
+For each part in this brief, you are expected to provide evidence of implementation alongside a report
+which details your understanding of the topic.
+
+In part 6 of the assignment, you are only expected to complete 3 out of 4 of the sections to achieve
+the maximum of 35 marks. However, if you choose to do all four you may be able to score more marks
+(not more than 35).
+
+This brief will require students to develop a basic offline Blockchain application that includes the
+following:
+
+    • Blockchain made of cryptographically connected Blocks;
+    • Transaction generation – including digital signature via asymmetric encryption;
+    • A Proof-of-Work consensus algorithm – including hashing and threading;
+    • Validation methods to ensure the Blockchain is valid;
+    • A basic UI that can verify the implementation of the above features.
+
+The following instructions are built to ease you into programming with C# and Windows Forms and
+gradually get more complex throughout.
+
+                                                                                      1
+Part 1 – Project Setup
+
+Setup
+
+Download the BlockchainAssignment Project from Blackboard (Available here: Blockchain and
+Security → Teaching Materials → Week 1 – Introduction to Blockchain → Practical’s and Supporting
+Materials → Blockchain Project (Zip)). Open Visual Studio click open project/solution and select
+BlockchainAssignment.sln. In the Solution explorer you will see the BlockchainAssignment.csproj.
+Expand this to find the components of the project, including the code, references, and properties. For
+us, the important parts are the BlockchainApp.cs, HashCode-, and Wallet- folders.
+Double click the BlockchainApp.cs to open a Windows Form, which shows the basic UI of the App. You
+are free to modify it during this assignment as you see fit but ensure that the results are clear (as you
+are required to provide screenshots in your report). Right click BlockchainApp.cs and click view code
+to see the underlying code behind the UI. Currently it is mostly empty.
+The HashCode and Wallet folders are host to ready-made code that will be applied later in this
+assignment. Wallet is responsible for the asymmetric encryption (public and private key pairs) and
+digital signatures in transaction. HashCode is responsible for combining hashes and converting hashes
+to and from byte arrays to strings both ways. This code is provided to help reduce the workload of
+the project, such that time can be evenly distributed across each of the components.
+
+Customising the UI
+
+To familiarise yourself with Windows Forms and C# briefly add some functionality to the UI. First add
+a button, on the left side of the screen a horizontal tab titled Toolbox should be visible.
+
+Click Toolbox and a window will expand, click All Windows Forms or Common Controls, and click and
+drag Button onto the UI. Now search for a TextBox in the toolbox and drag it onto the UI. Your UI
+should now appear as the following:
+
+                                                                                                                          2
+Click button1 once to open its properties in the bottom left. Change its text property to say ‘Print’
+instead of ‘button1’. Now double click the button and you will be taken to the underlying code, a new
+function for clicking the button is created after double clicking it. Next you can write some code that
+takes the text from the TextBox we added and prints it to the larger textbox above, when we click the
+Button. To get the names of the Textboxes you can click them in the UI form, in this case the large
+black text box is richTextBox1 and the smaller text box is textBox1.
+Code:
+
+Output:
+
+     Note: This textbox and button can be removed or re-purposed after this section as you wish.
+
+                                                                                                                          3
+Part 2 – Blocks and the Blockchain
+
+Creating the classes and their contents
+
+C# is an object-orientated language. Therefore, it makes sense to exploit this with the object-
+orientated nature of Blockchain. Right click BlockchainAssignment.csproj and click add then new item.
+Add a new class called Blockchain.cs and another class called Block.cs. A Blockchain consists of a chain
+of blocks, so add a list variable into Blockchain.cs that holds Blocks.
+
+                                                               1: Blockchain.cs code
+
+The Blockchain itself needs to be initialised in the code. You can initialise in it BlockchainApp.cs or
+initialise it in Program.cs (Main) and pass into the BlockchainApp.cs.
+
+                                                   2: Initialising blockchain within the form
+
+Now you can add variables into Block.cs. Typically, a Block within a Blockchain would have many
+variables. Many of these will be added throughout the duration of the assignment, so write the code
+carefully such that it can be easily changed at a later point. For now, the following variables should
+be added to the Block class with appropriate types:
+
+    • A timestamp, set when the Block is made
+    • An index; the position of the Block within the Blockchain
+    • Hash of the Block
+    • Hash of the previous Block
+
+                                                                                                                          4
+Now create a constructor for a new Block to assign these variables. The constructor should have two
+arguments, the hash of the prior Block and the index of the prior Block. Alternatively, you can pass
+the whole previous Block through (In this case you will need to set the access modifiers for the
+variables to public). The timestamp should be set to the current time (current time can be retrieved
+using Datetime.Now), and the previous hash and current index should be set with respect to the given
+arguments. Assignment of the hash of the Block will be covered in the next section.
+
+                                                  3: A Constructor with one argument in C#
+
+Hashing and creating the Genesis Block
+
+A genesis block is the first block of a block chain. Modern versions of Bitcoin number it as block 0,
+though very early versions counted it as block 1
+We now need to generate a hash to finish the assignment of the variables in Block.cs. First, we need
+to create a new method in Block.cs that will create the hash. This method will also be extended as w
+required during the course of the assignment.
+
+                                           4: An empty method in C# that should return a String
+
+The hash of a Block is normally the hash of all information within the Block. Therefore, we want to
+combine the index, timestamp and previous hash and hash the combination. The code displayed
+below uses the SHA256 to produce a hash. You can copy it into your CreateHash method.
+SHA-256 and SHA-512 are novel hash functions computed with 32-bit and 64-bit words, respectively.
+https://emn178.github.io/online-tools/sha256.html
+
+SHA256 hasher = SHA256Managed.Create();
+String input = index.ToString() + timestamp.ToString() + prevHash;
+Byte[] hashByte = hasher.ComputeHash(Encoding.UTF8.GetBytes(input));
+String hash = string.Empty;
+foreach (byte x in hashByte)
+
+           hash += String.Format("{0:x2}", x);
+return hash;
+
+Finally, now assign the value of the hash variable in the constructor to the output of CreateHash().
+Now we have a constructor to create Blocks, but no methods that create them. As stated, the first
+Block in a Blockchain has no previous hash and is called the Genesis Block. To generate a Genesis
+Block we must create another constructor in Block.cs. This constructor will have no arguments, it will
+assign the previous hash to an empty string and the index to 0.
+
+                                                                                                                          5
+Now do the following:
+    • Create a constructor for Blockchain.cs
+    • This constructor calls the Genesis Block constructor in Block.cs.
+    • The Genesis Block is then added to the Blockchains list of Blocks.
+
+Now a genesis Block should be created when the app is started.
+Tip: Debugging in C# is very easy and very useful. You can place a breakpoint at any point in the code
+and view the state of variables and objects in real-time.
+
+                                  5: An example of debugging in C# that shows the contents of Blocks
+
+Printing a Block to the UI
+
+Now that we have generated a Genesis Block, we should verify this by displaying its variables to the
+UI. To achieve this the following should be done.
+
+    • Add a new method in Block.cs to return a string containing the Block index, previous hash,
+         hash and timestamp.
+
+    • Add a new method in Blockchain.cs that takes a Block index as an argument, then calls the
+         above method in the chosen block and returns the output.
+
+Add a button in the UI that calls the Blockchain.cs method to read a given Block. Print this text to the
+large black text box. Tip: You can re-purpose the buttons you made earlier for this purpose. Also,
+you may want to make a method dedicated to changing the text of richTextBox1, as you may be
+changing it frequently.
+
+                                                                                                                          6
+                                              6: The output of the Genesis Block – for now
+
+Note: You may notice that the hash is in hexadecimal meaning that each character in the hash can
+  be one of 16 characters: 0-9 and A-F. This is more relevant later when we focus on mining and
+                                                   proof-of-work.
+
+                                                                                                                        7
+Part 3 – Transactions and Digital Signatures
+
+Wallets & Private and Public Key Generation
+
+Blockchain technology can store almost any type of data within the blocks, although typically
+Blockchains store a ledger of transactions. Transactions on a Blockchain are a receipt of the movement
+of digital crypto-currency from one wallet to another. This digital currency is generated through the
+consensus algorithm, which we will be discussed in detail in later section. In this section we are
+interested in the generation of the wallets. In Blockchain a wallet has two components, a private key
+and a public key. A public key is public to all entities in a Blockchain, while a private key must be kept
+secret, as it gives the owner control of the wallet funds.
+
+Public and Private Key Pairs are mathematically related to each other, but a private key cannot be
+solved (deciphered, decoded) simply by exploiting this relationship with the public key. There exist
+many asymmetric encryption algorithms for the purpose of generating key pairs; in this assignment
+we will use the Elliptic Curve Digital Signature Algorithm (ECDSA). This is the same algorithm that
+Bitcoin and other Crypto-currencies use, therefore we can consider our key generation to be
+cryptographically strong.
+
+Within the folder Wallet, Wallet.cs can be found. This class includes the code for key pair generation
+and validation. Feel free to look at this code to familiarise yourself with its structure. This code is
+provided for your convenience to free up your time to focus on and grasp the essential framework.
+process.
+
+ The following methods are included:
+
+    • Wallet(out String privateKey) – Constructor for a Wallet object. The Wallet object has one
+         variable, public key. The private key is an output parameter. Example code of constructing a
+         Wallet:
+
+                       String privKey;
+                       Wallet.Wallet myNewWallet = new Wallet.Wallet(out privKey);
+                       String publicKey = myNewWallet.publicID;
+                       Console.WriteLine(publicKey + "\n" + privKey);
+
+    • ValidatePrivateKey(privateKey, publicID) – Returns true if private and public key are
+         mathematically related. Returns false otherwise.
+
+    • CreateSignature(publicID, privateKey, data) – Digitally signs the given data using the private
+         key given. Returns the digital signature.
+
+    • ValidateSignature(publicID, data, digitalSig) - Confirms that a given signature has been signed
+         by a private key related to the given public key. Returns true/false.
+
+Most of these methods are static, meaning they can be called without creating an instance of the
+Wallet object. Next, we can make use of this code in our Blockchain application; so, let us go ahead
+as follows:
+
+    • Add a new button to the UI that generates a new Wallet.
+    • Add two new text boxes to the UI to display the public and private keys after a wallet has been
+
+         generated.
+    • Add labels to the UI to distinguish which key is public and private, respectively.
+    • Add a button to validate the public and private keys present in the textboxes (Call the
+
+         ValidatePrivateKey method to do this)
+
+                 Note: The public key is 64 characters, and the private key 32 characters.
+
+                                                                                                                          8
+                                     7: An example of key pair generation with validation message.
+
+Setting up Transactions
+
+Now that we have created wallets, we want to be able to send funds between them. To achieve this,
+as mentioned previously we need to add transactions to the Blockchain. First, we need to develop a
+Transaction.cs class. Next, we can add the appropriate variables you would expect to see in a
+Blockchain transaction. You can consider an example of a transaction from Bitcoin. From this example
+the following variables can be adopted (implement them in Transaction.cs with appropriate types):
+
+    • Hash – the hash of the transaction and its contents
+    • Signature – the hash of the transaction signed with the private key of the sender
+    • SenderAddress – the public key of the sender
+    • RecipientAddress – the public key of the receiver
+    • Timestamp – the time at which the transaction was made/sent
+    • Amount – the amount of currency being sent to the receiver
+    • Fee – the fee added to the transaction (this will be implemented later)
+
+Now create a constructor for transaction, it should accept arguments for the above variables and also
+the sender’s private key, although you should exclude hash, signature and timestamp as the method
+will generate these. The constructor should assign the arguments to their respective properties, then
+the timestamp should be set to current time.
+
+The transaction should now have a sender, receiver, timestamp, amount, and fee. We can use this
+information to generate the hash. Take the code extract used in Part 2 to generate a SHA256 hash
+and adjust it to make a method to generate a transaction hash, then assign the hash with the result.
+
+Finally, you need to sign the hash with the sender’s private key (this was supplied in the argument of
+the constructor). You can generate a signature using the static method of Wallet.cs
+CreateSignature(), and provide the sender’s address, their private key, and the hash of the transaction
+as arguments.
+
+Note: The private key should not be left in the memory of the transaction instance, so do not save it
+                                                     as a variable.
+
+                                                                                                                          9
+Processing Transactions & Transaction Pools
+
+Now that we have made the infrastructure for a transaction, we want to be able to generate and
+process transactions. For this we can first generate a transaction and then display it to the UI. This
+will require a new UI element; in particular:
+
+    • An ‘Amount to send’ label and textbox
+    • A ‘Fee’ label and textbox
+    • A ‘receiver address’ label and textbox
+    • A button to ‘send the transaction,’ once the above fields have been completed
+
+                  Note: You can re-use the private and public textboxes for this purpose.
+
+                                                           8: New UI for transactions
+
+When the ‘Create Transaction’ button is clicked the following should occur:
+    • Amount, Fee, Public Key, Private Key, and Receiver Key fields are passed through to a new
+         instance of Transaction
+    • The Transaction is generated
+    • The Transaction is printed to the UI large text box
+
+Tip: It could be useful to make a method in Transaction.cs that returns the contents of a transaction
+                                                       as a string.
+
+           Note: Now is your chance to come up with the name of your own crypto-currency!
+
+                                                                                                                        10
+                                                      9: Sending some ‘AssignmentCoins’
+
+    Note: You may notice there are no checks in place currently to verify if the information being
+       provided is valid. For example, does the sender have the 10 AssignmentCoins to send? -
+                                       safeguarding against double-spend!
+
+We will add these checks in a later section, once it is possible to check the balance of a wallet.
+
+We have successfully generated a transaction, but we are not yet able to process it so that the
+blockchain could show it recorded in the next update. In Bitcoin when a transaction is created it is
+then processed by being shared with the network and placed in a transaction pool which consists of
+transactions that are waiting to be added to the next block on the Blockchain.
+
+A transaction is not confirmed or considered valid until it has been added to the Blockchain. Even
+then it is not always immediately accepted, some services that accept crypto-currency as payment
+require X number of confirmations. A transaction has one confirmation when it is first added to the
+Blockchain; when the next block is added it has two confirmations. Each additional block adds another
+confirmation. Transactions are not accepted until they reach a threshold of confirmations to reduce
+the impact of forks and attacks on the Blockchain. This is covered in more detail in the lectures.
+
+Our Blockchain is offline, so we do not need to worry about sharing it to the network. However, we
+should still place it in a transaction pool with other transactions while it is waiting to be added to the
+Blockchain. Now we can create a place to store pending transactions by adding a list of transactions
+to Blockchain.cs class called ‘transactionpool’ or ‘pendingtransactions’.
+
+Now when we generate a transaction, we can add it to the transaction pool, so it is ready to be added
+to the Blockchain.
+
+                                                                                                                        11
+Part 4 – Consensus Algorithms (Proof-of-Work)
+
+Generating new Blocks
+
+Your application should now be able to generate transactions and generate a genesis block. One Block
+on its own is not a Blockchain, therefore we need to generate some more blocks. We can add a
+button to the UI with the purpose of generating a new Blocks. When you click this button, it should
+call the Block constructor and pass it the variables from the previous block. Once this new Block has
+been generated, you can add it to the Blockchain (the List<Blocks> variable in Blockchain.cs). Now
+you can update the UI with the contents of the Block.
+Tip: It may be useful to create a GetLastBlock method in Blockchain.cs to get the latest block on the
+
+ chain. This method can be as simple as return blocks[blocks.Count - 1]; Also ensure that the
+ list of Blocks in Blockchain.cs is public or at least there is a public method to add new blocks to the
+
+                                                           list.
+
+               10: The second block – connected to the prior Genesis Block through reference to its previous hash
+
+If you have not already done so, you can now add a method or button to read all Blocks from the
+Blockchain and write them to the large text box.
+
+                                       11: Read All button displaying the 4 blocks within the chain
+
+                                                                                                                        12
+Adding transactions into Blocks
+
+We will now make use of the transaction pool that we created earlier. Blocks should carry transactions
+within them. We can examine this by first adding a new data field to Block.cs – transactionList, which
+should contain transactions. When a new Block is generated, it should be accompanied with
+transactions from the transaction pool. You can write some code to add transactions from the
+transaction pool to newly generated Blocks (This should occur during the Block generation process –
+before the hash is generated). Please make sure that the constructor of the Block is changed to accept
+a list of transactions in the arguments. We will edit the hashing mechanism in the Block later to
+consider transactions (by adding the “Merkle root”).
+Note: Blocks cannot take an infinite number of transactions from the transaction pool, you can add a
+
+       reasonable finite limit to the number of transactions that each block can take (such as 5).
+Note: Ensure that transactions picked from the transaction pool are removed once the new block is
+
+                         added to the chain. You may find the following line helpful:
+
+             transactionPool = transactionPool.Except(chosenTransactions).ToList();
+
+Now you can edit the Read function of Block to print out the contents of transactions within the Block.
+       Tip: Making use of a foreach loop in the Read code can make this task easier. See below.
+
+foreach (Transaction t in transactions) {
+    output += "\n" + t.ReadTransaction();
+
+}
+
+ Tip: It may be useful to add a button to read all transactions in the pool, to ensure that the code is
+                                                 working as intended.
+
+                                                12: Newly mined Block with two transactions
+
+                                                                                                                        13
+Proof-of-Work
+
+In an online Blockchain which is distributed across nodes in a peer-2-peer network, the nodes must
+reach a consensus on how the next Block should be added to the chain. In Bitcoin and other existing
+Crypto-currencies, Proof-of-Work is used. Proof-of-Work dictates that for a new Block to be added to
+the chain, this Block must have a hash that satisfies a given difficulty threshold. In Proof-of-Work
+nodes compete to create a Block that satisfies this difficulty threshold in the shortest time Consider
+the example below where the difficulty threshold is set as 2.
+
+    • A Blockchain node has generated a new Blockchain, however they cannot add it to the chain
+         until the hash begins with a number of zeros corresponding to the difficulty threshold.
+         (Difficulty = 2, therefore number of zeros required = 2).
+
+    • The node generates a hash of -
+         57169c0619650ff122a8d74776e74a5e6b6e8e517aea48579b2be0af19440488 for the block
+         using the block attributes.
+
+    • This hash does not satisfy the difficulty threshold, a new hash must be generated based on
+         this hash (re-hash). However hashing algorithms such as SHA256 always generate the same
+         hash given the same input. To generate a non-identical hash the Block has an extra data
+         property – nonce (number only used once). This nonce value is incremented after each hash
+         attempt until the resulting hash satisfies the difficulty threshold.
+
+    • So, the Blockchain node increments the nonce and rehashes until the difficulty threshold is
+         met. Finally, the following hash is generated that satisfies the threshold:
+         008a78f40bb59bf4c9da8cfccf6a9c8e1202b01933d2363eabb277ad867ba738
+
+    • The winning node having achieved the difficulty in shortest time then goes on to shares the
+         Block with the other nodes on the network, these nodes accept the new Block and add it to
+         their identical copies of the Blockchain. In this way the blockchain as universal record of
+         transactions is kept updated.
+
+To implement Proof-of-Work within our example Blockchain we need to add a new data property to
+Block.cs – nonce (set it to 0 by default) and set a global difficulty threshold float that must be satisfied.
+We recommend selecting a difficulty threshold of either 4, or 5.
+
+With the above complete, to create the Proof-of-Work algorithm the following must be implemented:
+
+    • Include the nonce in the CreateHash() method such that it is included in the process of the
+         composition of the hash.
+
+    • Create a new method Mine() that executes the CreateHash() method within a while loop,
+         which continues until the given hash starts with a number of zeros correlating to the difficulty.
+
+    • Change the Block.cs constructor to call Mine() instead of CreateHash().
+    • Increment the nonce after each failed hashing attempt. Do not increment the nonce after the
+
+         process has already resulted in a hash that has satisfied the difficulty criteria.
+    • Change the Read() method in Block.cs to also return the last value of nonce and the difficulty
+
+         level the Block was mined at.
+
+ Note: If you implemented this incorrectly your code could get stuck in a while loop. Making use of
+            debug mode (and reducing the difficulty) may help you investigate this problem.
+
+                                                                                                                        14
+                                                  13: Three Blocks mined at a difficulty of 4
+
+Difficulty (Level)
+
+The difficulty level as set in Proof-of-Work is proportional to the number of zeros at the beginning of
+the hash that constitute a valid block. The more zeros required there, the longer it will take to mine.
+SHA256 represents characters in hex format; meaning each character can be 1 of 16 different
+characters. Therefore, each extra zero required to mine in Proof-of-Work increases the difficulty by a
+factor of 16. For now, we are using a fixed difficulty of 4 or 5 zeros (up to you) at the beginning of the
+hash. Later however we will discuss the topic of a dynamic difficulty (which is why the data type of
+difficulty is float).
+
+For this section, the only action you need to take is to include the difficulty to the hash composition
+used in CreateHash().
+
+Rewards & Fees
+
+If we take a random Block from Bitcoin and look at the number of zeros required, we can see that 19
+zeros were required. The chance of generating a hash that begins with 19 zeros is 1/1619. This
+requires a huge amount of work to be done to generate a Block. Nodes all over the world compete to
+be the next one to generate a Block FIRST. Specialist computation hardware and much electricity is
+required to even have a slim chance of being the next node to mine a Block. Right now, in our
+Blockchain there is no incentive for nodes to mine, other than to get their transaction on the chain.
+In Bitcoin and other Proof-of-Work crypto-currencies the incentive comes in the form of a reward and
+fees.
+
+After each Block is mined in Bitcoin, a flat reward is given to the winning miner’s address. This reward
+is given as a transaction; the receiver address is the mining node address and the sending node is
+technically from nowhere (as the currency is generated there and then). In Bitcoin the sender’s
+
+                                                                                                                        15
+address is ‘Coinbase’, which is simply the terminology to refer to currency generated as a reward. In
+our implementation the sender’s address should be ‘Mine Rewards’ (because Wallet.cs is configured
+for reward currency to be sent from ‘Mine Rewards’. You can change this if you reconfigure Wallet.cs
+too). You can set the reward amount to any number you wish; you can even add conditions to the
+way rewards are PAID if you wish. For example, in Bitcoin, rewards are halved every 210,000 blocks;
+as a result only a finite amount in Bitcoins will ever exist.
+Fees are a small sum added to each transaction to incentivise the mining node to choose their
+transaction in the next Block. The higher the fee, the more likely the node will pick it. When the node
+successfully mines a Block, they receive a flat reward and the accumulative fees from all transactions
+in the Block. As we have already implemented fees in our transactions, we are ready to implement
+rewards and fees to mining nodes.
+To implemented fees and rewards we need to do the following:
+
+    • Add the logic for rewards; it can be fixed, variable, anything you decide.
+    • Update the UI code; such that the public address for the miner is sent through to the Block
+
+         constructor.
+    • Before we start mining the Block, we need to add all new transaction to the transaction list
+
+         (the pool) used by Block, t. In the constructor of the Block add a new method (before Mine()
+         is called) this method will calculate the reward and total fees owed (from all the transactions
+         in the Block) and create a transaction for it.
+    • Create this new transaction using the following line of code:
+    • Transaction transaction = new Transaction("Mine Rewards", minerAddress, (reward
+
+           + fees), 0,"")
+
+    • Wallet.cs is configured to deal with ‘Mine Rewards’ so a private key does not need to be
+         provided.
+
+    • Now add this new transaction to the transaction list in the Block.
+    • Add the reward to the hash composition used in CreateHash()
+    • Finally update the read method of Block.cs to print the reward, fees, and the miner’s address
+
+         {wallet).
+
+                          •
+
+                                                                                                                        16
+                                  14: Block with rewards implemented. Miner gets a reward of 25.001
+
+At this point we have successfully created an offline Blockchain. We have a consensus algorithm, a
+Blockchain, and can create transactions and get them published on the chain. However, we have not
+added any validation methods along the way. The next part covers validation and how we can prevent
+malicious actors from attacking the chain by utilising what we have already implemented.
+
+                                                                                                                        17
+Part 5 – Validation
+
+A Blockchain is normally hosted by many nodes in a peer-2-peer network. By definition being a
+trustless network, it is impossible to trust any node in the system, as they could be malicious.
+Therefore, instead of trusting the other nodes, you must trust the system. So far, we have developed
+a system that can generate digital keys, generate transactions with signatures, and generate and add
+Blocks to the Blockchain. However, we have no/minimal checks along the way to validate the
+Blockchain. The following section will highlight the areas that need validation and checks to ensure
+that the Blockchain is operating as intended, with no incorrect or malicious activity.
+
+Validating the Blockchain Structure
+
+As we already know, Blockchain is a linear structure of connected Blocks. The component that
+‘connects’ the Blocks is the reference to the hash of the previous Block. We should validate that the
+Blocks are properly connected, by checking that each Block correctly refer to the hash of the previous
+Block (Block Coherence, Contiguity)
+We can now include a new button within the UI that will perform full validation of the Blockchain. For
+now, you can make a method that iterates through the Blocks in the chain and checks the hashes of
+each block with its previous block to see if they match. This is to that each previous hash reference
+matches the hash of its previous block (the block that immediately preceded it; came just before it in
+the chain) If all Blocks pass (match their respective precursor block), then this method must return a
+success message; otherwise return a failure message.
+
+Checking and Validating Balance
+
+So far, we have had no way to check the balance of a wallet, and we do not have checks before
+transactions are made to see if a wallet can afford to spend the funds needed to be sent to another
+wallet for given transaction. We can include another button in the UI that checks the balance of a
+given wallet and include further checks within the transaction generation logic to ensure that the
+sender has sufficient funds before a transaction can be permitted to proceed.
+
+             (Remember currency is generated through mining so all wallets start with zero)
+Tip: You will need to create code that goes through all Blocks and searches for transactions involving
+
+                                            the wallet you are checking.
+
+    15: Check balance showing the balance of an address along with the transactions in which the address was involved.
+
+                                                                                                                        18
+Validating Blocks & Merkle Root
+
+So far, we have had have no verification method in the Blocks to check if the transactions within it
+have been tampered with Merkle root is a scalable and efficient method to encode data on the Blocks
+in an efficient manner. We can use the Merkle root algorithm to encode the transactions within a
+Block to a single hash. You can now include a new data field within Block.cs, as merkleRoot. We can
+include a new method within Block.cs to calculate the Merkle root too.
+
+The Merkle root algorithm combines the hashes of multiple transactions iteratively, until only one
+resulting hash remains after the hash of the latest block has been included. Consider the following
+example for how Merkle root is implemented:
+
+    • A Block has five transactions within: 1, 2, 3, 4, and 5.
+    • The hash of 1 and 2 are combined to make 1,2
+    • The hash of 3 and 4 are combined to make 3,4
+    • The hash of 5 is left untouched for now to make 5
+    • Now the hashes 1,2 and 3,4 are combined to make 1,2,3,4
+    • Finally, the hashes 1,2,3,4 and 5 are combined to make 1,2,3,4,5
+    • 1,2,3,4,5 is the final hash, and therefore it is the Merkle root.
+
+Now implement the Merkle root method in code. To help with this task you can make use of
+HashTools.cs made available for you in the HashCode folder. Use the method
+
+combineHash(hash1,hash2) to combine the hashes of transactions.
+
+  Tip: It may be useful to make the Merkle root algorithm static, as it will be useful for verification.
+
+Once the Merkle root algorithm and assignment are completed, Include the Merkle root validation
+with the validation method you made earlier. (Please do not forget to include the Merkle root within
+the Read() method in Block.cs)
+
+We do not just perform comparison of the hash of the Blocks for the purpose of Proof-of-Work [i.e.to
+check if a miner has submitted a block that is i) carries the content of all previous blocks and ii) satisfies
+the difficulty level, iii) has included all the transactions] we also use it to ensure that none of the data
+in a Block has been tampered with. As hashing algorithms always create the same hash given the
+same input, we can rehash the contents of a Block and compare the result with which hash? to check
+that the provided hash for the Block matches the combinatorial hash of all the previous blocks (their
+Merkle root. If the hashes do not match, then it is likely that some data in some Block(s) has been
+tampered with. If this happens the entire Block has to be rejected. So now we need to include this
+facility within our full Blockchain validation method, to check if the hash of a Block submitted by a
+miner does match the expected reference hash (who computed that, can they be trusted, who
+validates them?) indeed, hash provided is correct.
+
+Finally, we can include the merkleRoot data property within the SHA256 hashing method that
+generates a Block hash. This means if any transactions have been tampered with, then the Merkle
+Root will be different and as a result the hash of the Block will be wrong.
+
+                                                                                                                        19
+Validating Transactions
+
+Similarly to the last section, here we can include checks within the validation method to recalculate
+the hash of the transactions to arrive at the hash of a given block and compare it with a given hash
+of transaction within a submitted block. In addition to this we can also include logic to verify the
+signature provided in the transaction, to check to see that i the transaction has been signed off with
+the correct private key i.e. to authenticate the person making the transaction. For this purpose,
+Wallet.cs has a verification method that you can make use of: ValidateSignature(publicKey, hash,
+signature).
+
+Testing the validation
+
+You can test the validation methods that you have implemented in various ways. For example, you
+can try some of the following steps
+
+    • Sending a transaction with address that does not have enough funds to support it
+    • Sending a transaction and providing an invalid private key
+    • Creating a button/method that generates invalid Blocks with incorrect features – e.g., wrong
+
+         previous hash, wrong hash, invalid transactions within the block.
+
+                           *****************************************************
+
+Part 6 – Assignment Tasks
+
+This part will consist of 4 sections, to earn full marks for implementation (15) in this part of the
+assignment you only need to include in your submission correct implementations of three out of four
+of these sections. T
+
+This part carries 35 marks overall, 15 for implementation and 20 for report. You can earn the full 20
+marks for the report section if you only implement three sections. However, you may be able to pick
+up lost marks due to incomplete implementation of any three if you choose to implement all four (You
+cannot score more than 35 for this section).
+
+Research and reference to other Blockchain implementations is valued highly for this section,
+especially if you incorporate their logic into your solution.
+
+Threading during Proof-of-Work
+
+Currently when a node performs Proof-of-Work to find a hash to satisfy the difficulty, only one core
+in the CPU is working, the rest are idle.
+
+    1) Extend the Proof-of-Work algorithm to parallelize this task such that multiple threads are in
+         use. For the report, document the implementation and prove that there is a performance
+         efficiency gain when using multiple threads as opposed to one
+
+              Hint: Take multiple samples of mining times and compare them; make use of
+
+system.Diagnostics.Stopwatch.
+
+Do not forget to consider the fact that threads may repeat work (hashing the same data and creating
+hashes that have already been generated). Provide a solution to this problem and explain in the report
+how it prevents work from being repeated.
+
+Tip: The following C# resources may help implementation: Callbacks/Delegates and Threading. If you
+have problems updating the UI using threads the following line may be useful:
+
+textBox1.Invoke(new Action(() => textBox1.Text += message))
+
+                                                                                                                        20
+Adjusting the Difficulty Level in Proof-of-Work
+
+As previously mentioned in this brief, the difficulty level is a static type right now and so does not
+change from Block to Block. In existing Blockchain (Proof-of-Work) implementations a dynamic
+difficulty level is used. In Proof-of-Work crypto-currencies ‘Block Time’ is considered the average
+amount of time required until the next Block is added to the chain. In Bitcoin this is 10 minutes and
+in Ethereum this is 10-20 seconds.
+
+    2) Decide your own ‘Block time’ (with justification in the report) and implement an adaptive
+         difficulty level algorithm. Prove that the implementation works in the report and discuss how
+         you developed your solution for your implementation.
+
+ Note: In our current implementation increasing the difficulty by one would increase the amount of
+  work by a factor of 16. This is not suitable for dynamic difficulty level setting. You would need to
+
+              consider another approach; you may wish to review the existing approaches.
+
+In your report, please detail how you developed your implemented dynamic difficulty level and why
+you chose a particular approach while also providing evidence that it works. Also state what the
+duration of your ‘Block Time’ was and justify why.
+
+Mining Settings
+
+Currently, when Blocks are added to the chain, they pick transactions from the transaction pool
+arbitrarily. In reality, there are many ways that a node may wish to pick transactions from the pool.
+They may wish to be altruistic and pick the transactions that have been waiting the longest. They may
+wish to be greedy and pick the transactions with the largest fees. They may wish to be unpredictable
+and pick entirely randomly. They may have their own transactions pending and choose to pick up
+transactions involving their address first.
+
+    3) Implement a setting within the UI to enables the node to decide how it wishes to pick
+         transactions from the pool. Include “Greedy” (highest fee first), “Altruistic” (longest wait
+         first), “Random” and Address Preference.
+
+In your report discuss what you believe would be the optimal setting to choose and why. Also discuss
+how to choose to implement the settings and provide evidence that each setting works.
+
+Your own idea
+    4) You are welcome, within the scope of this work, to come up with your own extension/change
+         to add to the application. This change cannot be trivial and should take a similar amount of
+         implementation time to the other 3 sections. Some ideas, for example include:
+
+    • The implementation of a different consensus algorithm (Proof-of-Stake),
+    • Creating multiple nodes running in a local network, automating the generation of
+
+         transactions,
+    • Smart contracts (if you are really ambitious).
+
+You will need to justify your choice to add any extension to the application, document your
+implementation and provide proof that it works as intended.
+
+                           **********************************************
+
+                                                                                                                        21
+
diff --git a/CS3BC Coursework Specification.pdf b/CS3BC Coursework Specification.pdf
new file mode 100644
index 0000000..f9325ac
--- /dev/null
+++ b/CS3BC Coursework Specification.pdf	
@@ -0,0 +1,257 @@
+                                       Department of Computing
+                  School of Mathematical, Physical and Computational Sciences
+
+                                             Assessed Coursework Set
+Module Title: Blockchain and Security
+Module Code: CS3BC
+Lecturer responsible: Prof. Atta Badii
+Teaching Assistants: Dr Udeni Jayasinghe, Dr Asad Hussain, Mr. Abdullah Sarwar
+Type of Assignment: Coursework
+Individual/group Assignment:
+Individual Weighting of the
+Assignment: 50%
+Page limit/Word count: 7 pages excluding the appendix (screen-shots and/or code
+segments)
+Expected time spent on this assignment: 20 hrs
+Items to be Submitted: 1 report plus link of GitLab or similar repository for codes
+Work to be submitted online via Blackboard Ultra by: 12:00 noon, Monday 19th of May
+2025
+Artificial Intelligence Tools May be used to support work
+
+NOTES
+By submitting this work, you are certifying that you have read the assessment guidelines,
+which are displayed in the folder of Assessment on the Blackboard course for this module,
+and that you have conformed to and understand the associated policies and practices,
+including those on:
+
+    • Submitting your own work, not that of other people or systems (including those using
+         artificial intelligence), and the associated penalties for Academic Misconduct
+
+    • Submitting by the specified deadline, and the penalties associated with late
+         submission (if allowed)
+
+    • The exceptional circumstances system
+    • For students with relevant needs, attaching with a green sticker
+
+                                                                                                                                  1
+Assessment classification
+
+  First Class (>= 70%)
+  Outstanding quality correct and highly efficient solution with excellent analysis and
+  rationalisation of methods used and tested with the approach to validation of
+  correctness and efficiency thoroughly justified; excellent quality and presentation
+  of the technical report in terms of clarity, coherence, and other aspects of the
+  presentation such as English grammar.
+  Upper Second (60-69%)
+  High quality correct and efficient solution with good analysis and rationalisation of
+  methods used and tested with the approach to validation of correctness and
+  efficiency well-justified; high quality of presentation of the technical report in terms
+  of clarity, coherence, and other aspects of presentation such as English grammar.
+  Lower Second (50-59%)
+  Good quality correct and moderately efficient solution with reasonable analysis
+  and rationalisation of methods used and with the approach to validation of
+  correctness and efficiency reasonably justified; good quality and presentation of
+  the technical report in terms of clarity, coherence, and other aspects of
+  presentation such as
+  English grammar.
+  Third (40-49%)
+  satisfactory solutions with moderate/low quality and efficiency but adequate
+  analysis and rationalisation of methods used and tested with the approach to
+  validation of correctness adequately justified; satisfactory presentation of the
+  technical report in terms of clarity, coherence, and other aspects of presentation
+  such as English grammar but with some shortcomings.
+  Pass (30-39%)
+  Basic (minimally acceptable quality) solution with barely adequate analysis and
+  rationalisation of methods used and tested with the approach to validation of
+  correctness not fully justified, adequate quality and presentation of the technical
+  report in terms of clarity, coherence, and other aspects of presentation but with
+  many shortcomings.
+   Fail (<30%)
+  Inadequate solution with inadequate analysis and rationalisation of methods used
+  and tested; inadequate or missing validation of correctness of the approach
+  justified; inadequate quality and presentation of the technical report lacking in
+  clarity, coherence, and other aspects of presentation- below the minimum
+  acceptable standards.
+
+Assignment implementation requirements
+
+C#, Visual Studio (v# 4.7.2): https://visualstudio.microsoft.com/vs/community/
+Code Project: BlockchainAssignment.zip (downloaded from the CS3BC
+Blackboard “Assessment” → “Assignment Starter Resources” folder Titled:
+Practical and Assignment Application Starter Project/Initial Implementation
+Environment)
+
+                                                                                                                       2
+Assignment Submission requirements
+The following information is required on the front sheet of your submission:
+Module Code: CS3BC
+Assignment report Title: Blockchain Coursework Assignment
+Student Number (e.g.,25098635):
+Date (when the work was completed):
+Actual hrs spent for the assignment:
+Which Artificial Intelligence tools used (if applicable):
+
+                                                                                                                       3
+Practical Guided Exercises and Assignment
+This integrated Practical’s & Coursework Assignment set for this module is
+intended to enable every student to implement a basic offline Blockchain. The
+practicals are structured to allow guided step-by-step development of the required
+components for the basic blockchain implementation.
+It is expected that you will complete and document the first 5 parts of the
+Coursework Assignment as a structured sequence of 5 exercise steps as supported
+through step-by-step lab demonstrations as illustrated in the practicals support
+document which is called “Practical Exercises and Coursework Support Lab Script”
+and that you can download from:
+
+                        Blackboard → Modules → Blockchain and Security
+And in the assessment Tab:
+
+                       Content → Assessment → Assignment Starter Resources
+The assignment task (Part 6) is based on the application that you will have built
+through the first 5 parts of the practical lab exercises. For your submission you will
+submit your solution for the first 5 parts as worked out through demonstrated lab
+sessions plus your solution to the three tasks out of 4 of the following 4 tasks that
+form Part 6.
+To earn full marks for implementation (15) for this Part 6 of this coursework you
+only need to submit correct implementations of three out of four of these
+assignment tasks. As you can see in the below marking scheme table, this Part 6
+carries 35 marks overall, 15 for implementation and 20 for the report. You can
+earn the full 20 marks for the report section if you only implement three
+sections. However, you may be able to pick up lost marks due to incomplete
+implementation of any three if you choose to implement all four, although in any
+case, for Part 6, one cannot obtain more than the maximum allowed marks of
+35.
+Research and reference to other Blockchain implementations will be valued
+highly for the Part 6 tasks; especially if you incorporate their logic into your
+solution.
+
+                                                                                                                       4
+Marks for the assignment are allocated as follows:
+
+Coursework Parts               Marks for            Marks for Total
+                               evidence of          the Report Marks
+                               implementation
+
+Part 1 – Project Setup         3                    2   5
+
+Part 2 – Blocks and the        5                    5   10
+
+Blockchain
+
+Part 3 – Transactions and      5                    5   10
+
+Digital Signatures
+
+Part 4 – Consensus Algorithms  10                   10  20
+
+(Proof-of-Work)
+
+Part 5 – Validation            10                   10  20
+
+Part 6 – Assignment Tasks (1-
+
+4)                             15                   20  35
+
+    Equally divided
+
+                               48                   52  (100)
+
+  For each part in this coursework assignment, you are expected to submit evidence
+  of implementation alongside a report which details your understanding of the
+  steps. Evidence of implementation can be provided by screenshots of results for
+  parts 1-5 and by a link to the code to be made accessible to the assessors.
+
+  To reconfirm: For this Part 6 (the assignment), you are expected to complete 3 out
+  of 4 of the tasks to achieve the maximum of 35 marks. However, in cases where a
+  student may have attempted all four tasks, but not scoring the maximum on each
+  task, the fourth task is also assessed and this could raise their overall score up to
+  a maximum of 35 marks which is the total mark that could be earned for Part 6.
+
+The 4 tasks in Part 6 of this assignment are as follows:
+
+Task 1: Extending the Proof-of-Work algorithm
+  Extending the Proof-of-Work algorithm to parallelise this task such that multiple
+  threads are in use. Currently when a node performs Proof-of-Work to find a hash
+  to satisfy the difficulty level, only one core in the CPU is working, the rest are idle.
+  For the report, document the implementation and prove that there is a performance
+  efficiency gain when using multiple threads as opposed to one.
+
+                                                                      5
+  Guidance for this task:
+  Take multiple samples of mining times and compare them; make use of
+  system.Diagnostics .Stopwatch. Do not forget to consider the fact that threads may
+  repeat work (hashing the same data and creating hashes that have already
+  generated). Provide a solution that avoids such duplicated work and explain in the
+  report how it prevents work from being repeated.
+
+ Tip: The following C# resources may help implementation: Callbacks/Delegates
+ and Threading.
+
+  If you have problems updating the UI using threads the following line may be
+ useful.
+
+                textBox1.Invoke(new Action(() => textBox1.Text += message))
+
+Task 2: Adjusting the Difficulty Level in Proof-of-Work
+  As previously mentioned in the practicals support document, the difficulty level was
+  a static type so far and as such did not change for each new cycle of block mining.
+  In state-of the art Blockchain (Proof-of-Work) implementations a dynamic
+  difficulty level is used. In Proof-of-Work crypto-currencies ‘Block Time’ is
+  considered as the average amount of time required until the next Block is added to
+  the chain. In Bitcoin this is 10 minutes and in Ethereum this is 10-20 seconds.
+
+  For this task, please decide your own ‘Block time’ (with justification provided in the
+  report) and implement an adaptive difficulty level algorithm. Prove that the
+  implementation works in the report and discuss how you developed your solution
+  for your implementation.
+
+  Guidance for this task:
+  In our current implementation increasing the difficulty by one would increase the
+  amount of work by a factor of 16. This is not suitable for dynamic difficulty level
+  setting. You would need to consider another approach; you may wish to review the
+  existing approaches as adopted by others.
+
+  In your report, please detail how you developed your implemented dynamic difficulty
+  level and why you chose a particular approach while also providing evidence that it
+  works. Also state what the duration of your ‘Block Time’ was and justify why.
+
+Task 3: Implementing Alternative Mining Preference Settings
+  Currently, when Blocks are being formed by including transactions within them to
+  be added to the chain, the transactions are selected from the transaction pool
+  arbitrarily. In reality, there are many ways that a node (a miner) may wish to select
+  transactions to mine from the transactions pool. They may wish to be altruistic and
+  pick the transactions that have been waiting the longest. They may wish to be
+  greedy and pick the transactions with the largest fees. They may wish to be
+  unpredictable and pick the transaction entirely randomly. They may have their own
+  transactions pending and choose to pick up transactions involving their address
+  first. For this task, please implement a setting within the UI, as has been developed
+  during the practical sessions, to enable the node to decide how it wishes to pick
+  transactions from the pool. Include “Greedy” (highest fee first), “Altruistic” (longest
+  wait first), “Random” and “Address Preference”.
+
+                                                                                                                          6
+  Guidance for this Task:
+  In your report discuss what you believe would be the optimal setting to choose and
+  why. Also discuss how to choose to implement the settings and provide evidence
+  that each setting works.
+Task 4: Your own Task
+  You are welcome, within the scope of this work, to come up with your own
+  extension/modification of the application developed through parts 1-5 of the
+  practical sessions. Such an extension as you may design and implement for this
+  task 4 should not be trivial; it would need to require an amount of effort comparable
+  to what is needed to complete each of the first 3 tasks listed above.
+  Guidance for this Task:
+  Some ideas for this task 4, for example, include:
+
+       • The implementation of a different consensus algorithm (Proof-of-Stake),
+       • Creating multiple nodes running in a local network, automating the
+
+           generation of transactions,
+       • Smart contracts (if you are really ambitious).
+  You will need to justify your choice to add any extension to the application,
+  document your implementation and provide proof that it works as intended.
+
+                                  ****************************************
+
+                                                                                                                          7
+
diff --git a/Further Coursework Support (4).pdf b/Further Coursework Support (4).pdf
new file mode 100644
index 0000000..6aad4a1
--- /dev/null
+++ b/Further Coursework Support (4).pdf	
@@ -0,0 +1,144 @@
+ Blockchain
+
+   Practical Exercises and
+     Coursework Support
+
+       Coursework Assignment:
+               Hints and Tips
+
+                                                                                                                                                                  1
+
+Copyright University of Reading
+Assignment Tasks
+
+Options
+Choose ¾ of the following options:
+
+1. Threading during Proof-of-Work
+2. Adjusting the Difficulty Level in Proof-of-Work
+3. Mining Settings
+4. Your own idea
+
+35 marks (15 for implementation and 20 for report)
+
+Research and reference to other Blockchain implementations
+
+highly recommended for these sections.              2
+Threading during Proof-of-Work
+
+• Utilise the full computational power available using:
+   • Possible Solution: Multi-threading e.g. C# Threads
+   • Advanced Solution: GPU implementation e.g. CUDA C
+
+• Requirements:
+   • E-Nonce (Prevent duplication of work)
+   • Coordination of threads
+
+• Reporting Suggestion:
+   • You can perform a comparison study comparing mining
+     times of single- vs. multi-threaded solution
+       • Vary difficulty level to examine the point at which
+        overheads are overcome
+
+                                                                                                                                                                  3
+Adjusting the Difficulty Level in PoW
+
+• “Dynamic” or “Adaptive” Difficulties
+
+• Decide your own ‘block time’ and implement an
+ appropriate algorithm
+
+• Principles and Requirements
+
+• Establish a target block time
+
+• Continuously call Mine()
+
+• Calculate the “Mine Rate” based on previous block
+ timestamps
+
+• Adjust the difficulty based on the difference between
+ target and actual/observed block time
+
+• Note the current implementation adjusts difficulty by a factor
+
+of 16 with each step which you may find to be too
+
+significant – consider alternative solutions.            4
+Adjusting the Difficulty Level in PoW
+
+Starting off:
+
+• Need to have revised thread management in C#
+
+• Please refer to the notes already provided
+
+• Can start with a moderate level of difficulty say 5 and
+
+• Now you need to benchmark this i.e. measure how
+ long it takes with or without threads and how many
+ threads to satisfy a workable level of difficulty and
+ block time
+
+• This just means repeating the PoW using Mine() for
+ different levels of difficulty with or without threads
+
+Block time = timestamp for block (n) – timestamp for
+
+block (n-1)                                                5
+Adjusting the Difficulty Level in PoW
+
+  • Exponential growth function
+  • In the exponential growth of f(x), the function doubles every
+
+    time you add one to its input x. In the exponential decay of
+    g(x), the function shrinks in half every time you add one to its
+    input x … e.g., Adaptive Proof of Work (APoW)
+
+         • Establish a target block time
+         • Calibration “Block-To-Block Stair-Stepping”
+
+             >Median block time of a batch of N recently-mined
+              blocks
+
+         • Exponential Decay Difficulty Adjustments
+
+                                                                                                           
+
+             >Adjusts the difficulty according to  
+
+                 > After a significant spike in hash rate and difficulty followed by a huge
+                   drop in hash rate and difficulty, each new block becomes much easier
+                   until the difficulty stabilizes according to the true size of the network 6
+ Mining Settings
+
+• Selection of pending transactions for mining
+• Possible Options:
+
+   1. Greedy (Largest fees)
+   2. Unpredictable (Random)
+   3. altruistic (Oldest existing)
+   4. Address based (Personal transactions)
+
+This just requires
+i) Use the existing code to create many transactions with variable
+amounts and fees
+i) Write code to deliver that is to select the right transactions from the
+transaction pool in each of the 4 case
+ii) Using the Windows Form to create the 4 buttons that would select and
+display the right number of transactions up to a stated limit according the
+
+                                                                                                                                                                  7
+
+selection strategies 1-4 above.
+                Your own idea
+
+                                    Possible Suggestions
+1) Implementation of a different consensus algorithm (e.g. Proof-of-Stake)
+2) Create multiple nodes running in a local network, automating the
+
+   generation of transactions.
+3) (Advanced) Smart Contracts
+
+                                                                                                                                                                      8
+
diff --git a/Further Coursework Support-CS3BC20-2023.pdf b/Further Coursework Support-CS3BC20-2023.pdf
new file mode 100644
index 0000000..667a228
--- /dev/null
+++ b/Further Coursework Support-CS3BC20-2023.pdf	
@@ -0,0 +1,228 @@
+Further Clarification re Assessment and Implementation
+
+The only code to be added by students would be additional code to be integrated within the Mine()
+routine of the fully commented working program provided (for pointers see below).
+
+As the marking scheme below shows, by completing and documenting tasks 1-5 , which is simply to
+
+run the programme provided and presenting a report on it on the same basis as the Coursework
+
+Support Notes, a student can obtain (65%), and by completing just one of the last three tasks (requiring
+
+a few lines of code to be added) (35/3= 11.66%) a student can obtain 65+11.66= 76.66% of the marks;
+
+by completing a second task (E.g. Multi-threading using an extra-Nonce for re-hashing to get the block
+
+with the right number of zeros responsive to difficulty number) a student can obtain 76.66+11.66=
+
+88.32 and by implementing an adaptive difficulty algorithm (see hints about using an exponential
+
+decay function in                         a student can obtain up to 100% of the marks; or
+
+alternatively a student can suggest their own third task as they wish as long as not trivial.
+
+Part                                      Evidence of implementation          Report           Total
+1 – Project Setup                                                          3         2             5
+2 – Blocks and the Blockchain                                              5         5
+3 – Transactions and Digital Signatures                                    5         5            10
+4 – Consensus Algorithms (Proof of Work)                                                          10
+5 - Validation                                                            10       10             20
+6 – Assignment Tasks 1, 2, 3                                              10       10             20
+
+                Equally divided marks                             15                           20 35
+
+                                                                  48                           52 (100)
+
+                   Coursework Facts
+
+Tasks 1-5 which cover the stages of building the mini-blockchain                               65%
+
+No programming is necessary, but it is essential to show a comprehensive understanding of the code
+provided and the mini-blockchain build scenario. Students are to submit a description of each of the
+steps including screenshots from their own running instance of the blockchain application running
+on their own computer to demonstrate their understanding. Thus, students will get full marks
+allocated to these steps (Yellow Parts = 65%) simply by showing their own screenshots arising from
+the execution of the code provided and outlining the steps for example illustrated by a flow chart.
+
+All the code, including the constructors for each necessary object such as block, wallet and transaction,
+are integrated within the working code including the GUI using Windows Forms as provided in the
+practical folder to build a mini-blockchain. The Coursework requires that students refer to the
+document in the Blackboard → CS3BC20 Blockchain → Practical folder
+
+                                                        which is the cookbook used for step-by-step creation
+of the mini-blockchain during laboratory sessions. This is to help the students, for the coursework to
+create their own version of the mini-blockchain on their own computer using the fully commented
+code that is also in the Blackboard → CS3BC20 Blockchain → Practical folder
+
+                                                                                                         1
+Part 6 (Tasks 1, 2, 3) the green highlighted tasks in the above Marking Scheme           35%
+
+Some tutorial advice regarding the only additional coding necessary for implementing Part B tasks has
+been provided in lab/lecture sessions and is also set out in the following two documents available on
+Blackboard:
+
+For Tasks 1, 2, 3 of Part 6, students can add some code of their own to the MIne () routine within the
+working code to experiment with alternative scenarios for Proof-of-Work which is the process of
+mining valid blocks as already implemented within the code.
+
+The points at which this additional code could be introduced is dependent on the Tasks selected for
+Part 6:
+
+i)  Task 1: Multi-threading to carry out, in parallel, the block preparation (Proof-of-Work)
+
+    process for different degrees of difficulty. Finding out as you increase the degree of difficulty,
+
+    how high one needs to go, before multi-threading would give significant speed advantage in
+
+    arriving at a valid block with the right number of leading zeros, noting that multi-threading
+
+    requires a computational overhead in thread management, and such parallelised
+
+    computation will lead to an efficiency gain only when the gain from the parallelism is over-
+
+    compensates for the time taken for thread management.
+
+ii) Task 2: Decision by an algorithm which periodically adjusts the “degree-of-difficulty”
+
+    consistent with the Block Update Rate set for the next cycle – the time interval between
+
+    successive block updates that has to allow enough time for the miners to arrive at a block
+
+    hash with as many leading zeros as the number stated as the “degree of difficulty”.
+
+iii) Task 3: Decision by the miner as to which transactions to select for inclusion in the next block
+
+    as typically there could be more transactions in the pool than a miner could/would include in
+
+    each next block to be submitted.
+
+Part 6 - (Tasks 1, 2, 3) Preparatory steps
+
+So far students will each have created their own instance of the mini blockchain by running
+the code provided and interacting with the window forms produced to be able to show the
+objects created (Blocks, Transactions, and Wallets) so that they can use this to run 2/3
+experiments/Tasks.
+Students can now simply create a few new transactions by sending coins from one wallet to
+another, essentially establishing the mini-blockchain as a ledger – creating a number of
+accounts (wallets) and say 10-20 transactions within an hour time-period with varying
+amounts and fees so that the transactions will have sufficiently spread-out timestamps.
+Students would then be ready to attempt the additional Tasks for the last 35 marks; here are
+some more hints building on the advice given in the lab-lecture sessions and in the two
+following documents:
+
+                                                                                         2
+Part 6 - Task 1              35/3≈11.67 Marks
+
+This is simply a multi-threading exercise. Multi-threading tutorials are available for C# which
+is the language of the already completed program for the mini-blockchain build but for
+students who wish to translate the existing program to another language such as Python or
+Java, multi-threading tutorials have also been included for these languages with lots of code
+examples by way of additional support. Despite this, the additional code to be written for the
+additional Tasks is relatively minor, so it would probably be advisable to attempt to continue
+with C# even if one is more comfortable with some other language.
+
+BB → CS3BC20 → Practicals →
+
+For this task one can run two or more threads each doing the block validation/mining (Proof-
+of-Work) process in parallel. First thread would use a standard Nonce and subsequent threads
+using extra-Nonces, e-Nonce, as a Nonce can only be used with one of the threads, so as to
+avoid duplication of computation with each new thread instead of advancing the chance of
+producing the valid block faster. Thread synchronisation is also vital to ensure the first
+successful Mine() thread is recognised as the final result and all threads are timed to enable
+benchmarking the efficiency of single versus multi-threaded Mine() which is what the
+objective of this task.
+
+So, one would need to measure how long it takes with single or more threads and how many
+threads to satisfy a workable level of Degree-of-Difficulty for a reasonable Block Update Time
+(time-to -compute-valid-block-Ready).
+
+This just means using the existing code and adding some extensions using Mine() to work out
+the time each thread takes to do its Mine(). This would mean setting up new variables for
+thread management and latency registering (could make use of system.Diagnostics.Stopwatch).
+
+One should be able to take multiple samples of mining times and compare them for different
+number of threads and for a few increasing “Degree-of-Difficulty” numbers and seeing for what
+Degree-of-Difficulty and what number of threads a most efficient [(shortest Mine() time] is achievable
+.
+So one can keep increasing the difficulty level to examine the point at which overheads of
+threading are exceeded by the efficiency gain arising from the parallelism provided by the
+threading. Say starting from four as the “Degree-of-Difficulty” used in the available working
+program and manually re-setting it for each run with a different number of thread (while
+increasing or decreasing the number of threads and timing the process to establish at what
+Degree-of-Difficulty, using how many threads, the Mine() will execute faster to deliver the
+valid block with requisite number of leading zeros, i.e. the optimal set-up at which the parallel
+execution of Mine() through multi-threading gets the job done fastest.
+
+Part 6 - Task 2              35/3≈11.67 marks
+
+Clearly there is a trade-off between changing the Degree-of-Difficulty and time-to-submit of
+valid blocks which is the time it takes to complete the computation required to arrive at a
+submittable block with the requisite number of leading zeros that thus satisfies the "Degree-
+of-Difficulty".
+
+                             3
+The block update time (latency) usually does not change frequently for a specific Blockchains
+(e.g. In Ethereum the block update time 10-20 seconds, for Bitcoin it is presently 10 minutes and
+the Degree-of-Difficulty maintained with this is 19, see below).
+
+                      =    () –    ( − 1)
+
+For setting the “Degree-of-Difficulty” to vary the computational load of Dynamic Proof-of-
+Work for miners from time to time, one can assess the trend in the median value of Block
+Update Time and have an algorithm that dynamically increases the Degree-of-Difficulty
+responsive to the trend in the median value of the Block Update Time.
+
+                      =    () –    ( − 1)
+
+In this way, potentially, Blockchains could use the block update times of the last N blocks to
+re-adjust the Degree-of-Difficulty responsive to the trend in the value of the Block Update
+Time.
+One can use an exponential function to have the Degree-of-Difficulty be re-set responsive to
+changes in the Block Update Time (median time it has taken for the miners to submit the last
+N blocks) or use alternative approaches for such Adaptive Proof-of-Work and decide which
+would be most effective.
+However, the starting point could be to establish a target block time and apply an exponential
+decay function to converge to a “Degree-of-Difficulty” number incrementally best adjusted
+for the target block update latency desired (for further information please see
+
+                               ).
+
+                                        ****************************
+
+                                                                                                                          4
+Part 6 - Task 3                                                  35/3 ≈ 11.67 marks
+
+Using a bit of code to modify the way Mine() works, a student can allow the selection of
+
+transactions from the transactions pool to take place based on:
+
+• Greedy (choose transactions with the higher fees with a cut-off of say six transactions
+    to chosen)
+
+• Altruistic (check the timestamp of transactions and chose the oldest ones with cut-off
+    on how old)
+
+• Random (run a Rand() function with a small range and choose the transaction which
+    have most matches with say the transaction number or the hash of some parameter
+    of the transaction - with a cut-off on the transactions)
+
+• Address-based (Choosing transactions based on the value of some other attribute of
+    the transaction e.g., the highest wallet_ID addresses with a cut off after the top six
+    chosen)
+
+Start by using the Windows Form to create buttons for each of the above four types of Mining.
+Declare custom functions to select transactions from the transaction pool, according to each
+of the above criteria, thereafter, proceeding to run Mine() with this method to select the
+transactions to be selected for the new block generated – ready to be submitted.
+
+Basic Technical Reporting Hygiene
+As you can see 52% of the marks are allocated to the reporting so it is important that the
+accompanying report submitted is complete, coherent, and well-presented as it with the
+presentation that one can needlessly lose marks one could easily keep.
+
+Good luck.
+
+                 ********************************
+
+                                                                 5
+

commit e78c75bca26bce3b4cfa8832febda2b4cc992b83
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Tue Feb 18 16:30:48 2025 +0000

    Add project files.

diff --git a/BlockchainAssignment.sln b/BlockchainAssignment.sln
new file mode 100644
index 0000000..ba03788
--- /dev/null
+++ b/BlockchainAssignment.sln
@@ -0,0 +1,25 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.30611.23
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BlockchainAssignment", "BlockchainAssignment\BlockchainAssignment.csproj", "{A7A15326-A321-4E6D-BC72-E4289D6DEF38}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{A7A15326-A321-4E6D-BC72-E4289D6DEF38}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{A7A15326-A321-4E6D-BC72-E4289D6DEF38}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A7A15326-A321-4E6D-BC72-E4289D6DEF38}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{A7A15326-A321-4E6D-BC72-E4289D6DEF38}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {85CFA1A9-DAE1-47D4-9161-D9C2D54C6352}
+	EndGlobalSection
+EndGlobal
diff --git a/BlockchainAssignment/App.config b/BlockchainAssignment/App.config
new file mode 100644
index 0000000..56efbc7
--- /dev/null
+++ b/BlockchainAssignment/App.config
@@ -0,0 +1,6 @@
+﻿<?xml version="1.0" encoding="utf-8" ?>
+<configuration>
+    <startup> 
+        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
+    </startup>
+</configuration>
\ No newline at end of file
diff --git a/BlockchainAssignment/BlockchainApp.Designer.cs b/BlockchainAssignment/BlockchainApp.Designer.cs
new file mode 100644
index 0000000..e5bcb4e
--- /dev/null
+++ b/BlockchainAssignment/BlockchainApp.Designer.cs
@@ -0,0 +1,64 @@
+﻿namespace BlockchainAssignment
+{
+    partial class BlockchainApp
+    {
+        /// <summary>
+        /// Required designer variable.
+        /// </summary>
+        private System.ComponentModel.IContainer components = null;
+
+        /// <summary>
+        /// Clean up any resources being used.
+        /// </summary>
+        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
+        protected override void Dispose(bool disposing)
+        {
+            if (disposing && (components != null))
+            {
+                components.Dispose();
+            }
+            base.Dispose(disposing);
+        }
+
+        #region Windows Form Designer generated code
+
+        /// <summary>
+        /// Required method for Designer support - do not modify
+        /// the contents of this method with the code editor.
+        /// </summary>
+        private void InitializeComponent()
+        {
+            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
+            this.SuspendLayout();
+            // 
+            // richTextBox1
+            // 
+            this.richTextBox1.BackColor = System.Drawing.SystemColors.InfoText;
+            this.richTextBox1.ForeColor = System.Drawing.SystemColors.ButtonHighlight;
+            this.richTextBox1.Location = new System.Drawing.Point(12, 12);
+            this.richTextBox1.Name = "richTextBox1";
+            this.richTextBox1.Size = new System.Drawing.Size(657, 314);
+            this.richTextBox1.TabIndex = 0;
+            this.richTextBox1.Text = "";
+            // 
+            // BlockchainApp
+            // 
+            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+            this.BackColor = System.Drawing.SystemColors.ActiveCaption;
+            this.ClientSize = new System.Drawing.Size(681, 481);
+            this.Controls.Add(this.richTextBox1);
+            this.ForeColor = System.Drawing.Color.Black;
+            this.Name = "BlockchainApp";
+            this.Text = "Blockchain App";
+            this.Load += new System.EventHandler(this.Form1_Load);
+            this.ResumeLayout(false);
+
+        }
+
+        #endregion
+
+        private System.Windows.Forms.RichTextBox richTextBox1;
+    }
+}
+
diff --git a/BlockchainAssignment/BlockchainApp.cs b/BlockchainAssignment/BlockchainApp.cs
new file mode 100644
index 0000000..81b84b3
--- /dev/null
+++ b/BlockchainAssignment/BlockchainApp.cs
@@ -0,0 +1,24 @@
+﻿using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Data;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+
+namespace BlockchainAssignment
+{
+    public partial class BlockchainApp : Form
+    {
+        public BlockchainApp()
+        {
+            InitializeComponent();
+        }
+
+        private void Form1_Load(object sender, EventArgs e)
+        {
+        }
+    }
+}
diff --git a/BlockchainAssignment/BlockchainApp.resx b/BlockchainAssignment/BlockchainApp.resx
new file mode 100644
index 0000000..1af7de1
--- /dev/null
+++ b/BlockchainAssignment/BlockchainApp.resx
@@ -0,0 +1,120 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers & schema ...
+    <resheader name="resmimetype">text/microsoft-resx</resheader>
+    <resheader name="version">2.0</resheader>
+    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
+    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
+    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
+    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
+    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
+        <value>[base64 mime encoded serialized .NET Framework object]</value>
+    </data>
+    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
+        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
+        <comment>This is a comment</comment>
+    </data>
+                
+    There are any number of "resheader" rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    -->
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" use="required" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+              <xsd:attribute ref="xml:space" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+              <xsd:attribute ref="xml:space" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
\ No newline at end of file
diff --git a/BlockchainAssignment/BlockchainAssignment.csproj b/BlockchainAssignment/BlockchainAssignment.csproj
new file mode 100644
index 0000000..a1fec3d
--- /dev/null
+++ b/BlockchainAssignment/BlockchainAssignment.csproj
@@ -0,0 +1,85 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProjectGuid>{A7A15326-A321-4E6D-BC72-E4289D6DEF38}</ProjectGuid>
+    <OutputType>WinExe</OutputType>
+    <RootNamespace>BlockchainAssignment</RootNamespace>
+    <AssemblyName>BlockchainAssignment</AssemblyName>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
+    <Deterministic>true</Deterministic>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="System.Xml.Linq" />
+    <Reference Include="System.Data.DataSetExtensions" />
+    <Reference Include="Microsoft.CSharp" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Deployment" />
+    <Reference Include="System.Drawing" />
+    <Reference Include="System.Net.Http" />
+    <Reference Include="System.Windows.Forms" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="BlockchainApp.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="BlockchainApp.Designer.cs">
+      <DependentUpon>BlockchainApp.cs</DependentUpon>
+    </Compile>
+    <Compile Include="HashCode\HashTools.cs" />
+    <Compile Include="Program.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="Wallet\Wallet.cs" />
+    <EmbeddedResource Include="BlockchainApp.resx">
+      <DependentUpon>BlockchainApp.cs</DependentUpon>
+    </EmbeddedResource>
+    <EmbeddedResource Include="Properties\Resources.resx">
+      <Generator>ResXFileCodeGenerator</Generator>
+      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
+      <SubType>Designer</SubType>
+    </EmbeddedResource>
+    <Compile Include="Properties\Resources.Designer.cs">
+      <AutoGen>True</AutoGen>
+      <DependentUpon>Resources.resx</DependentUpon>
+    </Compile>
+    <None Include="Properties\Settings.settings">
+      <Generator>SettingsSingleFileGenerator</Generator>
+      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
+    </None>
+    <Compile Include="Properties\Settings.Designer.cs">
+      <AutoGen>True</AutoGen>
+      <DependentUpon>Settings.settings</DependentUpon>
+      <DesignTimeSharedInput>True</DesignTimeSharedInput>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="App.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+</Project>
\ No newline at end of file
diff --git a/BlockchainAssignment/HashCode/HashTools.cs b/BlockchainAssignment/HashCode/HashTools.cs
new file mode 100644
index 0000000..4caf583
--- /dev/null
+++ b/BlockchainAssignment/HashCode/HashTools.cs
@@ -0,0 +1,45 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Security.Cryptography;
+using System.Collections;
+
+namespace BlockchainAssignment.HashCode {
+
+    public static class HashTools
+    {
+        // Takes byte array and returns hexadecimal string
+        public static string ByteArrayToString(byte[] ba)
+        {
+            StringBuilder hex = new StringBuilder(ba.Length * 2);
+
+            foreach (byte b in ba)
+                hex.AppendFormat("{0:x2}", b);
+            
+            return hex.ToString();
+        }
+
+        // Converts String to ByteArray
+        public static byte[] StringToByteArray(string hex)
+        {
+            return Enumerable.Range(0, hex.Length)
+                             .Where(x => x % 2 == 0)
+                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
+                             .ToArray();
+        }
+
+        public static String CombineHash(String hash1, String hash2)
+        {
+            Byte[] bytes1 = StringToByteArray(hash1);
+            Byte[] bytes2 = StringToByteArray(hash2);
+
+            SHA256 hashSys = SHA256Managed.Create();
+            Byte[] combinedbytes = hashSys.ComputeHash(bytes1.Concat(bytes2).ToArray());
+
+            return ByteArrayToString(combinedbytes);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/BlockchainAssignment/Program.cs b/BlockchainAssignment/Program.cs
new file mode 100644
index 0000000..ae22dac
--- /dev/null
+++ b/BlockchainAssignment/Program.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+
+namespace BlockchainAssignment
+{
+    static class Program
+    {
+        /// <summary>
+        /// The main entry point for the application.
+        /// </summary>
+        [STAThread]
+        static void Main()
+        {
+            Application.EnableVisualStyles();
+            Application.SetCompatibleTextRenderingDefault(false);
+            Application.Run(new BlockchainApp());
+        }
+    }
+}
diff --git a/BlockchainAssignment/Properties/AssemblyInfo.cs b/BlockchainAssignment/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..d9d7761
--- /dev/null
+++ b/BlockchainAssignment/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("BlockchainAssignment")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("BlockchainAssignment")]
+[assembly: AssemblyCopyright("Copyright ©  2020")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("a7a15326-a321-4e6d-bc72-e4289d6def38")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/BlockchainAssignment/Properties/Resources.Designer.cs b/BlockchainAssignment/Properties/Resources.Designer.cs
new file mode 100644
index 0000000..e08976a
--- /dev/null
+++ b/BlockchainAssignment/Properties/Resources.Designer.cs
@@ -0,0 +1,71 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.42000
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace BlockchainAssignment.Properties
+{
+
+
+    /// <summary>
+    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    /// </summary>
+    // This class was auto-generated by the StronglyTypedResourceBuilder
+    // class via a tool like ResGen or Visual Studio.
+    // To add or remove a member, edit your .ResX file then rerun ResGen
+    // with the /str option, or rebuild your VS project.
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    internal class Resources
+    {
+
+        private static global::System.Resources.ResourceManager resourceMan;
+
+        private static global::System.Globalization.CultureInfo resourceCulture;
+
+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
+        internal Resources()
+        {
+        }
+
+        /// <summary>
+        ///   Returns the cached ResourceManager instance used by this class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Resources.ResourceManager ResourceManager
+        {
+            get
+            {
+                if ((resourceMan == null))
+                {
+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BlockchainAssignment.Properties.Resources", typeof(Resources).Assembly);
+                    resourceMan = temp;
+                }
+                return resourceMan;
+            }
+        }
+
+        /// <summary>
+        ///   Overrides the current thread's CurrentUICulture property for all
+        ///   resource lookups using this strongly typed resource class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Globalization.CultureInfo Culture
+        {
+            get
+            {
+                return resourceCulture;
+            }
+            set
+            {
+                resourceCulture = value;
+            }
+        }
+    }
+}
diff --git a/BlockchainAssignment/Properties/Resources.resx b/BlockchainAssignment/Properties/Resources.resx
new file mode 100644
index 0000000..af7dbeb
--- /dev/null
+++ b/BlockchainAssignment/Properties/Resources.resx
@@ -0,0 +1,117 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers & schema ...
+    <resheader name="resmimetype">text/microsoft-resx</resheader>
+    <resheader name="version">2.0</resheader>
+    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
+    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
+    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
+    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
+    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
+        <value>[base64 mime encoded serialized .NET Framework object]</value>
+    </data>
+    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
+        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
+        <comment>This is a comment</comment>
+    </data>
+                
+    There are any number of "resheader" rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    -->
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
\ No newline at end of file
diff --git a/BlockchainAssignment/Properties/Settings.Designer.cs b/BlockchainAssignment/Properties/Settings.Designer.cs
new file mode 100644
index 0000000..af2a542
--- /dev/null
+++ b/BlockchainAssignment/Properties/Settings.Designer.cs
@@ -0,0 +1,30 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.42000
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace BlockchainAssignment.Properties
+{
+
+
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
+    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
+    {
+
+        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
+
+        public static Settings Default
+        {
+            get
+            {
+                return defaultInstance;
+            }
+        }
+    }
+}
diff --git a/BlockchainAssignment/Properties/Settings.settings b/BlockchainAssignment/Properties/Settings.settings
new file mode 100644
index 0000000..3964565
--- /dev/null
+++ b/BlockchainAssignment/Properties/Settings.settings
@@ -0,0 +1,7 @@
+﻿<?xml version='1.0' encoding='utf-8'?>
+<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
+  <Profiles>
+    <Profile Name="(Default)" />
+  </Profiles>
+  <Settings />
+</SettingsFile>
diff --git a/BlockchainAssignment/Wallet/Wallet.cs b/BlockchainAssignment/Wallet/Wallet.cs
new file mode 100644
index 0000000..64e2be4
--- /dev/null
+++ b/BlockchainAssignment/Wallet/Wallet.cs
@@ -0,0 +1,129 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Security.Cryptography;
+using System.IO;
+
+namespace BlockchainAssignment.Wallet
+{
+    // Below is the code for generating key pairs and signatures, and validating signatures and private keys
+    class Wallet
+    {
+        // Public ID - viewable to all (Derived from the users private key)
+        public String publicID; 
+
+        public Wallet(out String privateKey)
+        {
+            privateKey = String.Empty;
+            
+            byte[] pubKey;
+            byte[] privKey;
+
+            CngKeyCreationParameters keyCreationParameters = new CngKeyCreationParameters();
+            keyCreationParameters.ExportPolicy = CngExportPolicies.AllowPlaintextExport;
+            keyCreationParameters.KeyUsage = CngKeyUsages.Signing;
+
+            CngKey key = CngKey.Create(CngAlgorithm.ECDsaP256, null, keyCreationParameters);
+
+            byte[] KeyBlob = key.Export(CngKeyBlobFormat.EccPrivateBlob); 
+            byte[] pubBlob = key.Export(CngKeyBlobFormat.EccPublicBlob);
+
+            pubKey = KeyBlob.Skip(8).Take(KeyBlob.Length - 40).ToArray();
+            privKey = KeyBlob.Skip(72).Take(KeyBlob.Length).ToArray();
+
+            publicID = Convert.ToBase64String(pubKey);
+            privateKey = Convert.ToBase64String(privKey);
+        }
+
+        public static bool ValidatePrivateKey(String privateKey, String publicID)
+        {
+            // Random string used to create a verification signature
+            String testHash = "0000abc1e11b8d37c1e1232a2ea6d290cddb0c678058c37aa766f813cbbb366e"; 
+
+            if (privateKey.Length != 44 || publicID.Length != 88)
+                return false;
+
+            String sig = CreateSignature(publicID, privateKey, testHash);
+
+            return ValidateSignature(publicID, testHash, sig);
+        }
+
+        // Validates if a signiture is legitimate.
+        // publicID is the Id of the wallet making the transaction.
+        // datahash is the hash of transaction
+        // datasig is the hash created by the private key and datahash
+        // The datasig can be validated with the above parameters.
+        public static bool ValidateSignature(String publicID, String datahash, String datasig)
+        {
+            if (publicID.Equals("Mine Rewards"))
+                publicID = "QfF3+9GgTxyGLvb+ScOAI6nJxBh8IyZbeD0r6BJBMyabZmyuP82yrSLKMq/F05OG0VZ4gg63uHFZUKzCu3wZuA==";
+            
+            if (publicID.Length != 88 || datasig.Equals("null"))
+                return false;
+            
+            CngKey key = createKey(publicID);
+
+            if (key == null)
+                return false;
+
+            ECDsaCng dsa = new ECDsaCng(key);
+            return dsa.VerifyData(Convert.FromBase64String(datahash), Convert.FromBase64String(datasig));
+        }
+
+        public static String CreateSignature(String publicID, String privateKey, String datahash) //need to have checks that publicID and privatekey are correct before using this method
+        {
+            CngKey key = createKey(publicID, privateKey);
+
+            if (key == null)
+                return "null";
+            
+            Byte[] datahashByte = Convert.FromBase64String(datahash);
+
+            ECDsaCng dsa = new ECDsaCng(key);
+            Byte[] byteSig = dsa.SignData(datahashByte);
+
+            return Convert.ToBase64String(byteSig);
+        }
+
+        private static CngKey createKey(String publicID, String privateKey = "")
+        {
+            try
+            {
+                if (publicID.Equals("Mine Rewards") && privateKey.Equals(String.Empty))
+                {
+                    publicID = "QfF3+9GgTxyGLvb+ScOAI6nJxBh8IyZbeD0r6BJBMyabZmyuP82yrSLKMq/F05OG0VZ4gg63uHFZUKzCu3wZuA==";
+                    privateKey = "mkT1Iu3YF4NSruHBptVytyDkNcxwemrkclndJH0+73o=";
+                }
+
+                CngKey key;
+                byte[] keyByte = new Byte[] { 69, 67, 83, 49, 32, 0, 0, 0 }; //first 8 bytes always same
+                byte[] publicBytes = Convert.FromBase64String(publicID);
+                byte[] keyByteCombine1 = new Byte[72];
+                keyByte.CopyTo(keyByteCombine1, 0);
+                publicBytes.CopyTo(keyByteCombine1, keyByte.Length);
+
+                if (!privateKey.Equals(String.Empty))
+                {
+                    keyByteCombine1[3] = 50; //must be set to 50 to be a private block
+                    byte[] privateBytes = Convert.FromBase64String(privateKey);
+                    byte[] keyByteCombine2 = new Byte[104];
+                    keyByteCombine1.CopyTo(keyByteCombine2, 0);
+                    privateBytes.CopyTo(keyByteCombine2, keyByteCombine1.Length);
+
+                    key = CngKey.Import(keyByteCombine2, CngKeyBlobFormat.EccPrivateBlob);
+                    return key;
+                }
+                key = CngKey.Import(keyByteCombine1, CngKeyBlobFormat.EccPublicBlob);
+                return key;
+            }
+
+            catch (Exception error)
+            {
+                Console.WriteLine(error.ToString());
+                return null;
+            }
+        }
+    }
+}

commit cc041a7e5d72f82d3c792adb4597bc3a85eee9ae
Author: Luke Wilson <nk002734@student.reading.ac.uk>
Date:   Tue Feb 18 16:30:45 2025 +0000

    Add .gitattributes and .gitignore.

diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..1ff0c42
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,63 @@
+###############################################################################
+# Set default behavior to automatically normalize line endings.
+###############################################################################
+* text=auto
+
+###############################################################################
+# Set default behavior for command prompt diff.
+#
+# This is need for earlier builds of msysgit that does not have it on by
+# default for csharp files.
+# Note: This is only used by command line
+###############################################################################
+#*.cs     diff=csharp
+
+###############################################################################
+# Set the merge driver for project and solution files
+#
+# Merging from the command prompt will add diff markers to the files if there
+# are conflicts (Merging from VS is not affected by the settings below, in VS
+# the diff markers are never inserted). Diff markers may cause the following 
+# file extensions to fail to load in VS. An alternative would be to treat
+# these files as binary and thus will always conflict and require user
+# intervention with every merge. To do so, just uncomment the entries below
+###############################################################################
+#*.sln       merge=binary
+#*.csproj    merge=binary
+#*.vbproj    merge=binary
+#*.vcxproj   merge=binary
+#*.vcproj    merge=binary
+#*.dbproj    merge=binary
+#*.fsproj    merge=binary
+#*.lsproj    merge=binary
+#*.wixproj   merge=binary
+#*.modelproj merge=binary
+#*.sqlproj   merge=binary
+#*.wwaproj   merge=binary
+
+###############################################################################
+# behavior for image files
+#
+# image files are treated as binary by default.
+###############################################################################
+#*.jpg   binary
+#*.png   binary
+#*.gif   binary
+
+###############################################################################
+# diff behavior for common document formats
+# 
+# Convert binary document formats to text before diffing them. This feature
+# is only available from the command line. Turn it on by uncommenting the 
+# entries below.
+###############################################################################
+#*.doc   diff=astextplain
+#*.DOC   diff=astextplain
+#*.docx  diff=astextplain
+#*.DOCX  diff=astextplain
+#*.dot   diff=astextplain
+#*.DOT   diff=astextplain
+#*.pdf   diff=astextplain
+#*.PDF   diff=astextplain
+#*.rtf   diff=astextplain
+#*.RTF   diff=astextplain
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..9491a2f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,363 @@
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+##
+## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore
+
+# User-specific files
+*.rsuser
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+
+# Mono auto generated files
+mono_crash.*
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+[Ww][Ii][Nn]32/
+[Aa][Rr][Mm]/
+[Aa][Rr][Mm]64/
+bld/
+[Bb]in/
+[Oo]bj/
+[Oo]ut/
+[Ll]og/
+[Ll]ogs/
+
+# Visual Studio 2015/2017 cache/options directory
+.vs/
+# Uncomment if you have tasks that create the project's static files in wwwroot
+#wwwroot/
+
+# Visual Studio 2017 auto generated files
+Generated\ Files/
+
+# MSTest test Results
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+
+# NUnit
+*.VisualState.xml
+TestResult.xml
+nunit-*.xml
+
+# Build Results of an ATL Project
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+
+# Benchmark Results
+BenchmarkDotNet.Artifacts/
+
+# .NET Core
+project.lock.json
+project.fragment.lock.json
+artifacts/
+
+# ASP.NET Scaffolding
+ScaffoldingReadMe.txt
+
+# StyleCop
+StyleCopReport.xml
+
+# Files built by Visual Studio
+*_i.c
+*_p.c
+*_h.h
+*.ilk
+*.meta
+*.obj
+*.iobj
+*.pch
+*.pdb
+*.ipdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*_wpftmp.csproj
+*.log
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+*.VC.db
+*.VC.VC.opendb
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# Visual Studio Trace Files
+*.e2e
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# AxoCover is a Code Coverage Tool
+.axoCover/*
+!.axoCover/settings.json
+
+# Coverlet is a free, cross platform Code Coverage Tool
+coverage*.json
+coverage*.xml
+coverage*.info
+
+# Visual Studio code coverage results
+*.coverage
+*.coveragexml
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# Note: Comment the next line if you want to checkin your web deploy settings,
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# Microsoft Azure Web App publish settings. Comment the next line if you want to
+# checkin your Azure Web App publish settings, but sensitive information contained
+# in these scripts will be unencrypted
+PublishScripts/
+
+# NuGet Packages
+*.nupkg
+# NuGet Symbol Packages
+*.snupkg
+# The packages folder can be ignored because of Package Restore
+**/[Pp]ackages/*
+# except build/, which is used as an MSBuild target.
+!**/[Pp]ackages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/[Pp]ackages/repositories.config
+# NuGet v3's project.json files produces more ignorable files
+*.nuget.props
+*.nuget.targets
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Windows Store app package directories and files
+AppPackages/
+BundleArtifacts/
+Package.StoreAssociation.xml
+_pkginfo.txt
+*.appx
+*.appxbundle
+*.appxupload
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!?*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.jfm
+*.pfx
+*.publishsettings
+orleans.codegen.cs
+
+# Including strong name files can present a security risk
+# (https://github.com/github/gitignore/pull/2483#issue-259490424)
+#*.snk
+
+# Since there are multiple workflows, uncomment next line to ignore bower_components
+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
+#bower_components/
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+ServiceFabricBackup/
+*.rptproj.bak
+
+# SQL Server files
+*.mdf
+*.ldf
+*.ndf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+*.rptproj.rsuser
+*- [Bb]ackup.rdl
+*- [Bb]ackup ([0-9]).rdl
+*- [Bb]ackup ([0-9][0-9]).rdl
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+node_modules/
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
+*.vbw
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+paket-files/
+
+# FAKE - F# Make
+.fake/
+
+# CodeRush personal settings
+.cr/personal
+
+# Python Tools for Visual Studio (PTVS)
+__pycache__/
+*.pyc
+
+# Cake - Uncomment if you are using it
+# tools/**
+# !tools/packages.config
+
+# Tabs Studio
+*.tss
+
+# Telerik's JustMock configuration file
+*.jmconfig
+
+# BizTalk build output
+*.btp.cs
+*.btm.cs
+*.odx.cs
+*.xsd.cs
+
+# OpenCover UI analysis results
+OpenCover/
+
+# Azure Stream Analytics local run output
+ASALocalRun/
+
+# MSBuild Binary and Structured Log
+*.binlog
+
+# NVidia Nsight GPU debugger configuration file
+*.nvuser
+
+# MFractors (Xamarin productivity tool) working folder
+.mfractor/
+
+# Local History for Visual Studio
+.localhistory/
+
+# BeatPulse healthcheck temp database
+healthchecksdb
+
+# Backup folder for Package Reference Convert tool in Visual Studio 2017
+MigrationBackup/
+
+# Ionide (cross platform F# VS Code tools) working folder
+.ionide/
+
+# Fody - auto-generated XML schema
+FodyWeavers.xsd
\ No newline at end of file
